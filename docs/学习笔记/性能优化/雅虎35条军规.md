# 雅虎35条军规

## 前言

前端性能优化是现代Web开发中至关重要的一环，直接影响用户体验、搜索引擎排名和商业价值。雅虎（Yahoo）开发者网络在2007年提出的35条前端性能优化规则，至今仍是业界公认的性能优化黄金标准。

![雅虎35条军规](/public/assets/yahu_1.png)

本文档整理了完整的35条军规，按以下7个类别系统归纳：

| 类别 | 规则数量 | 主要关注点 |
|------|----------|------------|
| **页面内容** | 10条 | HTTP请求、DNS、重定向、缓存等 |
| **服务器** | 7条 | CDN、压缩、缓存头、ETag等 |
| **Cookie** | 2条 | Cookie大小和域名策略 |
| **CSS** | 4条 | 样式表位置和优化 |
| **JavaScript** | 6条 | 脚本位置、压缩和DOM操作 |
| **图片** | 4条 | 图片优化和Sprite技术 |
| **移动端** | 2条 | 移动设备特殊考虑 |

接下来将详细介绍每个类别的具体规则和现代化实践方案。

---

**📄 页面内容**

## 1. 减少HTTP请求

Web 前端 80% 的响应时间花在图片、样式、脚本等资源下载上。减少HTTP请求是提高页面加载速度的重要手段。减少HTTP请求可以通过以下几种方式：

- 合并JS/CSS文件。服务器端（CDN）自动合并，基于Node.js的文件合并工具，通过把所有脚本放在一个文件中的方式来减少请求数。
- 使用CSS Sprite雪碧图将背景图片合并成一个文件，通过background-image 和 background-position 控制显示
- 行内图片（Base64编码）。使用Data URI scheme将图片嵌入HTML或者CSS中；或者将CSS、JS、图片直接嵌入HTML中，会增加文件大小，也可能产生浏览器兼容及其他性能问题。

## 2. 减少DNS查询

用户输入URL后，浏览器首先要查询域名（hostname）对应服务器的IP地址，一般需要耗费20-120毫秒时间。DNS查询完成之前，浏览器无法从服务器下载任何数据。

基于性能考虑，ISP、局域网、操作系统、浏览器都会有相应的 DNS 缓存机制。

**DNS缓存机制：**

- IE缓存30分钟，可通过注册表中DnsCacheTimeout项设置
- Firefox缓存1分钟，通过network.dnsCacheExpiration配置
- Chrome等现代浏览器也有相应的DNS缓存策略

另外需要注意的是这里有一个矛盾，减少不同的域名可减少 DNS 查找，同时也减少了页面下载资源文件的并发量。也就是说，虽然避免 DNS 查找削减了响应时间，但是减少并行下载数量却增加了响应时间。原则是把组件分散在 2~4 个域名下，控制好数量，这是同时减少 DNS 查找和允许并发下载的折中方案。

::: tip 注解

为什么通过减少DNS查询能够优化？
1. 时间开销
每次DNS查询需要消耗20-120毫秒时间，而查询未完成前会阻塞浏览器下载资源。多个域名=多次DNS查询=累积延迟。这也是为什么2～4个域名是最佳实践，过少域名DNS查询次数虽然减少了，但并发下载受限，而过多域名DNS查询开销过大，并发下载量多。

2. 网络开销
用户请求 → 本地DNS缓存 → 递归DNS服务器 → 根域名服务器 → 顶级域名服务器 → 权威域名服务器
每一个环节都有网络延迟，影响整体性能。

3. 浏览器行为
浏览器必须先完成DNS解析才能建立TCP连接，而解析过程遇到新域名就要暂停等待DNS解析。

具体场景：
假设页面有10个资源分布在5个不同域名：
 - 没有DNS缓存时：5 × 80ms(平均DNS查询) = 400ms 额外延迟
 - 有DNS缓存时：第一次访问后续页面几乎无DNS开销
这就是为什么DNS查询优化对首次访问和缓存过期后的访问影响最大的原因！
所以减少DNS查询本质上是在减少这种串行阻塞带来的时间开销。

DNS查询优化具体方法

1. DNS预解析设置
<!-- 预解析即将用到的域名 -->
<link rel="dns-prefetch" href="//example.com">

<!-- 对于HTTPS站点，还可以预连接 -->
<link rel="preconnect" href="https://fonts.googleapis.com">

2. 服务器DNS优化
设置合理的TTL值

3. CDN配置优化
将静态资源分布到少数几个CDN域名，不同资源分散在不同域名下

:::

## 3. 避免重定向

HTTP重定向通过301/302状态码实现。下面是一个有301状态码的HTTP头

```text
HTTP/1.1 301 Moved Permanently 
Location: http://example.com/newuri
Content-Type: text/html
```

浏览器会自动跳转到Location域指明的URL。重定向需要的所有信息都在HTTP头部，而响应体一般是空的。其实额外的HTTP头，比如Expires和Cache-Control也表示重定向。除此之外还有别的跳转方式：refresh元标签和JavaScript，但如果你必须得做重定向，最好用标准的3xxHTTP状态码，主要是为了让返回按钮能正常使用。

牢记重定向会拖慢用户体验，在用户和HTML文档之间插入重定向会延迟页面上的所有东西，页面无法渲染，组件也无法开始下载，直到HTML文档被送达浏览器。

有一种常见的极其浪费资源的重定向，而且web开发人员一般都意识不到这一点，就是URL尾部缺少一个斜线的时候。例如，跳转到`http://astrology.yahoo.com/astrology`会返回一个重定向到`http://astrology.yahoo.com/astrology/`的301响应（注意添在尾部的斜线）。在Apache中可以用Alias，mod_rewrite或者DirectorySlash指令来取消不必要的重定向。

重定向最常见的用途是把旧站点连接到新的站点，还可以连接同一站点的不同部分，针对用户的不同情况（浏览器类型，用户帐号类型等等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用Alias和mod_rewrite，前提是两个代码路径都在相同的服务器上。如果是因为域名变化而使用了重定向，就可以创建一条CNAME（创建一个指向另一个域名的DNS记录作为别名）结合Alias或者mod_rewrite指令。

::: tip 注解

Apache是传统Web服务器的标配，而我们现在更多是使用Nginx，Node.js服务器等。

需要手动配置Apache的配置文件，添加以下内容：

```apache
<VirtualHost *:80>
    DocumentRoot /var/www/html
    DirectoryIndex index.html
    # 处理路由重定向等...
</VirtualHost>
```

雅虎35条军规写于2007年，那时前端工程化还不发达，需要更多地考虑服务器配置。

现在我们可以忽视掉这个优化方法。

:::

## 4. 缓存Ajax请求

要提高性能，优化Ajax响应至关重要。最重要的提高Ajax性能的方法就是让响应变得可缓存，就像在添上Expires或者Cache-Control HTTP头中讨论的一样。

**其他适用于Ajax的优化规则：**

- **Gzip组件**：Ajax响应数据也应该启用Gzip压缩，特别是返回JSON或XML数据时，可以显著减少传输大小
- **减少DNS查找**：Ajax请求的API域名也要考虑DNS优化，避免频繁的跨域请求导致额外的DNS查询
- **压缩JavaScript**：处理Ajax请求的相关JavaScript代码（如jQuery、axios等库）也需要压缩
- **避免重定向**：Ajax请求的URL路径要避免301/302重定向，否则会增加请求延迟
- **配置ETags**：Ajax响应也要配置合适的ETag头，利用浏览器缓存机制减少不必要的数据传输

这些网络层优化规则对Ajax请求同样有效，应当一并考虑。

::: tip 注解

这一块就是http缓存机制，目前这种优化也是主流方案。

Expires 是HTTP/1.0的缓存头，指定资源的过期时间（绝对时间）

**服务器响应头示例**
```http
Expires: Wed, 21 Oct 2024 07:28:00 GMT
```

**设置示例：**

```js
// Node.js/Express
app.get('/api/data', (req, res) => {
  const expiryDate = new Date();
  expiryDate.setHours(expiryDate.getHours() + 24); // 24小时后过期
  res.set('Expires', expiryDate.toUTCString());
  res.json({ data: 'some data' });
});
```

```nginx
// Nginx配置
location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
    expires 1y;  # 静态资源1年过期
}

location /api/ {
    expires 1h;  # API数据1小时过期
}
```

Cache-Control 是HTTP/1.1的缓存头，功能更强大，优先级高于Expires：

常用指令：

**基本缓存控制**

- Cache-Control: max-age=3600                    # 缓存1小时
- Cache-Control: no-cache                        # 每次都验证，但可以缓存
- Cache-Control: no-store                        # 完全不缓存
- Cache-Control: must-revalidate                 # 过期后必须重新验证

**组合使用**
- Cache-Control: public, max-age=86400           # 公共缓存，24小时
- Cache-Control: private, max-age=300            # 私有缓存，5分钟
- Cache-Control: no-cache, must-revalidate       # 强制验证

**设置示例：**

```js
// Express.js 不同类型资源的缓存策略
app.use('/static', express.static('public', {
  maxAge: '1y',  // 静态资源长期缓存
  setHeaders: (res, path) => {
    if (path.endsWith('.html')) {
      res.setHeader('Cache-Control', 'no-cache'); // HTML文件不缓存
    }
  }
}));

// API响应缓存
app.get('/api/user/:id', (req, res) => {
  res.set('Cache-Control', 'private, max-age=300'); // 用户数据5分钟
  res.json({ user: userData });
});

app.get('/api/config', (req, res) => {
  res.set('Cache-Control', 'public, max-age=3600'); // 配置数据1小时
  res.json({ config: configData });
});

// 实时数据不缓存
app.get('/api/realtime', (req, res) => {
  res.set('Cache-Control', 'no-store');
  res.json({ timestamp: Date.now() });
});
```

:::

## 5. 延迟加载

页面初始加载时哪些内容是绝对必需的？不在答案之列的资源都可以延迟加载。比如：

非首屏使用的数据、样式、脚本、图片等；
用户交互时才会显示的内容。

遵循「渐进增强」理念开发的网站：JavaScript用于增强用户体验，但没有（不支持） JavaScript也能正常工作，完全可以延迟加载JavaScript。

将首屏以外的HTML放在不渲染的元素中，如隐藏的`<textarea>`，或者type属性为非执行脚本的`<script>`标签中，减少初始渲染的DOM元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。

另一个常见的做法是图片的延迟加载（懒加载），具体逻辑是当用户滚动页面看到内容时，再加载所需图片。这种操作在较多图片的网页中，可以节省大量带宽，页面渲染速度也会变快。

::: tip 注解

延迟加载（即懒加载）一直都是优化的重要手段。主要方案有以下：

1. 图片懒加载（Lazy Loading）
- Intersection Observer API（现代浏览器推荐）
- 原生 loading="lazy" 属性（最简单）
- 传统滚动事件监听

2. 代码分割（Code Splitting）
- 动态导入import()（ES2020）
- React.lazy 懒加载组件 + Suspense 占位符
- Vue 异步组件（Vue3）
- Webpack 代码分割

3. 路由级别的懒加载

4. 内容延迟渲染
- 虚拟滚动（大列表优化）
- 分页懒加载

5. 资源预加载策略
- preload 预加载关键资源
- prefetch 预加载可能需要的资源
- preconnect/dns-prefetch 预连接外部域名
:::

## 6. 预加载

预加载可能看起来和延迟加载是相反的，但它其实有不同的目标。通过预加载组件可以充分利用浏览器空闲的时间来请求将来会用到的组件（图片，样式和脚本）。用户访问下一页的时候，大部分组件都已经在缓存里了，所以在用户看来页面会加载得更快。

实际应用中有以下几种预加载的类型：

- 无条件预加载：尽快开始加载，获取一些额外的组件。以`google.com`为例，首页加载完成后会立即下载一个Sprite图片。这个图片并不是首页需要的，而是搜索结果页面上的内容。
- 有条件预加载：根据用户操作猜测用户将要跳转到哪里并据此预加载。在search.yahoo.com的输入框里键入内容后，可以看到那些额外组件是怎样请求加载的。
- 提前预加载：在推出新设计之前预加载。经常在重新设计之后会听到：“这个新网站不错，但比以前更慢了”，一部分原因是用户访问先前的页面都是有旧缓存的，但新的却是一种空缓存状态下的体验。可以通过在将要推出新设计之前预加载一些组件来减轻这种负面影响，老站可以利用浏览器空闲的时间来请求那些新站需要的图片和脚本。

::: tip 注解

预加载和懒加载看似矛盾，实际上是互补的优化策略：

**核心区别：**
- 懒加载：推迟加载暂时不需要的资源，优化首屏加载时间
- 预加载：提前加载即将需要的资源，优化后续页面的加载体验

**应用场景：**
1. 懒加载用于：首屏以外的图片、非关键CSS/JS、下方内容等
2. 预加载用于：下一页面的关键资源、用户可能访问的资源、关键路径资源

**协同工作：**
首屏 → 懒加载非关键资源 → 同时预加载下个页面资源 → 提升整体用户体验

**预加载具体方案：**

1. **Resource Hints（资源提示）**
- dns-prefetch 预解析DNS
- preconnect 预连接（DNS + TCP + TLS）
- preload 预加载关键资源
- prefetch 预获取可能需要的资源

2. **JavaScript 动态预加载**
- 图片预加载 preloadImages
- 脚本预加载 preloadScript
- 样式预加载 preloadCSS

3. **Web API 预加载**
- Service Worker 预缓存
- Intersection Observer 预加载

4. **模块预加载（现代框架）**
- React - 路由级预加载
- Vue - 异步组件预加载
- Next.js - 自动预加载

:::

## 7. 减少DOM操作

一个复杂的页面意味着要下载更多的字节，而且用JavaScript访问DOM也会更慢。举个例子，想要添加一个事件处理器的时候，循环遍历页面上的500个DOM元素和5000个DOM元素是有区别的。

从以下几个角度考虑移除不必要的标记：
- 是否还在使用表格布局
- 塞进去更多的`</div>`仅为解决布局问题，也许有更好、更语义化的标记
- 能否通过伪元素实现的功能，就没必要添加额外元素，如清除浮动

DOM元素的数量很容易测试，只需要在控制台里输入：
```js
document.getElementsByTagName('*').length
```

::: tip 注解

**为什么虚拟DOM时代仍需要减少DOM操作？**

1. **虚拟DOM不是万能的**
   - 虚拟DOM只是优化了DOM操作过程，但最终仍要操作真实DOM
   - 虚拟DOM diff算法复杂度与节点数量相关，节点越多计算越耗时
   - 大量DOM节点会增加虚拟DOM树的大小和比较成本

2. **浏览器渲染性能限制**
   - 即使是虚拟DOM最终更新到真实DOM时，浏览器仍需重排重绘
   - DOM节点越多，Layout（布局）和Paint（绘制）越耗时
   - 过多DOM节点会增加内存占用，影响垃圾回收效率

3. **JS引擎执行效率**
   - DOM查询和遍历操作的时间复杂度与DOM数量正相关
   - 事件代理的效率会因DOM层级过深而下降
   - CSS选择器匹配性能也与DOM结构复杂度相关

**减少DOM操作的具体方案：**

1. 组件化架构优化，避免平铺式大量DOM，组件化精简DOM
2. 虚拟滚动（长列表优化）
3. DOM批量操作，避免在for循坏里面逐个操作DOM，而是使用DocumentFragment批量操作DOM和innerHTML批量更新DOM
4. CSS优化减少DOM，避免使用额外DOM实现效果，而是使用CSS伪元素替代
5. 事件委托减少事件绑定，避免给每个元素绑定事件，而是使用事件委托
6. 现代框架最佳实践，使用Key优化列表渲染，React使用React.memo和useMemo避免不必要的重渲染，Vue使用v-memo缓存复杂计算结果

即使在虚拟DOM时代，减少DOM操作仍是性能优化的基础。关键是要理解虚拟DOM的工作原理，合理运用组件化、虚拟滚动、批量操作等技术，在减少DOM节点数量的同时提升用户体验。

:::

## 8. 使用多个域名

Chrome 等现代化浏览器，都会有同域名限制并发下载数的情况，不同的浏览器及版本都不一样，简单的情况如下：

- Chrome34/32	并发下载数为6
- IE10	并发下载数为6
- IE11		并发下载数为13
- Firefox27/26		并发下载数为6
- Safari7.0.1		并发下载数为6

使用不同的域名可以最大化下载线程，但注意保持在 2~4 个域名内，以避免 DNS 查询损耗。

例如，动态内容放在`csspod.com`上，静态资源放在`static.csspod.com`上。这样还可以禁用静态资源域下的 Cookie，减少数据传输，详见 Cookie 优化。

::: tip 注解

这条内容已经过时。

同域名并发限制是指浏览器为了访问服务器过载和优化性能，对同一个域名下的并发http请求数量设置的限制，通常为6个。

HTTP1/1.1时代，默认限制每个域名同时建立约为6个并发TCP连接。

HTTP2时代，引入了多路复用技术，在一个TCP连接上可以同时发送和接收多个请求和响应。

**现代替代方案**

1. **启用HTTP/2**：确保服务器支持HTTP/2协议
2. **资源合并**：使用模块打包工具（Webpack、Vite等）合并资源
3. **CDN优化**：使用支持HTTP/2的CDN服务

如何分辨网站使用的HTTP版本？

- 按F12打开开发者工具
- 切换到Network标签页
- 刷新页面
- 查看请求列表
- 右键标题栏，勾选"Protocol"列
- 查看协议列：h2表示HTTP/2，http/1.1表示HTTP/1.1

HTTP1和HTTP2的区别：

报文格式：
HTTP/1.x 使用纯文本的报文。而HTTP/2 将数据分割为更小的、二进制格式的帧进行传输，并且在传输过程中可以乱序发送，然后在接收端根据流标识重新组装。

多路复用：
HTTP/1.1 在单个TCP 连接中一次只能处理一个请求。HTTP/2 则在一个TCP 连接中可以同时传输多个数据流（一个连接多个请求），即多路复用，解决了HTTP/1.1 中的队头阻塞问题，提高了效率。

头部压缩：
HTTP/1.x 头部信息庞大且每次请求都会重复发送。HTTP/2 使用HPACK 算法对头部进行压缩，通过索引表避免重复传输相同的头部信息，大幅减少了数据传输量。

服务器推送：
HTTP/2 允许服务器在客户端请求之前，主动将某些可能需要的资源“推送”给客户端，这样客户端可以更早地获取到所有资源，从而提高网页加载速度。

:::

## 9. 减少iframe使用

用`<iframe>`可以把一个HTML文档插入到父文档里，重要的是明白`<iframe>`是如何工作的并高效地使用它。

**`<iframe>`的优点：**
- 可以用来加载速度较慢的第三方资源，如广告、徽章；
- 可用作安全沙箱；
- 可以并行下载脚本。

**`<iframe>`的缺点：**
- 加载代价昂贵，即使是空的页面；
- 阻塞页面 load 事件触发；
- Iframe 完全加载以后，父页面才会触发 load 事件。 Safari、Chrome 中通过 JavaScript 动态设置 iframe src 可以避免这个问题。
- 缺乏语义。

::: tip 注解

时至今日，iframe仍然有较多的使用场景，比如：
- 支付宝、微信支付等在线支付；内嵌高德、百度地图；内嵌YouTube视频等第三方内容集成

**现代化替代方案**

1. 使用Web Components替代iframe，Web Components是一种新的标准化组件系统，可以自定义标签，实现组件的封装和复用，避免iframe的语义化和SEO问题。
2. 微前端架构，qiankun、single-spa等微前端框架，可以实现多个子应用的独立加载和卸载，避免iframe的阻塞问题。

:::

## 10. 杜绝404

HTTP 请求是昂贵的，所以发出 HTTP 请求但获得没用的响应（如 404）是完全不必要的，并且会降低用户体验。

一些网站会有特别的 404 页面提高用户体验，但这仍然会浪费服务器资源。更糟糕的是当链接指向外部 js 但却得到 404 结果。这样首先会降低（占用）并行下载数，其次浏览器可能会把 404 响应体当作 js 来解析，试图从里面找出可用的东西。


**🖥️ 服务器** 

## 11. 使用CDN

用户与服务器的物理距离对响应时间也有影响。把内容部署在多个地理位置分散的服务器上能让用户更快地载入页面。

网站 80-90% 响应时间消耗在资源下载上，减少资源下载时间是性能优化的黄金法则。相比分布式架构的复杂和巨大投入，静态内容分发网络（CDN）可以以较低的投入，获得加载速度有效提升。

内容分发网络（CDN）是一组分散在不同地理位置的web服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数（hop）最少的或者响应时间最快的服务器。

::: tip 注解

CDN 服务是一种很好的优化手段，也是目前我司使用的一种重要手段。Cloudflare、七牛云 CDN、融合云/融合 CDN等。特别是海外业务，有一些地区网络存在波动问题，使用 CDN 服务可以显著提升访问速度。

另外这些CDN厂商也支持设置缓存策略。

:::

## 12. 添加Expires或者Cache-Control头

这条规则有两个方面：

- 对于静态组件：通过设置一个遥远的将来时间作为 Expires 来实现永不失效
- 多余动态组件：用合适的 Cache-Control HTTP 头来让浏览器进行条件性的请求

网页设计越来越丰富，这意味着页面里有更多的脚本，图片。站点的新访客可能还是不得不提交几个 HTTP 请求，但通过使用有效期能让组件变得可缓存，这避免了在接下来的浏览过程中不必要的 HTTP 请求。

一般来讲，浏览器等客户端都会有缓存机制来减少 HTTP 请求的数目和大小，让页面能够更快加载。Web 服务器通过有效期 HTTP 响应头来告诉客户端，页面的各个组件应该被缓存多久。用一个遥远的将来时间做有效期，告诉浏览器这个响应在 2022 年 4 月 15 日前不会改变。

```http
Expires: Thu, 15 Apr 2022 20:00:00 GMT
```

Cache-Control 使用 max-age 指令指定组件被缓存多久，它以秒为单位定义了一个更新期限。使用带有 max-age 的 Cache-Control 可以消除 Expires 的限制，但对于不支持 HTTP1.1 的应用（在 2019 的现在很少很少了），仍希望使用 Expires 头。可以同时指定这两个响应头，如果两者同时出现时，HTTP 规范规定 max-age 指令将重写 Expires 头。

当出现了 Expires 头时，直到过期时间为止一直会使用缓存的版本，浏览器不会检查任何更新，直到过了过期时间。为了确保用户能够获取组件的最新版本，需要在所有的 HTML 页面中修改组件的文件名。Yahoo 在此使用了将版本号嵌入在组件的文件名中的方法，简而言之就是通过修改文件名的方式来重置缓存。

::: tip 注解

这个优化，其实就是http请求缓存。

具体可以参考我的另一篇文章[http请求缓存](/学习笔记/性能优化/http请求缓存)。

:::

## 13. Gzip压缩

压缩可以通过减少HTTP请求响应的大小来缩短响应时间。

从 HTTP1.1 开始，Web 客户端可以通过 HTTP 请求中的 Accept-Encoding 头来标识对压缩的支持。

```http
Accept-Encoding: gzip, deflate, br
```

如果 Web 服务器看到请求中的这个头，就会使用客户端列出的方法中的一种来压缩响应。Web 服务器通过响应中的 Content-Encoding 头来告知 Web 客户端：

```http
Content-Encoding: gzip
```

Gzipping一般能够把响应压缩到70%左右，目前大约90%的通过浏览器的网络传输都支持gzip。

::: tip 注解

目前Gzip压缩已经成为了主流的压缩方式，浏览器默认支持，前端无需任何配置。但服务器需要配置才能启用Gzip压缩。

**Nginx配置示例：**
```nginx
# nginx.conf
http {
    # 启用gzip
    gzip on;
    
    # 压缩级别 1-9，级别越高压缩率越大但CPU消耗也越大
    gzip_comp_level 6;
    
    # 最小压缩文件大小，小于此大小的文件不压缩
    gzip_min_length 1000;
    
    # 压缩的文件类型
    gzip_types
        text/plain
        text/css
        text/js
        text/xml
        text/javascript
        application/javascript
        application/xml+rss
        application/json;
    
    # 为代理请求启用压缩
    gzip_proxied any;
    
    # 禁用IE6的gzip压缩（可选，IE6支持有问题）
    gzip_disable "msie6";
}
```

**Node.js Express配置示例：**
```js
const express = require('express');
const compression = require('compression');
const app = express();

// 启用gzip压缩中间件
app.use(compression({
    // 压缩级别
    level: 6,
    // 压缩阈值，小于此大小不压缩
    threshold: 1024,
    // 压缩算法
    strategy: compression.constants.Z_DEFAULT_STRATEGY
}));

app.get('/', (req, res) => {
    res.send('Hello World!');
});
```

**Vite配置示例：**
```js
// vite.config.js
import { defineConfig } from 'vite'
import viteCompression from 'vite-plugin-compression'

export default defineConfig({
  plugins: [
    viteCompression({
      verbose: true,          // 显示压缩结果
      disable: false,         // 不禁用压缩
      deleteOriginFile: false, // 保留原文件
      threshold: 10240,       // 10KB以上的文件才压缩
      algorithm: 'gzip',      // 使用gzip算法
      ext: '.gz',            // 压缩文件扩展名
    })
  ]
})
```

**最佳实践：**

1. **压缩文本类文件**：HTML、CSS、JS、JSON、XML、SVG等
2. **不压缩已压缩文件**：图片、视频、音频、压缩包等
3. **设置合理阈值**：太小的文件压缩收益不大，建议1KB以上才压缩
4. **选择合适压缩级别**：一般选择6级，平衡压缩率和CPU消耗
5. **CDN启用压缩**：如果使用CDN，确保CDN服务商也启用了Gzip
:::

## 14. 配置Etag

实体标记（Entity tags，ETag）是服务器和浏览器之间判断浏览器缓存中某个文件是否匹配服务器端原文件的一种机制。实体就是资源文件，如图片，脚本，样式等等。ETag 是比验证 last-modified 日期更高效的机制。

服务器这样设置组件的 ETag：

```http
HTTP/1.1 200 OK
Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT
ETag: "10c24bc-4ab-457e1c1f"
Content-Length: 12195
```

之后，如果浏览器要验证文件，它用 If-None-Match 头部来传 ETag 给服务器。如果 ETag 匹配，服务器返回 304（文件未变化），就不下载内容。这样就减少了 12195 个字节的响应体。

```
GET /i/yahoo.gif HTTP/1.1
Host: us.yimg.com
If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT
If-None-Match: "10c24bc-4ab-457e1c1f"
HTTP/1.1 304 Not Modified
```

ETag 的问题在于，通常使用文件的某些属性来构造它，这些属性对于特定的网站服务器来说是唯一的。在集群的情况下，当浏览器从一台服务器上获取了原始文件之后又尝试向另一台服务器来验证文件时，ETag 是不匹配的。这种情况是使用服务器集群的网站经常会遇到的问题。默认情况下，Apache 和 IIS 向 ETag 中嵌入的数据都会大大降低有效性验证的成功率。

如果不想用ETags提供的灵活的验证模型，最好把所有的Etag全都去掉，可以用基于组件的时间戳的Last-ModifiedHTTP头验证，而且去掉ETag可以减少HTTP响应头以及后续请求的大小。

::: tip 注解

Etag 是http请求缓存中协商缓存的一种配置。

具体可以参考我的另一篇文章[http请求缓存](/学习笔记/性能优化/http请求缓存)。

:::

## 15. 尽早输出（flush）缓冲

当用户请求一个页面时，服务器需要用大约200到500毫秒来组装HTML页面，在这期间，浏览器闲等着数据到达。PHP中有一个flush()函数，允许给浏览器发送一部分已经准备完毕的HTML响应，以便浏览器可以在后台准备剩余部分的同时开始获取资源，好处主要体现在很忙的后台或者很“轻”的前端页面上（P.S. 也就是说，响应时耗主要在后台方面时最能体现优势）。

比较理想的清空缓冲区的位置是HEAD后面，因为HTML的HEAD部分通常更容易生成，并且允许引入任何CSS和JavaScript文件，这样就可以让浏览器在后台还在处理的时候就开始并行获取资源。

```php
<!-- css, js -->
</head>
<?php flush(); ?>
<body>
<!-- content -->
```

::: tip 注解

flush()确实是PHP等服务端语言的特有技术，而我们现在更多是使用Nuxt.js、Next.js等框架，这些框架会自动处理缓冲区，无需手动调用flush()函数。

Next.js是通过 Streaming SSR + Suspense 实现，在组件边界自动触发。

```tsx
export default function StreamingPage() {
  return (
    <html>
      <head><title>Loading</title></head>
      <body>
        <Suspense fallback={<div>Loading header...</div>}>
          <Header />
        </Suspense>
        <Suspense fallback={<div>Loading content...</div>}>
          <SlowContent />
        </Suspense>
      </body>
    </html>
  )
}
```

Nuxt.js是通过 Hybrid Rendering 实现，通过路由配置触发。

```ts
export default {
  nitro: {
    routeRules: {
      '/': { prerender: true },              // 预渲染
      '/api/**': { cors: true },             // API路由
      '/blog/**': { isr: 60 },              // ISR策略
      '/admin/**': { ssr: false },          // SPA模式
      '/stream': { 
        headers: { 'cache-control': 'no-cache' },
        experimentalNoScripts: true  // 流式渲染
      }
    }
  }
}
```

:::

## 16. Ajax请求使用GET请求

使用XMLHttpRequest时，浏览器的POST请求是通过一个两步的过程来实现的：先发送HTTP头，在发送数据Data。所以最好用GET请求，它只需要发送一个TCP报文（除非cookie特别多）。

POST请求的一个有趣的副作用是实际上没有发送任何数据，就像GET请求一样。正如HTTP说明文档中描述的，GET请求是用来检索信息的。所以它的语义只是用GET请求来请求数据，而不是用来发送需要存储到服务器的数据。

::: tip 注解

GET和POST是HTTP请求的两种基本方法，它们有以下主要区别：

### GET vs POST 详细对比表

| 特性 | GET | POST |
|------|-----|------|
| **后退按钮/刷新** | 无害 | 数据会被重新提交（浏览器应该告知用户数据会被重新提交） |
| **书签** | 可收藏为书签 | 不可收藏为书签 |
| **缓存** | 能被缓存 | 不能缓存 |
| **编码类型** | application/x-www-form-urlencoded | application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码 |
| **历史** | 参数保留在浏览器历史中 | 参数不会保存在浏览器历史中 |
| **对数据长度的限制** | 是的。当发送数据时，GET方法向URL添加数据；URL的长度是受限制的（URL的最大长度是2048个字符） | 无限制 |
| **对数据类型的限制** | 只允许ASCII字符 | 没有限制。也允许二进制数据 |
| **安全性** | 与POST相比，GET的安全性较差，因为所发送的数据是URL的一部分。在发送密码或其他敏感信息时绝不要使用GET！ | POST比GET更安全，因为参数不会被保存在浏览器历史或web服务器日志中 |
| **可见性** | 数据在URL中对所有人都是可见的 | 数据不会显示在URL中 |
| **语义** | 用于请求数据（幂等操作） | 用于提交数据到服务器进行处理（非幂等操作） |
| **幂等性** | ✅ 幂等（多次调用结果相同） | ❌ 非幂等（多次调用可能产生不同结果） |
| **副作用** | ❌ 无副作用（不改变服务器状态） | ✅ 有副作用（会改变服务器状态） |

### 使用场景对比

| 场景 | 推荐方法 | 原因 |
|------|----------|------|
| 搜索查询 | GET | 可缓存、可书签、无副作用 |
| 用户登录 | POST | 敏感信息、有副作用 |
| 文件上传 | POST | 大数据量、二进制数据 |
| 数据查询 | GET | 可缓存、幂等操作 |
| 创建订单 | POST | 有副作用、敏感操作 |
| 分页浏览 | GET | 可书签、可分享URL |
| 支付提交 | POST | 敏感信息、关键操作 |

:::

## 17. 避免图片src为空

图片标签的 src 属性值为空字符串可能以下面两种形式出现：

```html
<img src="" />
```

```js
var img = new Image(); 
img.src = "";
```

虽然src属性为空字符串，但浏览器仍然会向服务器发起一个HTTP请求：

- IE 向页面所在的目录发送请求；
- Safari、Chrome、Firefox向页面本身发送请求；
- Opera不执行任何操作。

空src产生请求的后果不容小觑：

- 意外发送大量的通信量对服务器来说是很伤的，尤其是在每天有几百万访问量页面的时候。
- 浪费服务器资源去生成一个根本不可能被看到的页面
- 可能会污染用户数据，如果追踪请求状态，要么通过cookie要么是其它方式，可能会破坏用户数据。即使图片请求并没有返回图片，整个HTTP头部也会被浏览器接受并读取，包括所有的cookie。虽然其余部分会被丢弃，但这可能已经造成破坏了。

问题的根本原因是各个浏览器在处理URI时的分歧，这在RFC 3986 – Uniform Resource Identifiers文档中有明确定义。如果URI是一个空串，会被看作一个相对URI，并按照5.2节定义的算法处理。实际情况是，Firefox、Safari和Chrome都是根据文档中5.4节列出的规范来处理空串，而IE并没有正确处理。据说在旧版本规范文档RFC 2396 – Uniform Resource Identifiers（被RFC 3986废弃了）中，所以从严格意义上来说浏览器处理相对URI的做法都是对的。问题是，在这种情形下，空串显然是无心的（P.S. 而不是什么相对URI）。

HTML5的4.8.2节有关于<img>标签src属性的描述，规定浏览器不再发送额外请求。

::: tip 注解

这条优化过时了。

现代浏览器当img元素的src属性为空字符串时，不会发起额外的网络请求。

浏览器会触发error事件，但不会产生网络请求。

::: 

**🍪 Cookie**

## 18. 减少Cookie大小

Cookie被用于身份认证、个性化设置等诸多用途。Cookie通过HTTP头在服务器和浏览器间来回传送，减少Cookie大小可以降低其对响应速度的影响。

- 去除不必要的 Cookie；
- 尽量压缩 Cookie 大小；
- 注意设置 Cookie 的 domain 级别，如无必要，不要影响到 sub-domain；
- 设置合适的过期时间。

::: tip 注解

HTTP2引入了头部压缩机制来减少头部冗余信息，但还是会携带Cookie。

所以优化Cookie大小还是有必要的。

:::

## 19. 静态资源使用无Cookie域名

当浏览器发送对静态图像的请求时，cookie也会一起发送，而服务器根本不需要这些cookie。它们只是增加了网络流量。所以你应该保证静态文件的请求是没有 Cookie 的。可以创建一个子域名来托管所有静态组件。

如果域名是`www.example.org`，可以把静态文件部署到`static.example.org`。然而，如果已经在顶级域`example.org`或者`www.example.org`设置了cookie，那么所有对`static.example.org`的请求都会含有这些cookie。这时候可以再买一个新域名，把所有的静态组件部署上去，并保持这个新域名不含cookie。Yahoo!用的是`yimg.com`，YouTube是`ytimg.com`，Amazon是`images-amazon.com`等等。

把静态组件部署在不含cookie的域下还有一个好处是有些代理可能会拒绝缓存带cookie的组件。有一点需要注意：如果不知道应该用`example.org`还是`www.example.org`作为主页，可以考虑一下cookie的影响。省略www的话，就只能把cookie写到`*.example.org`，所以因为性能原因最好用www子域，并且把cookie写到这个子域下。

::: tip 注解

这里很好的解释了为什么API请求地址和静态资源文件不使用同一个域名的原因。

:::

**🎨 CSS**

## 20. 把样式表放在`<head>`中

在Yahoo!研究性能的时候，我们发现把样式表放到文档的HEAD部分能让页面看起来加载地更快。这是因为把样式表放在head里能让页面逐步渲染。

关注性能的前端工程师想让页面逐步渲染。也就是说，我们想让浏览器尽快显示已有内容，这在页面上有一大堆内容或者用户网速很慢时显得尤为重要。给用户显示反馈（比如进度指标）的重要性已经被广泛研究过，并且被记录下来了。在我们的例子中，HTML页面就是进度指标！当浏览器逐渐加载页面头部，导航条，顶部logo等等内容的时候，这些都被正在等待页面加载的用户当作反馈，能够提高整体用户体验。

在很多浏览器（包括IE）中，把样式表放在HTML文档底部都会阻止页面逐渐渲染。这些浏览器阻塞渲染过程，以避免因为样式变动而重绘页面元素，用户这时就只能盯着空白页面。

HTML官方文档清楚地描述了样式表应该放在页面的HEAD里面：”Unlike A, [LINK] may only appear in the HEAD section of a document, although it may appear any number of times.”（不像a标签，link标签可能只出现在HEAD部分，虽然它能可以出现任意多次）。空白屏幕或者没有样式的falsh内容都是不可取的。理想方案就是遵循HTML官方文档，把样式表放在HTML文档的HEAD部分。

::: tip 注解

发现上文没有解释为什么把样式表放在HEAD中可以提高页面加载性能，这里加以补充。

1. **防止FOUC（Flash of Unstyled Content）**：浏览器从上到下的顺序解析HTML文档，把CSS放在`<head>`中，浏览器会在渲染页面内容之前就先加载和解析样式，避免页面在加载过程中出现短暂的无样式内容闪烁；
2. **提高页面加载性能**：浏览器可以在解析HTMl的同时并行下载CSS，样式优先加载，确保首次渲染时页面已经有正确的样式，减少重绘和重排次数；
3. **更好的用户体验**：用户看到的页面从一开始就是完整样式的，避免页面布局突然变化造成的视觉跳跃，提供更平滑的页面加载体验。

:::

## 21. 避免使用CSS表达式

用CSS表达式动态设置CSS属性，是一种强大又危险的方式。从IE5开始支持，但从IE8起就不推荐使用了。例如，可以用CSS表达式把背景颜色设置成按小时交替的：

```css
background-color: expression( (new Date()).getHours()%2 ? "#B8D4FF" : "#F08A00" );
```

上面的代码中，expression方法可以接受一个JavaScript表达式。CSS属性会被设置成表达式的计算结果。expression方法会被其它浏览器忽略，所以只有想办法实现跨浏览器的与IE一致的用户体验才有用。

表达式最大的问题是它们经常被重复计算，比我们想象的次数还要多。不仅仅是页面渲染和调整大小的时候，在页面被滚动，甚至用户在页面上移动鼠标时都会重新计算表达式。给CSS表达式添加一个计数器就可以追踪它重新计算的时间和频率，而在页面上动动鼠标就可以引发10000多次重新计算。

减少CSS表达式重新计算的一种方式就是用一次性表达式，即在表达式第一次计算后就把样式属性设置成一个明确的值，换掉表达式。如果必须要在页面的整个生命周期中动态设置样式属性，可以用事件处理器来代替CSS表达式。如果必须使用CSS表达式，要记得它们可能会被重复计算上千次，从而影响整个页面的性能。

::: tip 注解

这条优化内容已经无效。

CSS表达式（CSS Expression）是 IE 5~7 中的一个非标准特性，它允许在CSS中直接执行JavaScript代码。但由于性能问题，每当页面发生任何变化（滚动、鼠标移动、窗口调整）时都会重新计算，频繁重复执行；JavaScript执行会阻塞CSS解析和页面渲染；浏览器无法对这些动态表达式进行优化，所以已经废弃掉了。

取代的是现代CSS计算属性和预处理器计算。

**现代CSS计算属性：**
```css
/* ✅ 现代CSS - 性能良好，推荐使用 */
width: calc(100% - 20px);
height: calc(100vh - var(--header-height));
font-size: clamp(1rem, 2.5vw, 2rem);
transform: rotate(calc(var(--angle) * 1deg));
```

**预处理器计算（构建时计算）：**
```scss
/* ✅ SCSS - 构建时计算，运行时是静态值 */
$base-size: 16px;
.heading {
  font-size: $base-size * 1.5; // 编译为 font-size: 24px;
  margin: #{$base-size / 2} 0;  // 编译为 margin: 8px 0;
}
```

**性能对比：**

| 特性 | CSS表达式 | 现代CSS | 预处理器 |
|------|----------|---------|----------|
| **浏览器支持** | 仅IE5-7 | 现代浏览器 | 构建时处理 |
| **执行时机** | 频繁重复执行 | 仅在需要时计算 | 构建时一次性 |
| **性能影响** | 极差（阻塞渲染） | 良好（原生优化） | 最佳（静态值） |
| **GPU加速** | 不支持 | 支持 | 支持 |
| **可维护性** | 差（混合JS/CSS） | 好（纯CSS） | 好（变量管理） |

:::


## 22. 使用`<link>`代替`@import`

前面提到了一个最佳实践：为了实现逐步渲染，CSS应该放在顶部。

在IE中用@import与在底部用<link>效果一样，所以最好不要用它。

## 23. 不要使用filter

AlphaImageLoader 为 IE5.5-IE8 专有的技术，和 CSS 表达式一样，放进博物馆吧。IE 专有的 AlphaImageLoader 滤镜可以用来修复 IE7 之前的版本中半透明 PNG 图片的问题。在图片加载过程中，这个滤镜会阻塞渲染，卡住浏览器，还会增加内存消耗而且是被应用到每个元素的，而不是每个图片，所以会存在一大堆问题。

**⚡ JavaScript** 

## 24. 把脚本放在页面底部

浏览器下载脚本时，会阻塞其他资源并行下载，即使是来自不同域名的资源。因此，最好将脚本放在底部，以提高页面加载速度。

有时候，并不容易把脚本移动到底部。举个例子，如果脚本是用document.write插入到页面内容中的，就没办法再往下移了。还可能存在作用域问题，在多数情况下，这些问题都是可以解决的。可以考虑`<script>`的以下属性：

- defer 属性；
- HTML5 新增的async属性。

::: tip 注解
**async 和 defer 的区别：**

- async 属性：异步加载，不会阻塞页面解析，但执行时机不确定，并不保证任何特定的执行顺序。
- defer 属性：延迟加载，会阻塞页面解析，但执行时机确定，在 DOMContentLoaded 之前执行；

使用了 async 属性加载的脚本不会在下载时阻塞页面。这意味着在脚本执行完成之前，将无法为用户处理和渲染网页上的其余内容。无法保证脚本的运行次序。当页面的脚本之间彼此独立，且不依赖于本页面的其他任何脚本时，async 是最理想的选择。

使用 defer 属性加载的脚本将按照它们在页面上出现的顺序加载。在页面内容全部加载完毕之前，脚本不会运行，如果脚本依赖于 DOM 的存在（例如，脚本修改了页面上的一个或多个元素），这一点非常有用。

**总结：**

- async 和 defer 都指示浏览器在页面的其他部分（DOM 等）正在下载时，在一个单独的线程中下载脚本，因此在获取过程中页面加载不会被阻塞。
- 带有 async 属性的脚本将在下载完成后立即执行。这将阻塞页面，并不保证任何特定的执行顺序。
- 带有 defer 属性的脚本将按照它们的顺序加载，并且只有在所有脚本加载完毕后才会执行。
- 如果脚本应该立刻运行且没有任何依赖，那么应使用 async。
- 如果脚本需要等待页面解析，且依赖于其他脚本或 DOM，请使用 defer 加载脚本，并将关联的脚本按你想要浏览器加载它们的顺序置于相应 `<script>` 元素中。

:::


## 25. 使用外部JavaScript和CSS

在现实环境中使用外部文件通常会产生较快的页面，因为 JavaScript 和 CSS 有机会被浏览器缓存起来。对于内联的情况，由于 HTML 文档通常不会被配置为可以进行缓存的，所以每次请求 HTML 文档都要下载 JavaScript 和 CSS。所以，如果 JavaScript 和 CSS 在外部文件中，浏览器可以缓存它们，HTML 文档的大小会被减少而不必增加 HTTP 请求数量。

决定是否使用外部文件的关键在于被缓存的外部文件占请求的 HTML 文档数的比重。如果网站用户在每次会话中进行多次页面访问，同时页面重用了多个脚本和样式表，使用外部文件是很好的选择。

对于大多数网站而言，难以精确度量以判断是否使用内联或外部文件，此时建议是使用外部文件的方式。对于这个问题的一个例外是网站主页，由于主页对于响应时间要求更高，因此更加倾向于内联而不是外部文件。

对于内联文件而言，由于无法利用浏览器缓存，因此给人感觉依然比较低效。我们可以通过加载后下载和动态内联的方式来使得网站主页既可以获得内联的优势，同时也能缓存外部文件。

## 26. 压缩JavaScript和CSS

压缩具体来说就是从代码中去除不必要的字符以减少大小，从而提升加载速度。代码最小化就是去掉所有注释和不必要的空白字符（空格，换行和 tab）。

在 JavaScript 中这样做能够提高响应性能，因为要下载的文件变小了。两个最常用的 JavaScript 代码压缩工具是 JSMin 和 YUI Compressor，YUI compressor 还可以压缩 CSS。

混淆 是一种可选的源码优化措施，要比压缩更复杂，所以混淆过程也更容易产生 Bug。在对美国前十的网站调查中，压缩可以缩小 21%，而混淆能缩小 25%。虽然混淆的缩小程度更高，但比压缩风险更大。

除了压缩外部脚本和样式，行内的和块也可以压缩。即使启用了 gzip 模块，先进行压缩也能够缩小 5% 或者更多的大小。JavaScript 和 CSS 的用处越来越多，所以压缩代码会有不错的效果。

> 得益于 Node.js 的流行，开源社区涌现出许多高效、易用的前端优化工具，JavaScript 和 CSS 压缩类如 UglifyJS 2、csso、cssnano 等都是很成熟的工具。对于内嵌的 CSS 和 JavaScript，也可以通过 htmlmin 等工具压缩。这些项目都有 Gulp、Webpack 等流行构建工具的配套版本。

::: tip 注解

使用外部JavaScript和CSS与压缩JavaScript和CSS，属于同一种优化策略。

目前的开发，都是基于 vite 或者 webpack 等构建工具，这些工具都提供了压缩和混淆的功能，我们可以去分割和压缩代码。


**方案主要有以下几种：**
1. CDN优先: 大型库使用CDN外部引入

```js
// vite.config.js - 根据环境决定是否外部化
import { defineConfig } from 'vite'

export default defineConfig(({ command, mode }) => {
  const isProduction = mode === 'production'
  
  return {
    build: {
      rollupOptions: {
        // 生产环境使用CDN，开发环境打包
        external: isProduction ? [
          'vue',
          'vue-router',
          'element-plus',
          'lodash',
          'axios'
        ] : [],
        
        output: isProduction ? {
          globals: {
            'vue': 'Vue',
            'vue-router': 'VueRouter',
            'element-plus': 'ElementPlus',
            'lodash': '_',
            'axios': 'axios'
          }
        } : {}
      }
    }
  }
})
```
2. 按需分割: 根据路由和功能模块分割

```js
// vite.config.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue' // 或其他框架插件

export default defineConfig({
  plugins: [vue()],
  
  build: {
    // 代码分割配置
    rollupOptions: {
      output: {
        // 手动分包策略
        manualChunks: {
          // 将Vue相关库单独打包
          'vue-vendor': ['vue', 'vue-router', 'pinia'],
          // 将UI库单独打包
          'ui-vendor': ['element-plus', 'ant-design-vue'],
          // 将工具库单独打包
          'utils-vendor': ['lodash', 'axios', 'dayjs'],
          // 将大型库单独打包
          'chart-vendor': ['echarts', 'chart.js'],
        },
        
        // 或者使用函数形式进行更精细的控制
        manualChunks(id) {
          // 将node_modules中的依赖分离
          if (id.includes('node_modules')) {
            // 第三方库按大小分组
            if (id.includes('vue') || id.includes('router') || id.includes('pinia')) {
              return 'vue-vendor'
            }
            if (id.includes('element') || id.includes('ant-design')) {
              return 'ui-vendor'
            }
            if (id.includes('lodash') || id.includes('axios')) {
              return 'utils-vendor'
            }
            // 其他第三方库
            return 'vendor'
          }
          
          // 按路由分割
          if (id.includes('/src/views/')) {
            const routeName = id.split('/views/')[1].split('/')[0]
            return `route-${routeName}`
          }
        },
        
        // 文件命名策略
        chunkFileNames: 'js/[name]-[hash].js',
        entryFileNames: 'js/[name]-[hash].js',
        assetFileNames: (assetInfo) => {
          const info = assetInfo.name.split('.')
          const extType = info[info.length - 1]
          
          if (/\.(mp4|webm|ogg|mp3|wav|flac|aac)$/.test(assetInfo.name)) {
            return `media/[name]-[hash].${extType}`
          }
          if (/\.(png|jpe?g|gif|svg)$/.test(assetInfo.name)) {
            return `images/[name]-[hash].${extType}`
          }
          if (/\.(woff2?|eot|ttf|otf)$/.test(assetInfo.name)) {
            return `fonts/[name]-[hash].${extType}`
          }
          if (extType === 'css') {
            return `css/[name]-[hash].${extType}`
          }
          return `assets/[name]-[hash].${extType}`
        }
      }
    },
    
    // 分包大小控制
    chunkSizeWarningLimit: 1000, // 1MB警告阈值
  }
})

```
3. 体积控制: 代码进行压缩

```js
// vite.config.js
import { defineConfig } from 'vite'
import { resolve } from 'path'

export default defineConfig({
  build: {
    // 启用/禁用压缩
    minify: 'terser', // 'terser' | 'esbuild' | false
    
    // Terser压缩选项（更强的压缩）
    terserOptions: {
      compress: {
        // 生产环境移除console
        drop_console: true,
        // 移除debugger
        drop_debugger: true,
        // 移除无用代码
        dead_code: true,
        // 全局变量替换
        global_defs: {
          __DEV__: false
        }
      },
      mangle: {
        // 混淆变量名
        properties: {
          regex: /^_/
        }
      },
      format: {
        // 移除注释
        comments: false
      }
    },
    
    // CSS压缩
    cssMinify: true,
    
    // 启用CSS代码分割
    cssCodeSplit: true
  }
})
```

:::

## 27. 移除重复脚本

重复的脚本不仅产生不必要的HTTP请求，而且重复解析执行浪费时间和计算资源。

## 28. 减少DOM操作

JavaScript 操作 DOM 很慢，尤其是当 DOM 节点很多时。

**使用时应该注意：**

- 缓存已经访问过的元素；
- 使用 DocumentFragment 暂存 DOM，整理好以后再插入 DOM 树；
- 使用 className 来操纵元素的样式；
- 避免使用 JavaScript 修复布局。

## 29. 使用高效的事件处理

有时候感觉页面反映不够灵敏，是因为有太多频繁执行的事件处理器被添加到了DOM树的不同元素上，这就是推荐使用事件委托的原因。

如果一个div里面有10个按钮，应该只给div容器添加一个事件处理器，而不是给每个按钮都添加一个。事件能够冒泡，所以可以捕获事件并得知哪个按钮是事件源。

不需要为了处理DOM树而等待onload事件，通常只要目标元素在DOM树中可访问即可，而不必等待所有的图片下载完成。可以考虑用DOMContentLoaded来代替onload事件，

:::tip 注解

针对事件的优化，这里推荐使用事件委托代替事件绑定。

:::

**🖼️ 图片**
## 30. 优化图片

尝试把GIF格式转换成PNG格式，看看是否节省空间。在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）。

::: tip 注解

### 图片优化是前端性能优化的重要环节

#### 1. 选择合适的图片格式

目前主流的图片格式有：JPEG、PNG、GIF、WebP、AVIF、SVG。每种格式都有其优缺点，需要根据具体场景选择合适的格式。

##### 1.1图片格式对比表格

| 格式 | 透明度 | 动画 | 浏览器支持 | 文件大小 | 适用场景 | 优点 | 缺点 |
|------|--------|------|------------|----------|----------|------|------|
| **JPEG** | ❌ | ❌ | 99.9% | 中等 | 照片、复杂图像 | 压缩率高、兼容性好 | 不支持透明、有损压缩 |
| **PNG** | ✅ | ❌ | 99.9% | 大 | Logo、图标、需要透明 | 无损、支持透明 | 文件较大 |
| **GIF** | ✅ | ✅ | 99.9% | 中等 | 简单动画、图标 | 支持动画、兼容性好 | 颜色限制256色 |
| **WebP** | ✅ | ✅ | 96%+ | 小 | 现代Web应用 | 压缩率极高、功能全面 | 部分老浏览器不支持 |
| **AVIF** | ✅ | ✅ | 72%+ | 极小 | 下一代Web | 压缩率最高、色彩丰富 | 浏览器支持有限 |
| **SVG** | ✅ | ✅ | 99%+ | 极小 | 图标、简单图形 | 矢量无损、可缩放 | 不适合复杂图像 |


##### 1.2使用场景和建议

| 场景 | 首选格式 | 备选格式 | 说明 |
|------|----------|----------|------|
| 📸 照片/复杂图像 | WebP → JPEG | AVIF → WebP → JPEG | 优先现代格式，兼容性回退 |
| 🎨 Logo/图标 | SVG → WebP | PNG → SVG | 矢量优先，位图备选 |
| 🎬 简单动画 | WebP → GIF | Lottie → WebP → GIF | 现代动画格式优先 |
| 👁️ 需要透明 | WebP → PNG | AVIF → WebP → PNG | 现代格式压缩更好 |
| 🎯 极致压缩 | AVIF → WebP | WebP → JPEG | 新格式压缩率最高 |
| 📱 移动端优化 | WebP → JPEG | AVIF → WebP → JPEG | 减少流量消耗 |

##### 1.3WebP格式检测和使用方法

###### 1.3.1 **JavaScript检测WebP支持**
```javascript
// 方法1：使用Canvas检测
function checkWebPSupport() {
  return new Promise((resolve) => {
    const canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    
    canvas.toBlob((blob) => {
      resolve(blob?.type === 'image/webp');
    }, 'image/webp', 0.5);
  });
}

// 使用示例
checkWebPSupport().then((supported) => {
  if (supported) {
    console.log('浏览器支持WebP格式');
  } else {
    console.log('浏览器不支持WebP格式');
  }
});

// 方法2：使用Data URL检测（更快）
function detectWebP() {
  return new Promise((resolve) => {
    const webP = new Image();
    webP.onload = webP.onerror = function () {
      resolve(webP.height === 2);
    };
    webP.src = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';
  });
}

// 使用示例
detectWebP().then((hasWebP) => {
  document.documentElement.classList.toggle('webp', hasWebP);
  document.documentElement.classList.toggle('no-webp', !hasWebP);
});
```

###### 1.3.2 **CSS类选择器方案**
```css
/* 支持WebP的浏览器 */
.webp .hero-image {
  background-image: url('hero.webp');
}

/* 不支持WebP的浏览器 */
.no-webp .hero-image {
  background-image: url('hero.jpg');
}

/* 或者使用属性选择器 */
[data-webp="true"] .hero-image {
  background-image: url('hero.webp');
}

[data-webp="false"] .hero-image {
  background-image: url('hero.jpg');
}
```

###### 1.3.3 **动态图片加载**
```javascript
class WebPImageLoader {
  constructor() {
    this.isWebPSupported = null;
    this.init();
  }

  async init() {
    this.isWebPSupported = await this.detectWebP();
    document.documentElement.setAttribute('data-webp', this.isWebPSupported);
  }

  detectWebP() {
    return new Promise((resolve) => {
      const webP = new Image();
      webP.onload = webP.onerror = function () {
        resolve(webP.height === 2);
      };
      webP.src = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';
    });
  }

  // 根据支持情况返回合适的图片URL
  getImageUrl(baseName, webpPath = '', fallbackPath = '') {
    if (this.isWebPSupported) {
      return webpPath || `${baseName}.webp`;
    }
    return fallbackPath || `${baseName}.jpg`;
  }

  // 批量处理图片
  loadImages() {
    const images = document.querySelectorAll('img[data-src]');
    images.forEach(img => {
      const baseSrc = img.dataset.src;
      const webpSrc = img.dataset.webp;
      const fallbackSrc = img.dataset.fallback;
      
      img.src = this.getImageUrl(baseSrc, webpSrc, fallbackSrc);
    });
  }
}

// 使用示例
const imageLoader = new WebPImageLoader();

// HTML中的使用
/*
<img data-src="hero" 
     data-webp="images/hero.webp" 
     data-fallback="images/hero.jpg" 
     alt="Hero Image">
*/
```

###### 1.3.4 **HTML Picture元素方案（推荐）**
```html
<!-- 使用picture元素提供回退方案 -->
<picture>
  <source srcset="image.webp" type="image/webp">
  <source srcset="image.jpg" type="image/jpeg">
  <img src="image.jpg" alt="描述">
</picture>

<!-- 支持多种尺寸 -->
<picture>
  <source media="(min-width: 800px)" srcset="large.webp" type="image/webp">
  <source media="(min-width: 800px)" srcset="large.jpg" type="image/jpeg">
  <source srcset="small.webp" type="image/webp">
  <source srcset="small.jpg" type="image/jpeg">
  <img src="small.jpg" alt="响应式图片">
</picture>
```
###### 1.3.5 **现代浏览器特性检测**
```javascript
// 使用现代API检测
function modernWebPDetection() {
  // 检查是否支持createImageBitmap API
  if ('createImageBitmap' in window) {
    const canvas = new OffscreenCanvas(1, 1);
    const ctx = canvas.getContext('2d');
    
    return createImageBitmap(canvas)
      .then(() => canvas.convertToBlob({ type: 'image/webp' }))
      .then(blob => blob.type === 'image/webp')
      .catch(() => false);
  }
  
  // 降级到传统检测方法
  return detectWebP();
}
```
##### 总结

目前推荐使用WebP格式，因为其压缩率极高、功能全面，浏览器支持逐步增加，也是现代首选方案。

### 2. 图片压缩策略

除了选择合适的图片格式，图片压缩也是优化图片性能的重要手段。

##### 2.1 **有损压缩优化**
```javascript
// 使用imagemin进行自动压缩
const imagemin = require('imagemin');
const imageminJpegtran = require('imagemin-jpegtran');
const imageminPngquant = require('imagemin-pngquant');
const imageminWebp = require('imagemin-webp');

await imagemin(['images/*.{jpg,png}'], {
  destination: 'build/images',
  plugins: [
    // JPEG优化 - 渐进式JPEG
    imageminJpegtran({ progressive: true }),
    
    // PNG优化 - 减少颜色数量
    imageminPngquant({
      quality: [0.6, 0.8]
    }),
    
    // 生成WebP格式
    imageminWebp({
      quality: 75
    })
  ]
});
```

##### 2.2. **无损压缩优化**
```bash
# 使用OptiPNG优化PNG
optipng -o7 *.png

# 使用MozJPEG优化JPEG
cjpeg -quality 85 -progressive input.jpg > output.jpg

# 使用SVGO优化SVG
svgo --config=svgo.config.js *.svg
```

#### 3. 懒加载实现

图片懒加载是优化图片性能的重要手段。

##### 3.1 **原生懒加载**
```html
<!-- 现代浏览器原生支持 -->
<img src="image.jpg" 
     loading="lazy" 
     alt="懒加载图片">
```

##### 3.2 **Intersection Observer实现**
```javascript
// 高性能懒加载实现
class LazyImageLoader {
  constructor(options = {}) {
    this.options = {
      root: null,
      rootMargin: '50px',
      threshold: 0.1,
      ...options
    };
    
    this.observer = new IntersectionObserver(
      this.handleIntersection.bind(this),
      this.options
    );
    
    this.init();
  }
  
  init() {
    const lazyImages = document.querySelectorAll('img[data-src]');
    lazyImages.forEach(img => {
      this.observer.observe(img);
    });
  }
  
  handleIntersection(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        this.loadImage(entry.target);
        this.observer.unobserve(entry.target);
      }
    });
  }
  
  loadImage(img) {
    // 创建新的图片对象预加载
    const imageLoader = new Image();
    
    imageLoader.onload = () => {
      // 加载完成后替换src
      img.src = img.dataset.src;
      img.classList.add('loaded');
    };
    
    imageLoader.onerror = () => {
      // 加载失败处理
      img.classList.add('error');
    };
    
    // 开始加载
    imageLoader.src = img.dataset.src;
  }
}

// 使用懒加载
new LazyImageLoader();
```

##### 3.3 **传统滚动事件监听**
```javascript
// 使用传统滚动事件监听
window.addEventListener('scroll', () => {
  const lazyImages = document.querySelectorAll('img[data-src]');
  lazyImages.forEach(img => {
    if (img.getBoundingClientRect().top < window.innerHeight) {
      img.src = img.dataset.src;
      img.classList.add('loaded');
    }
  });
});
```

#### 4. 构建工具优化

在现代开发中，我们都是基本vite、webpack等构建工具来打包项目，这些构建工具都提供了图片压缩的插件。我们可以借助这些插件在代码打包的过程中对图片进行压缩。


##### 4.1 **Webpack配置**
```javascript
// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.(png|jpe?g|gif|svg)$/i,
        use: [
          {
            loader: 'file-loader',
            options: {
              outputPath: 'images',
            },
          },
          {
            loader: 'image-webpack-loader',
            options: {
              mozjpeg: {
                progressive: true,
                quality: 75
              },
              optipng: {
                enabled: true,
              },
              pngquant: {
                quality: [0.6, 0.8],
              },
              webp: {
                quality: 75
              }
            },
          },
        ],
      },
    ],
  },
};
```

##### 4.2 **Vite配置**
```javascript
// vite.config.js
import { defineConfig } from 'vite';
import { ViteImageOptimize } from 'vite-plugin-imagemin';

export default defineConfig({
  plugins: [
    ViteImageOptimize({
      gifsicle: { optimizationLevel: 7 },
      mozjpeg: { quality: 75 },
      pngquant: { 
        quality: [0.6, 0.8],
        speed: 4 
      },
      svgo: {
        plugins: [
          { name: 'removeViewBox', active: false },
          { name: 'removeEmptyAttrs', active: false }
        ]
      },
      webp: { quality: 75 }
    })
  ]
});
```

#### 5. CDN优化

我们会将一些大资源图片或者公共图片资源存放在CDN服务商上（如七牛云），这些CDN服务商也提供了图片优化服务。我们可以借助这些服务在图片加载的过程中对图片进行优化。

##### 5.1 阿里云处理
```javascript
// 使用阿里云OSS图片处理
function generateImageUrl(baseUrl, options = {}) {
  const {
    width = null,
    height = null,
    quality = 75,
    format = 'webp',
    crop = 'fill'
  } = options;
  
  let params = [];
  
  if (width || height) {
    params.push(`resize,m_${crop}`);
    if (width) params.push(`w_${width}`);
    if (height) params.push(`h_${height}`);
  }
  
  params.push(`format,${format}`);
  params.push(`quality,q_${quality}`);
  
  return `${baseUrl}?x-oss-process=image/${params.join('/')}`;
}

// 使用示例
const optimizedUrl = generateImageUrl('https://example.com/image.jpg', {
  width: 800,
  height: 600,
  quality: 80,
  format: 'webp'
});
```

##### 5.2 七牛云处理
```javascript
export const handlePicUrl = (picUrl: string, width = 200, height = 200) => {
  if (!picUrl) return;
  if (picUrl.includes(useOrigin.VITE_APP_QNURL)) {
    // 七牛云
    const cs = '?imageslim';
    const cs2 = `|imageView2/1/w/${width}/h/${height}/format/webp`;
    let url = picUrl.includes(cs) ? picUrl + cs2 : picUrl + cs + cs2;
    if (!window.isSupportWebp) url = url.replace('webp', '');
    return url;
  } else {
    return picUrl;
  }
};
```
:::

## 31. 优化CSS Sprite

在Sprite图片中横向排列一般都比纵向排列的最终文件小
组合Sprite图片中的相似颜色可以保持低色数，最理想的是256色以下PNG8格式
“对移动端友好”，不要在Sprite图片中留下太大的空隙。虽然不会在很大程度上影响图片文件的大小，但这样做可以节省用户代理把图片解压成像素映射时消耗的内存。100×100的图片是1万个像素，而1000×1000的图片就是100万个像素了。

::: tip 注解

这一条主要是针对雪碧图的优化。雪碧图是将多张小图片合并成一张大图片，可以减少HTTP请求，提高页面加载速度。在UI出图的时候，可以跟UI沟通，减少图片的间隙。

:::

## 32. 不要在HTML中缩放图片

不要使用`<img>`的width、height缩放图片，如果用到小图片，就使用相应大小的图片。如果需要
`<img width="100" height="100" src="mycat.jpg" alt="My Cat" />`
那么图片本身（mycat.jpg）应该是100x100px的，而不是去缩小500x500px的图片。

> 很多 CMS 和 CDN 都提供图片裁切功能。

补充：设置图片的宽和高，以免浏览器按照「猜」的宽高给图片保留的区域和实际宽高差异，产生重绘。


## 33. 使用体积小、可缓存的favicon.ico

favicon.ico是放在服务器根目录的图片，它会带来一堆麻烦，因为即便你不管它，浏览器也会自动请求它，所以最好不要给一个404 Not Found响应。而且只要在同一个服务器上，每次请求它时都会发送cookie。

所以确保这个图标：

- 存在（避免 404）；
- 尽量小，最好小于 1K；
- 设置较长的过期时间。设置合适的有效期HTTP头（以后如果想换的话就不能重命名了），把有效期设置为几个月后一般比较安全，可以通过检查当前favicon.ico的最后修改日期来确保变更能让浏览器知道。

>对于较新的浏览器，可以使用PNG格式的favicon。

### 📱 移动端

## 34. 保证所有组件都小于25k

这个限制是因为iPhone不能缓存大于25K的组件，注意这里指的是未压缩的大小。这就是为什么缩减内容本身也很重要，因为单纯的gzip可能不够。

::: tip 注解

**这条规则已经过时**，原因如下：

1. **缓存限制已大幅提升**：现代iOS Safari和其他移动浏览器的缓存限制已经大幅提升，不再有25KB的限制
2. **Service Worker支持**：现代浏览器支持Service Worker，可以更灵活地控制缓存策略
3. **HTTP/2的普及**：虽然文件大小仍然重要，但现代的优化重点已经转向：
   - 代码分割（Code Splitting）
   - 懒加载（Lazy Loading）
   - Tree Shaking
   - 资源优先级管理

**现代最佳实践**：
- 单个JS bundle建议不超过200-300KB（gzip后）
- 使用webpack或vite的代码分割功能
- 实施路由级别的代码分割
- 对大型库进行按需加载
:::

## 35. 打包内容为分段文档

把各个组件打包成一个像有附件的电子邮件一样的复合文档里，可以用一个HTTP请求获取多个组件（记住一点：HTTP请求是代价高昂的）。用这种方式的时候，要先检查用户代理是否支持（iPhone就不支持）。


::: tip 注解

**这条规则已被更好的技术取代**：

1. **HTTP/2多路复用**：HTTP/2支持在单个连接上并行传输多个资源，大大减少了合并文件的需求
3. **模块化加载**：ES6模块和动态import()允许更细粒度的资源管理

**现代最佳实践**：
- 在HTTP/2环境下，适度拆分资源反而更好：
  - 更好的缓存粒度
  - 并行加载
  - 增量更新
- 使用资源提示（Resource Hints）：
  - `<link rel="preload">`
  - `<link rel="prefetch">`
  - `<link rel="preconnect">`
- 实施智能打包策略：
  - 共享依赖提取到单独的chunk
  - 按路由分割代码
  - 第三方库单独打包

**总结**：虽然减少请求数量的核心思想仍然有效，但实现方式已经完全改变。现代Web开发更注重智能的资源管理和加载策略，而不是简单的文件合并。
:::