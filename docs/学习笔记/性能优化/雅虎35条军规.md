# 雅虎35条军规

## 前言

前端性能优化是现代Web开发中至关重要的一环，直接影响用户体验、搜索引擎排名和商业价值。雅虎（Yahoo）开发者网络在2007年提出的35条前端性能优化规则，至今仍是业界公认的性能优化黄金标准。

![雅虎35条军规](/public/assets/yahu_1.png)

本文档整理了完整的35条军规，按以下7个类别系统归纳：

| 类别 | 规则数量 | 主要关注点 |
|------|----------|------------|
| **页面内容** | 10条 | HTTP请求、DNS、重定向、缓存等 |
| **服务器** | 7条 | CDN、压缩、缓存头、ETag等 |
| **Cookie** | 2条 | Cookie大小和域名策略 |
| **CSS** | 4条 | 样式表位置和优化 |
| **JavaScript** | 6条 | 脚本位置、压缩和DOM操作 |
| **图片** | 4条 | 图片优化和Sprite技术 |
| **移动端** | 2条 | 移动设备特殊考虑 |

接下来将详细介绍每个类别的具体规则和现代化实践方案。

---

## 页面内容

### 1. 减少HTTP请求

Web 前端 80% 的响应时间花在图片、样式、脚本等资源下载上。减少HTTP请求是提高页面加载速度的重要手段。减少HTTP请求可以通过以下几种方式：

- 合并JS/CSS文件。服务器端（CDN）自动合并，基于Node.js的文件合并工具，通过把所有脚本放在一个文件中的方式来减少请求数。
- 使用CSS Sprite雪碧图将背景图片合并成一个文件，通过background-image 和 background-position 控制显示
- 行内图片（Base64编码）。使用Data URI scheme将图片嵌入HTML或者CSS中；或者将CSS、JS、图片直接嵌入HTML中，会增加文件大小，也可能产生浏览器兼容及其他性能问题。

### 2. 减少DNS查询

用户输入URL后，浏览器首先要查询域名（hostname）对应服务器的IP地址，一般需要耗费20-120毫秒时间。DNS查询完成之前，浏览器无法从服务器下载任何数据。

基于性能考虑，ISP、局域网、操作系统、浏览器都会有相应的 DNS 缓存机制。

**DNS缓存机制：**

- IE缓存30分钟，可通过注册表中DnsCacheTimeout项设置
- Firefox缓存1分钟，通过network.dnsCacheExpiration配置
- Chrome等现代浏览器也有相应的DNS缓存策略

另外需要注意的是这里有一个矛盾，减少不同的域名可减少 DNS 查找，同时也减少了页面下载资源文件的并发量。也就是说，虽然避免 DNS 查找削减了响应时间，但是减少并行下载数量却增加了响应时间。原则是把组件分散在 2~4 个域名下，控制好数量，这是同时减少 DNS 查找和允许并发下载的折中方案。

```注解
为什么通过减少DNS查询能够优化？
1. 时间开销
每次DNS查询需要消耗20-120毫秒时间，而查询未完成前会阻塞浏览器下载资源。多个域名=多次DNS查询=累积延迟。这也是为什么2～4个域名是最佳实践，过少域名DNS查询次数虽然减少了，但并发下载受限，而过多域名DNS查询开销过大，并发下载多。

2. 网络开销
用户请求 → 本地DNS缓存 → 递归DNS服务器 → 根域名服务器 → 顶级域名服务器 → 权威域名服务器
每一个环节都网络延迟，影响整体性能。

3. 浏览器行为
浏览器必须先完成DNS解析才能建立TCP连接，而解析过程遇到新域名就要暂停等待DNS解析。

具体场景：
假设页面有10个资源分布在5个不同域名：
 - 没有DNS缓存时：5 × 80ms(平均DNS查询) = 400ms 额外延迟
 - 有DNS缓存时：第一次访问后续页面几乎无DNS开销
这就是为什么DNS查询优化对首次访问和缓存过期后的访问影响最大的原因！
所以减少DNS查询本质上是在减少这种串行阻塞带来的时间开销。
```

```注解
DNS查询优化具体方法

1. DNS预解析设置
<!-- 预解析即将用到的域名 -->
<link rel="dns-prefetch" href="//example.com">

<!-- 对于HTTPS站点，还可以预连接 -->
<link rel="preconnect" href="https://fonts.googleapis.com">

2. 服务器DNS优化
设置合理的TTL值

3. CDN配置优化
将静态资源分布到少数几个CDN域名，不同资源分散在不同域名下

```

### 3. 避免重定向

HTTP重定向通过301/302状态码实现。下面是一个有301状态码的HTTP头

```text
HTTP/1.1 301 Moved Permanently 
Location: http://example.com/newuri
Content-Type: text/html
```

浏览器会自动跳转到Location域指明的URL。重定向需要的所有信息都在HTTP头部，而响应体一般是空的。其实额外的HTTP头，比如Expires和Cache-Control也表示重定向。除此之外还有别的跳转方式：refresh元标签和JavaScript，但如果你必须得做重定向，最好用标准的3xxHTTP状态码，主要是为了让返回按钮能正常使用。

牢记重定向会拖慢用户体验，在用户和HTML文档之间插入重定向会延迟页面上的所有东西，页面无法渲染，组件也无法开始下载，直到HTML文档被送达浏览器。

有一种常见的极其浪费资源的重定向，而且web开发人员一般都意识不到这一点，就是URL尾部缺少一个斜线的时候。例如，跳转到`http://astrology.yahoo.com/astrology`会返回一个重定向到`http://astrology.yahoo.com/astrology/`的301响应（注意添在尾部的斜线）。在Apache中可以用Alias，mod_rewrite或者DirectorySlash指令来取消不必要的重定向。

重定向最常见的用途是把旧站点连接到新的站点，还可以连接同一站点的不同部分，针对用户的不同情况（浏览器类型，用户帐号类型等等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用Alias和mod_rewrite，前提是两个代码路径都在相同的服务器上。如果是因为域名变化而使用了重定向，就可以创建一条CNAME（创建一个指向另一个域名的DNS记录作为别名）结合Alias或者mod_rewrite指令。

```注解
Apache是传统Web服务器的标配，而我们现在更多是使用Nginx，Node.js服务器等。

需要手动配置Apache的配置文件，添加以下内容：
<VirtualHost *:80>
    DocumentRoot /var/www/html
    DirectoryIndex index.html
    # 处理路由重定向等...
</VirtualHost>

雅虎35条军规写于2007年，那时前端工程化还不发达，需要更多地考虑服务器配置。

现在我们可以忽视掉这个优化方法。
```

### 4. 缓存Ajax请求

要提高性能，优化Ajax响应至关重要。最重要的提高Ajax性能的方法就是让响应变得可缓存，就像在添上Expires或者Cache-Control HTTP头中讨论的一样。

**其他适用于Ajax的优化规则：**

- **Gzip组件**：Ajax响应数据也应该启用Gzip压缩，特别是返回JSON或XML数据时，可以显著减少传输大小
- **减少DNS查找**：Ajax请求的API域名也要考虑DNS优化，避免频繁的跨域请求导致额外的DNS查询
- **压缩JavaScript**：处理Ajax请求的相关JavaScript代码（如jQuery、axios等库）也需要压缩
- **避免重定向**：Ajax请求的URL路径要避免301/302重定向，否则会增加请求延迟
- **配置ETags**：Ajax响应也要配置合适的ETag头，利用浏览器缓存机制减少不必要的数据传输

这些网络层优化规则对Ajax请求同样有效，应当一并考虑。

```注解
这一块就是http缓存机制，目前这种优化也是主流方案。

Expires 是HTTP/1.0的缓存头，指定资源的过期时间（绝对时间）

# 服务器响应头示例
Expires: Wed, 21 Oct 2024 07:28:00 GMT

# 设置示例：
// Node.js/Express
app.get('/api/data', (req, res) => {
  const expiryDate = new Date();
  expiryDate.setHours(expiryDate.getHours() + 24); // 24小时后过期
  res.set('Expires', expiryDate.toUTCString());
  res.json({ data: 'some data' });
});

// Nginx配置
location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
    expires 1y;  # 静态资源1年过期
}

location /api/ {
    expires 1h;  # API数据1小时过期
}

Cache-Control 是HTTP/1.1的缓存头，功能更强大，优先级高于Expires：

常用指令：
# 基本缓存控制
Cache-Control: max-age=3600                    # 缓存1小时
Cache-Control: no-cache                        # 每次都验证，但可以缓存
Cache-Control: no-store                        # 完全不缓存
Cache-Control: must-revalidate                 # 过期后必须重新验证

# 组合使用
Cache-Control: public, max-age=86400           # 公共缓存，24小时
Cache-Control: private, max-age=300            # 私有缓存，5分钟
Cache-Control: no-cache, must-revalidate       # 强制验证

# 设置示例：
// Express.js 不同类型资源的缓存策略
app.use('/static', express.static('public', {
  maxAge: '1y',  // 静态资源长期缓存
  setHeaders: (res, path) => {
    if (path.endsWith('.html')) {
      res.setHeader('Cache-Control', 'no-cache'); // HTML文件不缓存
    }
  }
}));

// API响应缓存
app.get('/api/user/:id', (req, res) => {
  res.set('Cache-Control', 'private, max-age=300'); // 用户数据5分钟
  res.json({ user: userData });
});

app.get('/api/config', (req, res) => {
  res.set('Cache-Control', 'public, max-age=3600'); // 配置数据1小时
  res.json({ config: configData });
});

// 实时数据不缓存
app.get('/api/realtime', (req, res) => {
  res.set('Cache-Control', 'no-store');
  res.json({ timestamp: Date.now() });
});
```

### 5. 延迟加载

页面初始加载时哪些内容是绝对必需的？不在答案之列的资源都可以延迟加载。比如：

非首屏使用的数据、样式、脚本、图片等；
用户交互时才会显示的内容。

遵循「渐进增强」理念开发的网站：JavaScript用于增强用用户体验，但没有（不支持） JavaScript也能正常工作，完全可以延迟加载JavaScript。

将首屏以外的HTML放在不渲染的元素中，如隐藏的`<textarea>`，或者type属性为非执行脚本的`<script>`标签中，减少初始渲染的DOM元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。

另一个常见的做法是图片的延迟加载（懒加载），具体逻辑是当用户滚动页面看到内容时，再加载所需图片。这种操作在较多图片的网页中，可以节省大量带宽，页面渲染速度也会变快。

```注解
延迟加载（即懒加载）一直都是优化的重要手段。主要方案有以下：

1. 图片懒加载（Lazy Loading）
- Intersection Observer API（现代浏览器推荐）
- 原生 loading="lazy" 属性（最简单）
- 传统滚动事件监听

2. 代码分割（Code Splitting）
- 动态导入import()（ES2020）
- React.lazy 懒加载组件 + Suspense 占位符
- Vue 异步组件（Vue3）
- Webpack 代码分割

3. 路由级别的懒加载

4. 内容延迟渲染
- 虚拟滚动（大列表优化）
- 分页懒加载

5. 资源预加载策略
- preload 预加载关键资源
- prefetch 预加载可能需要的资源
- preconnect/dns-prefetch 预连接外部域名
```
