# 雅虎35条军规

## 前言

前端性能优化是现代Web开发中至关重要的一环，直接影响用户体验、搜索引擎排名和商业价值。雅虎（Yahoo）开发者网络在2007年提出的35条前端性能优化规则，至今仍是业界公认的性能优化黄金标准。

![雅虎35条军规](/public/assets/yahu_1.png)

本文档整理了完整的35条军规，按以下7个类别系统归纳：

| 类别 | 规则数量 | 主要关注点 |
|------|----------|------------|
| **页面内容** | 10条 | HTTP请求、DNS、重定向、缓存等 |
| **服务器** | 7条 | CDN、压缩、缓存头、ETag等 |
| **Cookie** | 2条 | Cookie大小和域名策略 |
| **CSS** | 4条 | 样式表位置和优化 |
| **JavaScript** | 6条 | 脚本位置、压缩和DOM操作 |
| **图片** | 4条 | 图片优化和Sprite技术 |
| **移动端** | 2条 | 移动设备特殊考虑 |

接下来将详细介绍每个类别的具体规则和现代化实践方案。

---

## 页面内容

### 1. 减少HTTP请求

Web 前端 80% 的响应时间花在图片、样式、脚本等资源下载上。减少HTTP请求是提高页面加载速度的重要手段。减少HTTP请求可以通过以下几种方式：

- 合并JS/CSS文件。服务器端（CDN）自动合并，基于Node.js的文件合并工具，通过把所有脚本放在一个文件中的方式来减少请求数。
- 使用CSS Sprite雪碧图将背景图片合并成一个文件，通过background-image 和 background-position 控制显示
- 行内图片（Base64编码）。使用Data URI scheme将图片嵌入HTML或者CSS中；或者将CSS、JS、图片直接嵌入HTML中，会增加文件大小，也可能产生浏览器兼容及其他性能问题。

### 2. 减少DNS查询

用户输入URL后，浏览器首先要查询域名（hostname）对应服务器的IP地址，一般需要耗费20-120毫秒时间。DNS查询完成之前，浏览器无法从服务器下载任何数据。

基于性能考虑，ISP、局域网、操作系统、浏览器都会有相应的 DNS 缓存机制。

**DNS缓存机制：**

- IE缓存30分钟，可通过注册表中DnsCacheTimeout项设置
- Firefox缓存1分钟，通过network.dnsCacheExpiration配置
- Chrome等现代浏览器也有相应的DNS缓存策略

另外需要注意的是这里有一个矛盾，减少不同的域名可减少 DNS 查找，同时也减少了页面下载资源文件的并发量。也就是说，虽然避免 DNS 查找削减了响应时间，但是减少并行下载数量却增加了响应时间。原则是把组件分散在 2~4 个域名下，控制好数量，这是同时减少 DNS 查找和允许并发下载的折中方案。

```注解
为什么通过减少DNS查询能够优化？
1. 时间开销
每次DNS查询需要消耗20-120毫秒时间，而查询未完成前会阻塞浏览器下载资源。多个域名=多次DNS查询=累积延迟。这也是为什么2～4个域名是最佳实践，过少域名DNS查询次数虽然减少了，但并发下载受限，而过多域名DNS查询开销过大，并发下载多。

2. 网络开销
用户请求 → 本地DNS缓存 → 递归DNS服务器 → 根域名服务器 → 顶级域名服务器 → 权威域名服务器
每一个环节都网络延迟，影响整体性能。

3. 浏览器行为
浏览器必须先完成DNS解析才能建立TCP连接，而解析过程遇到新域名就要暂停等待DNS解析。

具体场景：
假设页面有10个资源分布在5个不同域名：
 - 没有DNS缓存时：5 × 80ms(平均DNS查询) = 400ms 额外延迟
 - 有DNS缓存时：第一次访问后续页面几乎无DNS开销
这就是为什么DNS查询优化对首次访问和缓存过期后的访问影响最大的原因！
所以减少DNS查询本质上是在减少这种串行阻塞带来的时间开销。
```

```注解
DNS查询优化具体方法

1. DNS预解析设置
<!-- 预解析即将用到的域名 -->
<link rel="dns-prefetch" href="//example.com">

<!-- 对于HTTPS站点，还可以预连接 -->
<link rel="preconnect" href="https://fonts.googleapis.com">

2. 服务器DNS优化
设置合理的TTL值

3. CDN配置优化
将静态资源分布到少数几个CDN域名，不同资源分散在不同域名下

```

### 3. 避免重定向

HTTP重定向通过301/302状态码实现。下面是一个有301状态码的HTTP头

```text
HTTP/1.1 301 Moved Permanently 
Location: http://example.com/newuri
Content-Type: text/html
```

浏览器会自动跳转到Location域指明的URL。重定向需要的所有信息都在HTTP头部，而响应体一般是空的。其实额外的HTTP头，比如Expires和Cache-Control也表示重定向。除此之外还有别的跳转方式：refresh元标签和JavaScript，但如果你必须得做重定向，最好用标准的3xxHTTP状态码，主要是为了让返回按钮能正常使用。

牢记重定向会拖慢用户体验，在用户和HTML文档之间插入重定向会延迟页面上的所有东西，页面无法渲染，组件也无法开始下载，直到HTML文档被送达浏览器。

有一种常见的极其浪费资源的重定向，而且web开发人员一般都意识不到这一点，就是URL尾部缺少一个斜线的时候。例如，跳转到`http://astrology.yahoo.com/astrology`会返回一个重定向到`http://astrology.yahoo.com/astrology/`的301响应（注意添在尾部的斜线）。在Apache中可以用Alias，mod_rewrite或者DirectorySlash指令来取消不必要的重定向。

重定向最常见的用途是把旧站点连接到新的站点，还可以连接同一站点的不同部分，针对用户的不同情况（浏览器类型，用户帐号类型等等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用Alias和mod_rewrite，前提是两个代码路径都在相同的服务器上。如果是因为域名变化而使用了重定向，就可以创建一条CNAME（创建一个指向另一个域名的DNS记录作为别名）结合Alias或者mod_rewrite指令。

```注解
Apache是传统Web服务器的标配，而我们现在更多是使用Nginx，Node.js服务器等。

需要手动配置Apache的配置文件，添加以下内容：
<VirtualHost *:80>
    DocumentRoot /var/www/html
    DirectoryIndex index.html
    # 处理路由重定向等...
</VirtualHost>

雅虎35条军规写于2007年，那时前端工程化还不发达，需要更多地考虑服务器配置。

现在我们可以忽视掉这个优化方法。
```

### 4. 缓存Ajax请求

要提高性能，优化Ajax响应至关重要。最重要的提高Ajax性能的方法就是让响应变得可缓存，就像在添上Expires或者Cache-Control HTTP头中讨论的一样。

**其他适用于Ajax的优化规则：**

- **Gzip组件**：Ajax响应数据也应该启用Gzip压缩，特别是返回JSON或XML数据时，可以显著减少传输大小
- **减少DNS查找**：Ajax请求的API域名也要考虑DNS优化，避免频繁的跨域请求导致额外的DNS查询
- **压缩JavaScript**：处理Ajax请求的相关JavaScript代码（如jQuery、axios等库）也需要压缩
- **避免重定向**：Ajax请求的URL路径要避免301/302重定向，否则会增加请求延迟
- **配置ETags**：Ajax响应也要配置合适的ETag头，利用浏览器缓存机制减少不必要的数据传输

这些网络层优化规则对Ajax请求同样有效，应当一并考虑。

```注解
这一块就是http缓存机制，目前这种优化也是主流方案。

Expires 是HTTP/1.0的缓存头，指定资源的过期时间（绝对时间）

# 服务器响应头示例
Expires: Wed, 21 Oct 2024 07:28:00 GMT

# 设置示例：
// Node.js/Express
app.get('/api/data', (req, res) => {
  const expiryDate = new Date();
  expiryDate.setHours(expiryDate.getHours() + 24); // 24小时后过期
  res.set('Expires', expiryDate.toUTCString());
  res.json({ data: 'some data' });
});

// Nginx配置
location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
    expires 1y;  # 静态资源1年过期
}

location /api/ {
    expires 1h;  # API数据1小时过期
}

Cache-Control 是HTTP/1.1的缓存头，功能更强大，优先级高于Expires：

常用指令：
# 基本缓存控制
Cache-Control: max-age=3600                    # 缓存1小时
Cache-Control: no-cache                        # 每次都验证，但可以缓存
Cache-Control: no-store                        # 完全不缓存
Cache-Control: must-revalidate                 # 过期后必须重新验证

# 组合使用
Cache-Control: public, max-age=86400           # 公共缓存，24小时
Cache-Control: private, max-age=300            # 私有缓存，5分钟
Cache-Control: no-cache, must-revalidate       # 强制验证

# 设置示例：
// Express.js 不同类型资源的缓存策略
app.use('/static', express.static('public', {
  maxAge: '1y',  // 静态资源长期缓存
  setHeaders: (res, path) => {
    if (path.endsWith('.html')) {
      res.setHeader('Cache-Control', 'no-cache'); // HTML文件不缓存
    }
  }
}));

// API响应缓存
app.get('/api/user/:id', (req, res) => {
  res.set('Cache-Control', 'private, max-age=300'); // 用户数据5分钟
  res.json({ user: userData });
});

app.get('/api/config', (req, res) => {
  res.set('Cache-Control', 'public, max-age=3600'); // 配置数据1小时
  res.json({ config: configData });
});

// 实时数据不缓存
app.get('/api/realtime', (req, res) => {
  res.set('Cache-Control', 'no-store');
  res.json({ timestamp: Date.now() });
});
```

### 5. 延迟加载

页面初始加载时哪些内容是绝对必需的？不在答案之列的资源都可以延迟加载。比如：

非首屏使用的数据、样式、脚本、图片等；
用户交互时才会显示的内容。

遵循「渐进增强」理念开发的网站：JavaScript用于增强用用户体验，但没有（不支持） JavaScript也能正常工作，完全可以延迟加载JavaScript。

将首屏以外的HTML放在不渲染的元素中，如隐藏的`<textarea>`，或者type属性为非执行脚本的`<script>`标签中，减少初始渲染的DOM元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。

另一个常见的做法是图片的延迟加载（懒加载），具体逻辑是当用户滚动页面看到内容时，再加载所需图片。这种操作在较多图片的网页中，可以节省大量带宽，页面渲染速度也会变快。

```注解
延迟加载（即懒加载）一直都是优化的重要手段。主要方案有以下：

1. 图片懒加载（Lazy Loading）
- Intersection Observer API（现代浏览器推荐）
- 原生 loading="lazy" 属性（最简单）
- 传统滚动事件监听

2. 代码分割（Code Splitting）
- 动态导入import()（ES2020）
- React.lazy 懒加载组件 + Suspense 占位符
- Vue 异步组件（Vue3）
- Webpack 代码分割

3. 路由级别的懒加载

4. 内容延迟渲染
- 虚拟滚动（大列表优化）
- 分页懒加载

5. 资源预加载策略
- preload 预加载关键资源
- prefetch 预加载可能需要的资源
- preconnect/dns-prefetch 预连接外部域名
```

### 6. 预加载

预加载可能看起来和延迟加载是相反的，但它其实有不同的目标。通过预加载组件可以充分利用浏览器空闲的时间来请求将来会用到的组件（图片，样式和脚本）。用户访问下一页的时候，大部分组件都已经在缓存里了，所以在用户看来页面会加载得更快。

实际应用中有以下几种预加载的类型：

- 无条件预加载：尽快开始加载，获取一些额外的组件。以`goodle.com`为例，首页加载完成后会立即下载一个Sprite图片。这个图片并不是首页需要的，而是搜索结果页面上的内容。
- 有条件预加载：根据用户操作猜测用户将要跳转到哪里并据此预加载。在search.yahoo.com的输入框里键入内容后，可以看到那些额外组件是怎样请求加载的。
- 提前预加载：在推出新设计之前预加载。经常在重新设计之后会听到：“这个新网站不错，但比以前更慢了”，一部分原因是用户访问先前的页面都是有旧缓存的，但新的却是一种空缓存状态下的体验。可以通过在将要推出新设计之前预加载一些组件来减轻这种负面影响，老站可以利用浏览器空闲的时间来请求那些新站需要的图片和脚本。

```注解
预加载和懒加载看似矛盾，实际上是互补的优化策略：

**核心区别：**
- 懒加载：推迟加载暂时不需要的资源，优化首屏加载时间
- 预加载：提前加载即将需要的资源，优化后续页面的加载体验

**应用场景：**
1. 懒加载用于：首屏以外的图片、非关键CSS/JS、下方内容等
2. 预加载用于：下一页面的关键资源、用户可能访问的资源、关键路径资源

**协同工作：**
首屏 → 懒加载非关键资源 → 同时预加载下个页面资源 → 提升整体用户体验

**预加载具体方案：**

1. **Resource Hints（资源提示）**
- dns-prefetch 预解析DNS
- preconnect 预连接（DNS + TCP + TLS）
- preload 预加载关键资源
- prefetch 预获取可能需要的资源

2. **JavaScript 动态预加载**
- 图片预加载 preloadImages
- 脚本预加载 preloadScript
- 样式预加载 preloadCSS

3. **Web API 预加载**
- Service Worker 预缓存
- Intersection Observer 预加载

4. **模块预加载（现代框架）**
- React - 路由级预加载
- Vue - 异步组件预加载
- Next.js - 自动预加载
```

### 7. 减少DOM操作

一个复杂的页面意味着要下载更多的字节，而且用JavaScript访问DOM也会更慢。举个例子，想要添加一个事件处理器的时候，循环遍历页面上的500个DOM元素和5000个DOM元素是有区别的。

从以下几个角度考虑移除不必要的标记：
- 是否还在使用表格布局
- 塞进去更多的`</div>`仅为解决布局问题，也许有更好、更语义化的标记
- 能否通过伪元素实现的功能，就没必要添加额外元素，如清除浮动

DOM元素的数量很容易测试，只需要在控制台里输入：
```js
document.getElementsByTagName('*').length
```

```注解
**为什么虚拟DOM时代仍需要减少DOM操作？**

1. **虚拟DOM不是万能的**
   - 虚拟DOM只是优化了DOM操作过程，但最终仍要操作真实DOM
   - 虚拟DOM diff算法复杂度与节点数量相关，节点越多计算越耗时
   - 大量DOM节点会增加虚拟DOM树的大小和比较成本

2. **浏览器渲染性能限制**
   - 即使是虚拟DOM最终更新到真实DOM时，浏览器仍需重排重绘
   - DOM节点越多，Layout（布局）和Paint（绘制）越耗时
   - 过多DOM节点会增加内存占用，影响垃圾回收效率

3. **JS引擎执行效率**
   - DOM查询和遍历操作的时间复杂度与DOM数量正相关
   - 事件代理的效率会因DOM层级过深而下降
   - CSS选择器匹配性能也与DOM结构复杂度相关

**减少DOM操作的具体方案：**

1. 组件化架构优化，避免平铺式大量DOM，组件化精简DOM
2. 虚拟滚动（长列表优化）
3. DOM批量操作，避免在for循坏里面逐个操作DOM，而是使用DocumentFragment批量操作DOM和innerHTML批量更新DOM
4. CSS优化减少DOM，避免使用额外DOM实现效果，而是使用CSS伪元素替代
5. 事件委托减少事件绑定，避免给每个元素绑定事件，而是使用事件委托
6. 现代框架最佳实践，使用Key优化列表渲染，React使用React.memo和useMemo避免不必要的重渲染，Vue使用v-memo缓存复杂计算结果

即使在虚拟DOM时代，减少DOM操作仍是性能优化的基础。关键是要理解虚拟DOM的工作原理，合理运用组件化、虚拟滚动、批量操作等技术，在减少DOM节点数量的同时提升用户体验。
```
