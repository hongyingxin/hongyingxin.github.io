# 雅虎35条军规

## 前言

前端性能优化是现代Web开发中至关重要的一环，直接影响用户体验、搜索引擎排名和商业价值。雅虎（Yahoo）开发者网络在2007年提出的35条前端性能优化规则，至今仍是业界公认的性能优化黄金标准。

![雅虎35条军规](/public/assets/yahu_1.png)

本文档整理了完整的35条军规，按以下7个类别系统归纳：

| 类别 | 规则数量 | 主要关注点 |
|------|----------|------------|
| **页面内容** | 10条 | HTTP请求、DNS、重定向、缓存等 |
| **服务器** | 7条 | CDN、压缩、缓存头、ETag等 |
| **Cookie** | 2条 | Cookie大小和域名策略 |
| **CSS** | 4条 | 样式表位置和优化 |
| **JavaScript** | 6条 | 脚本位置、压缩和DOM操作 |
| **图片** | 4条 | 图片优化和Sprite技术 |
| **移动端** | 2条 | 移动设备特殊考虑 |

接下来将详细介绍每个类别的具体规则和现代化实践方案。

---

## 页面内容

### 1. 减少HTTP请求

Web 前端 80% 的响应时间花在图片、样式、脚本等资源下载上。减少HTTP请求是提高页面加载速度的重要手段。减少HTTP请求可以通过以下几种方式：

- 合并JS/CSS文件。服务器端（CDN）自动合并，基于Node.js的文件合并工具，通过把所有脚本放在一个文件中的方式来减少请求数。
- 使用CSS Sprite雪碧图将背景图片合并成一个文件，通过background-image 和 background-position 控制显示
- 行内图片（Base64编码）。使用Data URI scheme将图片嵌入HTML或者CSS中；或者将CSS、JS、图片直接嵌入HTML中，会增加文件大小，也可能产生浏览器兼容及其他性能问题。

### 2. 减少DNS查询

用户输入URL后，浏览器首先要查询域名（hostname）对应服务器的IP地址，一般需要耗费20-120毫秒时间。DNS查询完成之前，浏览器无法从服务器下载任何数据。

基于性能考虑，ISP、局域网、操作系统、浏览器都会有相应的 DNS 缓存机制。

**DNS缓存机制：**

- IE缓存30分钟，可通过注册表中DnsCacheTimeout项设置
- Firefox缓存1分钟，通过network.dnsCacheExpiration配置
- Chrome等现代浏览器也有相应的DNS缓存策略

另外需要注意的是这里有一个矛盾，减少不同的域名可减少 DNS 查找，同时也减少了页面下载资源文件的并发量。也就是说，虽然避免 DNS 查找削减了响应时间，但是减少并行下载数量却增加了响应时间。原则是把组件分散在 2~4 个域名下，控制好数量，这是同时减少 DNS 查找和允许并发下载的折中方案。

```注解
为什么通过减少DNS查询能够优化？
1. 时间开销
每次DNS查询需要消耗20-120毫秒时间，而查询未完成前会阻塞浏览器下载资源。多个域名=多次DNS查询=累积延迟。这也是为什么2～4个域名是最佳实践，过少域名DNS查询次数虽然减少了，但并发下载受限，而过多域名DNS查询开销过大，并发下载多。

2. 网络开销
用户请求 → 本地DNS缓存 → 递归DNS服务器 → 根域名服务器 → 顶级域名服务器 → 权威域名服务器
每一个环节都网络延迟，影响整体性能。

3. 浏览器行为
浏览器必须先完成DNS解析才能建立TCP连接，而解析过程遇到新域名就要暂停等待DNS解析。

具体场景：
假设页面有10个资源分布在5个不同域名：
 - 没有DNS缓存时：5 × 80ms(平均DNS查询) = 400ms 额外延迟
 - 有DNS缓存时：第一次访问后续页面几乎无DNS开销
这就是为什么DNS查询优化对首次访问和缓存过期后的访问影响最大的原因！
所以减少DNS查询本质上是在减少这种串行阻塞带来的时间开销。
```

```注解
DNS查询优化具体方法

1. DNS预解析设置
<!-- 预解析即将用到的域名 -->
<link rel="dns-prefetch" href="//example.com">

<!-- 对于HTTPS站点，还可以预连接 -->
<link rel="preconnect" href="https://fonts.googleapis.com">

2. 服务器DNS优化
设置合理的TTL值

3. CDN配置优化
将静态资源分布到少数几个CDN域名，不同资源分散在不同域名下

```

### 3. 避免重定向

HTTP重定向通过301/302状态码实现。下面是一个有301状态码的HTTP头

```text
HTTP/1.1 301 Moved Permanently 
Location: http://example.com/newuri
Content-Type: text/html
```

浏览器会自动跳转到Location域指明的URL。重定向需要的所有信息都在HTTP头部，而响应体一般是空的。其实额外的HTTP头，比如Expires和Cache-Control也表示重定向。除此之外还有别的跳转方式：refresh元标签和JavaScript，但如果你必须得做重定向，最好用标准的3xxHTTP状态码，主要是为了让返回按钮能正常使用。

牢记重定向会拖慢用户体验，在用户和HTML文档之间插入重定向会延迟页面上的所有东西，页面无法渲染，组件也无法开始下载，直到HTML文档被送达浏览器。

有一种常见的极其浪费资源的重定向，而且web开发人员一般都意识不到这一点，就是URL尾部缺少一个斜线的时候。例如，跳转到`http://astrology.yahoo.com/astrology`会返回一个重定向到`http://astrology.yahoo.com/astrology/`的301响应（注意添在尾部的斜线）。在Apache中可以用Alias，mod_rewrite或者DirectorySlash指令来取消不必要的重定向。

重定向最常见的用途是把旧站点连接到新的站点，还可以连接同一站点的不同部分，针对用户的不同情况（浏览器类型，用户帐号类型等等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用Alias和mod_rewrite，前提是两个代码路径都在相同的服务器上。如果是因为域名变化而使用了重定向，就可以创建一条CNAME（创建一个指向另一个域名的DNS记录作为别名）结合Alias或者mod_rewrite指令。

```注解
Apache是传统Web服务器的标配，而我们现在更多是使用Nginx，Node.js服务器等。

需要手动配置Apache的配置文件，添加以下内容：
<VirtualHost *:80>
    DocumentRoot /var/www/html
    DirectoryIndex index.html
    # 处理路由重定向等...
</VirtualHost>

雅虎35条军规写于2007年，那时前端工程化还不发达，需要更多地考虑服务器配置。

现在我们可以忽视掉这个优化方法。
```

### 4. 缓存Ajax请求

要提高性能，优化Ajax响应至关重要。最重要的提高Ajax性能的方法就是让响应变得可缓存，就像在添上Expires或者Cache-Control HTTP头中讨论的一样。

**其他适用于Ajax的优化规则：**

- **Gzip组件**：Ajax响应数据也应该启用Gzip压缩，特别是返回JSON或XML数据时，可以显著减少传输大小
- **减少DNS查找**：Ajax请求的API域名也要考虑DNS优化，避免频繁的跨域请求导致额外的DNS查询
- **压缩JavaScript**：处理Ajax请求的相关JavaScript代码（如jQuery、axios等库）也需要压缩
- **避免重定向**：Ajax请求的URL路径要避免301/302重定向，否则会增加请求延迟
- **配置ETags**：Ajax响应也要配置合适的ETag头，利用浏览器缓存机制减少不必要的数据传输

这些网络层优化规则对Ajax请求同样有效，应当一并考虑。

```注解
这一块就是http缓存机制，目前这种优化也是主流方案。

Expires 是HTTP/1.0的缓存头，指定资源的过期时间（绝对时间）

# 服务器响应头示例
Expires: Wed, 21 Oct 2024 07:28:00 GMT

# 设置示例：
// Node.js/Express
app.get('/api/data', (req, res) => {
  const expiryDate = new Date();
  expiryDate.setHours(expiryDate.getHours() + 24); // 24小时后过期
  res.set('Expires', expiryDate.toUTCString());
  res.json({ data: 'some data' });
});

// Nginx配置
location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
    expires 1y;  # 静态资源1年过期
}

location /api/ {
    expires 1h;  # API数据1小时过期
}

Cache-Control 是HTTP/1.1的缓存头，功能更强大，优先级高于Expires：

常用指令：
# 基本缓存控制
Cache-Control: max-age=3600                    # 缓存1小时
Cache-Control: no-cache                        # 每次都验证，但可以缓存
Cache-Control: no-store                        # 完全不缓存
Cache-Control: must-revalidate                 # 过期后必须重新验证

# 组合使用
Cache-Control: public, max-age=86400           # 公共缓存，24小时
Cache-Control: private, max-age=300            # 私有缓存，5分钟
Cache-Control: no-cache, must-revalidate       # 强制验证

# 设置示例：
// Express.js 不同类型资源的缓存策略
app.use('/static', express.static('public', {
  maxAge: '1y',  // 静态资源长期缓存
  setHeaders: (res, path) => {
    if (path.endsWith('.html')) {
      res.setHeader('Cache-Control', 'no-cache'); // HTML文件不缓存
    }
  }
}));

// API响应缓存
app.get('/api/user/:id', (req, res) => {
  res.set('Cache-Control', 'private, max-age=300'); // 用户数据5分钟
  res.json({ user: userData });
});

app.get('/api/config', (req, res) => {
  res.set('Cache-Control', 'public, max-age=3600'); // 配置数据1小时
  res.json({ config: configData });
});

// 实时数据不缓存
app.get('/api/realtime', (req, res) => {
  res.set('Cache-Control', 'no-store');
  res.json({ timestamp: Date.now() });
});
```

### 5. 延迟加载

页面初始加载时哪些内容是绝对必需的？不在答案之列的资源都可以延迟加载。比如：

非首屏使用的数据、样式、脚本、图片等；
用户交互时才会显示的内容。

遵循「渐进增强」理念开发的网站：JavaScript用于增强用用户体验，但没有（不支持） JavaScript也能正常工作，完全可以延迟加载JavaScript。

将首屏以外的HTML放在不渲染的元素中，如隐藏的`<textarea>`，或者type属性为非执行脚本的`<script>`标签中，减少初始渲染的DOM元素数量，提高速度。等首屏加载完成或者用户操作时，再去渲染剩余的页面内容。

另一个常见的做法是图片的延迟加载（懒加载），具体逻辑是当用户滚动页面看到内容时，再加载所需图片。这种操作在较多图片的网页中，可以节省大量带宽，页面渲染速度也会变快。

```注解
延迟加载（即懒加载）一直都是优化的重要手段。主要方案有以下：

1. 图片懒加载（Lazy Loading）
- Intersection Observer API（现代浏览器推荐）
- 原生 loading="lazy" 属性（最简单）
- 传统滚动事件监听

2. 代码分割（Code Splitting）
- 动态导入import()（ES2020）
- React.lazy 懒加载组件 + Suspense 占位符
- Vue 异步组件（Vue3）
- Webpack 代码分割

3. 路由级别的懒加载

4. 内容延迟渲染
- 虚拟滚动（大列表优化）
- 分页懒加载

5. 资源预加载策略
- preload 预加载关键资源
- prefetch 预加载可能需要的资源
- preconnect/dns-prefetch 预连接外部域名
```

### 6. 预加载

预加载可能看起来和延迟加载是相反的，但它其实有不同的目标。通过预加载组件可以充分利用浏览器空闲的时间来请求将来会用到的组件（图片，样式和脚本）。用户访问下一页的时候，大部分组件都已经在缓存里了，所以在用户看来页面会加载得更快。

实际应用中有以下几种预加载的类型：

- 无条件预加载：尽快开始加载，获取一些额外的组件。以`goodle.com`为例，首页加载完成后会立即下载一个Sprite图片。这个图片并不是首页需要的，而是搜索结果页面上的内容。
- 有条件预加载：根据用户操作猜测用户将要跳转到哪里并据此预加载。在search.yahoo.com的输入框里键入内容后，可以看到那些额外组件是怎样请求加载的。
- 提前预加载：在推出新设计之前预加载。经常在重新设计之后会听到：“这个新网站不错，但比以前更慢了”，一部分原因是用户访问先前的页面都是有旧缓存的，但新的却是一种空缓存状态下的体验。可以通过在将要推出新设计之前预加载一些组件来减轻这种负面影响，老站可以利用浏览器空闲的时间来请求那些新站需要的图片和脚本。

```注解
预加载和懒加载看似矛盾，实际上是互补的优化策略：

**核心区别：**
- 懒加载：推迟加载暂时不需要的资源，优化首屏加载时间
- 预加载：提前加载即将需要的资源，优化后续页面的加载体验

**应用场景：**
1. 懒加载用于：首屏以外的图片、非关键CSS/JS、下方内容等
2. 预加载用于：下一页面的关键资源、用户可能访问的资源、关键路径资源

**协同工作：**
首屏 → 懒加载非关键资源 → 同时预加载下个页面资源 → 提升整体用户体验

**预加载具体方案：**

1. **Resource Hints（资源提示）**
- dns-prefetch 预解析DNS
- preconnect 预连接（DNS + TCP + TLS）
- preload 预加载关键资源
- prefetch 预获取可能需要的资源

2. **JavaScript 动态预加载**
- 图片预加载 preloadImages
- 脚本预加载 preloadScript
- 样式预加载 preloadCSS

3. **Web API 预加载**
- Service Worker 预缓存
- Intersection Observer 预加载

4. **模块预加载（现代框架）**
- React - 路由级预加载
- Vue - 异步组件预加载
- Next.js - 自动预加载
```

### 7. 减少DOM操作

一个复杂的页面意味着要下载更多的字节，而且用JavaScript访问DOM也会更慢。举个例子，想要添加一个事件处理器的时候，循环遍历页面上的500个DOM元素和5000个DOM元素是有区别的。

从以下几个角度考虑移除不必要的标记：
- 是否还在使用表格布局
- 塞进去更多的`</div>`仅为解决布局问题，也许有更好、更语义化的标记
- 能否通过伪元素实现的功能，就没必要添加额外元素，如清除浮动

DOM元素的数量很容易测试，只需要在控制台里输入：
```js
document.getElementsByTagName('*').length
```

```注解
**为什么虚拟DOM时代仍需要减少DOM操作？**

1. **虚拟DOM不是万能的**
   - 虚拟DOM只是优化了DOM操作过程，但最终仍要操作真实DOM
   - 虚拟DOM diff算法复杂度与节点数量相关，节点越多计算越耗时
   - 大量DOM节点会增加虚拟DOM树的大小和比较成本

2. **浏览器渲染性能限制**
   - 即使是虚拟DOM最终更新到真实DOM时，浏览器仍需重排重绘
   - DOM节点越多，Layout（布局）和Paint（绘制）越耗时
   - 过多DOM节点会增加内存占用，影响垃圾回收效率

3. **JS引擎执行效率**
   - DOM查询和遍历操作的时间复杂度与DOM数量正相关
   - 事件代理的效率会因DOM层级过深而下降
   - CSS选择器匹配性能也与DOM结构复杂度相关

**减少DOM操作的具体方案：**

1. 组件化架构优化，避免平铺式大量DOM，组件化精简DOM
2. 虚拟滚动（长列表优化）
3. DOM批量操作，避免在for循坏里面逐个操作DOM，而是使用DocumentFragment批量操作DOM和innerHTML批量更新DOM
4. CSS优化减少DOM，避免使用额外DOM实现效果，而是使用CSS伪元素替代
5. 事件委托减少事件绑定，避免给每个元素绑定事件，而是使用事件委托
6. 现代框架最佳实践，使用Key优化列表渲染，React使用React.memo和useMemo避免不必要的重渲染，Vue使用v-memo缓存复杂计算结果

即使在虚拟DOM时代，减少DOM操作仍是性能优化的基础。关键是要理解虚拟DOM的工作原理，合理运用组件化、虚拟滚动、批量操作等技术，在减少DOM节点数量的同时提升用户体验。
```
### 8. 使用多个域名

Chrome 等现代化浏览器，都会有同域名限制并发下载数的情况，不同的浏览器及版本都不一样，简单的情况如下：

- Chrome34/32	并发下载数为6
- IE10	并发下载数为6
- IE11		并发下载数为13
- Firefox27/26		并发下载数为6
- Safari7.0.1		并发下载数为6

使用不同的域名可以最大化下载线程，但注意保持在 2~4 个域名内，以避免 DNS 查询损耗。

例如，动态内容放在`csspod.com`上，静态资源放在`static.csspod.com`上。这样还可以禁用静态资源域下的 Cookie，减少数据传输，详见 Cookie 优化。

```注解
这条内容已经过时。

同域名并发限制是指浏览器为了访问服务器过载和优化性能，对同一个域名下的并发http请求数量设置的限制，通常为6个。

HTTP1/1.1时代，默认限制每个域名同时建立约为6个并发TCP连接。

HTTP2时代，引入了多路复用技术，在一个TCP连接上可以同时发送和接收多个请求和响应。

**现代替代方案**

1. **启用HTTP/2**：确保服务器支持HTTP/2协议
2. **资源合并**：使用模块打包工具（Webpack、Vite等）合并资源
3. **CDN优化**：使用支持HTTP/2的CDN服务

如何分辨网站使用的HTTP版本？

- 按F12打开开发者工具
- 切换到Network标签页
- 刷新页面
- 查看请求列表
- 右键标题栏，勾选"Protocol"列
- 查看协议列：h2表示HTTP/2，http/1.1表示HTTP/1.1

HTTP1和HTTP2的区别：

报文格式：
HTTP/1.x 使用纯文本的报文。而HTTP/2 将数据分割为更小的、二进制格式的帧进行传输，并且在传输过程中可以乱序发送，然后在接收端根据流标识重新组装。

多路复用：
HTTP/1.1 在单个TCP 连接中一次只能处理一个请求。HTTP/2 则在一个TCP 连接中可以同时传输多个数据流（一个连接多个请求），即多路复用，解决了HTTP/1.1 中的队头阻塞问题，提高了效率。

头部压缩：
HTTP/1.x 头部信息庞大且每次请求都会重复发送。HTTP/2 使用HPACK 算法对头部进行压缩，通过索引表避免重复传输相同的头部信息，大幅减少了数据传输量。

服务器推送：
HTTP/2 允许服务器在客户端请求之前，主动将某些可能需要的资源“推送”给客户端，这样客户端可以更早地获取到所有资源，从而提高网页加载速度。﻿
```

### 9. 减少iframe使用

用`<iframe>`可以把一个HTML文档插入到父文档里，重要的是明白`<iframe>`是如何工作的并高效地使用它。

**`<iframe>`的优点：**
- 可以用来加载速度较慢的第三方资源，如广告、徽章；
- 可用作安全沙箱；
- 可以并行下载脚本。

**`<iframe>`的缺点：**
- 加载代价昂贵，即使是空的页面；
- 阻塞页面 load 事件触发；
- Iframe 完全加载以后，父页面才会触发 load 事件。 Safari、Chrome 中通过 JavaScript 动态设置 iframe src 可以避免这个问题。
- 缺乏语义。

```注解
时至今日，iframe仍然有较多的使用场景，比如：
- 支付宝、微信支付等在线支付；内嵌高德、百度地图；内嵌YouTube视频等第三方内容集成

**现代化替代方案**

1. 使用Web Components替代iframe，Web Components是一种新的标准化组件系统，可以自定义标签，实现组件的封装和复用，避免iframe的语义化和SEO问题。
2. 微前端架构，qiankun、single-spa等微前端框架，可以实现多个子应用的独立加载和卸载，避免iframe的阻塞问题。
```

### 10. 杜绝404

HTTP 请求是昂贵的，所以发出 HTTP 请求但获得没用的响应（如 404）是完全不必要的，并且会降低用户体验。

一些网站会有特别的 404 页面提高用户体验，但这仍然会浪费服务器资源。更糟糕的是当链接指向外部 js 但却得到 404 结果。这样首先会降低（占用）并行下载数，其次浏览器可能会把 404 响应体当作 js 来解析，试图从里面找出可用的东西。


## 服务器

### 11. 使用CDN

用户与服务器的物理距离对响应时间也有影响。把内容部署在多个地理位置分散的服务器上能让用户更快地载入页面。

网站 80-90% 响应时间消耗在资源下载上，减少资源下载时间是性能优化的黄金法则。相比分布式架构的复杂和巨大投入，静态内容分发网络（CDN）可以以较低的投入，获得加载速度有效提升。

内容分发网络（CDN）是一组分散在不同地理位置的web服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数（hop）最少的或者响应时间最快的服务器。

```注解
CDN 服务是一种很好的优化手段，也是目前我司使用的一种重要手段。Cloudflare、七牛云 CDN、融合云/融合 CDN等。特别是海外业务，有一些地区网络存在波动问题，使用 CDN 服务可以显著提升访问速度。

另外这些CDN厂商也支持设置缓存策略。
```

### 12. 添加Expires或者Cache-Control头

这条规则有两个方面：

- 对于静态组件：通过设置一个遥远的将来时间作为 Expires 来实现永不失效
- 多余动态组件：用合适的 Cache-Control HTTP 头来让浏览器进行条件性的请求

网页设计越来越丰富，这意味着页面里有更多的脚本，图片。站点的新访客可能还是不得不提交几个 HTTP 请求，但通过使用有效期能让组件变得可缓存，这避免了在接下来的浏览过程中不必要的 HTTP 请求。

一般来讲，浏览器等客户端都会有缓存机制来减少 HTTP 请求的数目和大小，让页面能够更快加载。Web 服务器通过有效期 HTTP 响应头来告诉客户端，页面的各个组件应该被缓存多久。用一个遥远的将来时间做有效期，告诉浏览器这个响应在 2022 年 4 月 15 日前不会改变。

```http
Expires: Thu, 15 Apr 2022 20:00:00 GMT
```

Cache-Control 使用 max-age 指令指定组件被缓存多久，它以秒为单位定义了一个更新期限。使用带有 max-age 的 Cache-Control 可以消除 Expires 的限制，但对于不支持 HTTP1.1 的应用（在 2019 的现在很少很少了），仍希望使用 Expires 头。可以同时制定这两个响应头，如果两者同时出现时，HTTP 规范规定 max-age 指令将重写 Expires 头。

当出现了 Expires 头时，直到过期时间为止一直会使用缓存的版本，浏览器不会检查任何更新，直到过了过期时间。为了确保用户能够获取组件的最新版本，需要在所有的 HTML 页面中修改组件的文件名。Yahoo 在此使用了将版本号嵌入在组件的文件名中的方法，简而言之就是通过修改文件名的方式来重置缓存。

```注解
这个优化，其实就是http请求缓存。

具体可以参考我的另一篇文章[http请求缓存]。
```

### 13. Gzip压缩

压缩可以通过减少HTTP请求响应的大小来缩短响应时间。

从 HTTP1.1 开始，Web 客户端可以通过 HTTP 请求中的 Accept-Encoding 头来标识对压缩的支持。

```http
Accept-Encoding: gzip, deflate, br
```

如果 Web 服务器看到请求中的这个头，就会使用客户端列出的方法中的一种来压缩响应。Web 服务器通过响应中的 Content-Encoding 头来告知 Web 客户端：

```http
Content-Encoding: gzip
```

Gzipping一般能够把响应压缩到70%左右，目前大约90%的通过浏览器的网络传输都支持gzip。

```注解

目前Gzip压缩已经成为了主流的压缩方式，浏览器默认支持，前端无需任何配置。但服务器需要配置才能启用Gzip压缩。

**Nginx配置示例：**
# nginx.conf
http {
    # 启用gzip
    gzip on;
    
    # 压缩级别 1-9，级别越高压缩率越大但CPU消耗也越大
    gzip_comp_level 6;
    
    # 最小压缩文件大小，小于此大小的文件不压缩
    gzip_min_length 1000;
    
    # 压缩的文件类型
    gzip_types
        text/plain
        text/css
        text/js
        text/xml
        text/javascript
        application/javascript
        application/xml+rss
        application/json;
    
    # 为代理请求启用压缩
    gzip_proxied any;
    
    # 禁用IE6的gzip压缩（可选，IE6支持有问题）
    gzip_disable "msie6";
}

**Node.js Express配置示例：**
const express = require('express');
const compression = require('compression');
const app = express();

// 启用gzip压缩中间件
app.use(compression({
    // 压缩级别
    level: 6,
    // 压缩阈值，小于此大小不压缩
    threshold: 1024,
    // 压缩算法
    strategy: compression.constants.Z_DEFAULT_STRATEGY
}));

app.get('/', (req, res) => {
    res.send('Hello World!');
});

**Vite配置示例：**
// vite.config.js
import { defineConfig } from 'vite'
import viteCompression from 'vite-plugin-compression'

export default defineConfig({
  plugins: [
    viteCompression({
      verbose: true,          // 显示压缩结果
      disable: false,         // 不禁用压缩
      deleteOriginFile: false, // 保留原文件
      threshold: 10240,       // 10KB以上的文件才压缩
      algorithm: 'gzip',      // 使用gzip算法
      ext: '.gz',            // 压缩文件扩展名
    })
  ]
})

**最佳实践：**

1. **压缩文本类文件**：HTML、CSS、JS、JSON、XML、SVG等
2. **不压缩已压缩文件**：图片、视频、音频、压缩包等
3. **设置合理阈值**：太小的文件压缩收益不大，建议1KB以上才压缩
4. **选择合适压缩级别**：一般选择6级，平衡压缩率和CPU消耗
5. **CDN启用压缩**：如果使用CDN，确保CDN服务商也启用了Gzip
```

### 14. 配置Etag
### 15. 尽早输出（flush）缓冲
### 16. Ajax请求使用GET请求
### 17. 避免图片src为空

## Cookie
### 18. 减少Cookie大小
### 19. 静态资源使用无Cookie域名

## CSS
### 20. 把脚本放在页面底部
### 21. 使用外部JavaScript和CSS
### 22. 压缩JavaScript和CSS
### 23. 移除重复脚本
### 24. 减少DOM操作
### 25. 使用高效的事件处理

## 图片
### 优化图片
### 优化CSS Sprite
### 不要在HTML中缩放图片
### 使用体积小、可缓存的favicon.ico

## 移动端
### 保证所有组件都小于25k
### 打包内容为分段文档