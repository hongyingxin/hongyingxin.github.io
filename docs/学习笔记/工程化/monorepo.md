# monorepo

## 什么是monorepo

Monorepo 翻译为“单一仓库”，是一种项目代码管理方式，指单个仓库中管理多个项目，有助于简化代码共享、版本控制、构建和部署等方面的复杂性，并为团队提供了更集中、更统一的开发环境。

## monorepo演进

### Monolith

一开始，一个Git仓库维护着项目代码，所有项目都放在同一个目录下，这种方式的优势在于部署简单，开发便捷，性能优势，技术栈统一。但随着项目越来越多，代码越来越复杂，大量代码构建效率也会降低，这种方式的缺点也逐渐暴露出来：扩展性限制，维护复杂性，版本冲突等。

Monolith代表性开源项目有WordPress CMS系统，由一个代码库维护着所有项目代码。

### MultiRepo

为了解决Monolith的缺点，于是将项目拆解成多个业务模块，并在多个Git仓库管理，模块解耦，大大降低了项目的复杂度，每个模块都可以独立编码、测试、开发，代码管理变得简化，构建效率也得以提升，这种代码管理方式称之为MultiRepo。

MultiRepo 是一种软件开发结构，其中每个项目或组件都有独立的代码仓库。这种分散的结构可能导致项目间协同开发困难，版本控制和依赖管理变得复杂。随着时间推移，不一致的构建和部署流程、依赖管理复杂、降低的可维护性以及困难的持续集成等。

MultiRepo强调分散管理，所以较难列举。如Vue Router、Vuex等独立仓库。

### Monorepo

为了解决上面MultiRepo的缺点，于是将多个项目代码管理在同一个仓库中，通过项目隔离，共享依赖，统一构建，统一部署，这种代码管理方式称之为Monorepo。

Monorepo 的代表性开源项目有Vue 3。

## Monorepo的优劣对比

| 场景 | MultiRepo | MonoRepo |
|------|-----------|----------|
| **代码可见性** | ✅ 代码隔离，研发者只需关注自己负责的仓库<br>❌ 包管理按照各自owner划分，当出现问题时，需要到依赖包中进行判断并解决 | ✅ 一个仓库中多个相关项目，很容易看到整个代码库的变化趋势，更好的团队协作<br>❌ 增加了非owner改动代码的风险 |
| **依赖管理** | ❌ 多个仓库都有自己的 node_modules，存在依赖重复安装情况，占用磁盘内存大<br>❌ 依赖管理不便，多个依赖可能在多个仓库中存在不同版本，重复安装，npm link 时不同项目的依赖会存在冲突 | ✅ 多项目代码都在一个仓库中，相同版本依赖提升到顶层只安装一次，节省磁盘内存<br>✅ 依赖调试方便，依赖包迭代场景下，借助工具自动 npm link，直接使用最新版本依赖，简化了操作流程 |
| **代码权限** | ✅ 各项目单独仓库，不会出现代码被误改的情况，单个项目出现问题不会影响其他项目 | ❌ 多个项目代码都在一个仓库中，没有项目粒度的权限管控，一个项目出问题，可能影响所有项目 |
| **开发迭代** | ✅ 仓库体积小，模块划分清晰，可维护性强<br>❌ 多仓库来回切换（编辑器及命令行），项目多的话效率很低。多仓库间存在依赖时，需要手动 npm link，操作繁琐 | ✅ 多个项目都在一个仓库中，可看到相关项目全貌，编码非常方便<br>✅ 代码复用高，方便进行代码重构<br>❌ 多项目在一个仓库中，代码体积可达几个 G，git clone时间较长 |
| **工程配置** | ❌ 各项目构建、打包、代码校验都各自维护，不一致时会导致代码差异或构建差异 | ✅ 多项目在一个仓库，工程配置一致，代码质量标准及风格也很容易一致 |
| **构建部署** | ❌ 多个项目间存在依赖，部署时需要手动到不同的仓库根据先后顺序去修改版本及进行部署，操作繁琐效率低 | ✅ 构建性 Monorepo 工具可以配置依赖项目的构建优先级，可以实现一次命令完成所有的部署 |

## Monorepo的使用场景

1. 大型项目与多项目协作

场景：企业或团队维护多个紧密关联的项目（如前端、后端、工具库）

优势：集中管理代码，方便跨项目修改和协作，避免代码分散导致的重复工作。

2. 共享代码与依赖

场景：多个项目共用组件库、工具函数或配置（如UI组件、通用SDK）

优势：直接引用内部模块，避免多仓库的版本同步问题，确保依赖一致性

3. 统一构建与持续集成（CI/CD）

场景：需要标准化构建、测试和部署流程（如CI/CD流水线）

优势：集中配置CI/CD流程，减少重复配置，提高效率

## Monorepo踩坑

1. 依赖安装耗时长

问题：Monorepo中每个项目都有自己的`package.json`依赖列表，随着Monorepo项目的增多，依赖安装时间会越来越长。

解决方案：相同版本依赖提升到 Monorepo 根目录下，减少冗余依赖安装；使用 pnpm 按需安装及依赖缓存。

2. 构建打包耗时长

问题：多个项目构建任务存在依赖时，往往是串行构建 或 全量构建，导致构建时间较长。

解决方案：增量构建，而非全量构建；也可以将串行构建，优化成并行构建。

## Monorepo工具对比

在采用 Monorepo（单一仓库）架构的软件开发中，工具的选择是至关重要的。合适的 Monorepo 工具能够帮助团队更高效地管理大规模代码库、提升协同开发体验以及优化构建和部署流程。
直至 2025 年，目前在前端界比较流行的 Monorepo 工具有 Rush、Turborepo、Lerna、Yarn Workspaces、Pnpm Workspaces、Yalc、npm Workspaces 和 Nx，下面将会简单分享各个热门工具的优缺点。

### Rush

Rush 是由 Microsoft 打造的 Monorepo 管理工具，旨在优化大型项目的构建和开发流程。它支持同时管理多个包，提供自动版本管理、并行构建、增量构建等功能，通过统一的命令行工具简化 Monorepo 的操作。尽管具有完整的生态系统和强大的社区支持，但学习曲线可能较陡峭，适用于大型项目而对小型项目可能显得过于庞大。

**功能**

- 解决了幽灵依赖：将项目所有依赖都安装到Repo根目录的common/temp下，通过软链接到各项目，保证各项目node_modules下依赖与package.json中依赖一致。
- 并行构建：Rush支持并行构建多个项目，提高了构建效率
- 插件系统：Rush提供了丰富的插件系统，可以扩展其功能，满足不同的需求
- 项目发布：ChangeLog支持友好，自动修改项目版本号，自动生成发布日志

**优点**

- 完整生态系统： Rush 提供了一系列工具和脚本，构建了一个完整的 Monorepo 生态系统，从版本管理到构建发布都有涵盖。
- 自动版本管理： 具备自动版本升级和依赖管理的功能，简化了维护过程，减轻了开发者的负担。
- 并行构建和增量构建： Rush 支持并行构建，提高了整体构建效率，同时也支持增量构建，仅构建发生变化的包，节省了构建时间。
- 社区支持： 作为由 Microsoft 支持的项目，Rush 有庞大的社区基础，保证了持续的更新和维护。

**缺点**

- 学习曲线较陡峭： Rush 的学习曲线较陡峭，需要花费一定时间去学习和理解其使用方法。
- 适用性： 由于其强大的功能集，更适用于大型项目，对于小型项目来说可能显得过于庞大，不太合适。

### Turborepo

Turborepo 是 Vercel 团队开源的高性能构建代码仓库系统，允许开发者使用不同的构建系统。专注于提升大型 Monorepo 项目性能的工具，通过支持并行构建和增量构建等功能，显著减少了构建时间，同时具备分布式缓存和模块化工具链设计，为开发者提供了更灵活的定制选择。虽然相对较新，但其性能优化和灵活性使其在大型项目中备受欢迎。

**优点**

- 性能优化： Turborepo 专注于提升 Monorepo 项目的性能，通过并行构建和增量构建等手段，显著减少了构建时间。
- 定制灵活： 工具链模块化设计，使得开发者可以根据项目需求选择和配置不同的工具，提供更大的灵活性。

**缺点**

- 较新项目： 相对于一些更成熟的 Monorepo 工具，Turborepo 可能相对较新，社区生态和文档可能相对有限。
- 学习曲线： 与其他 Monorepo 工具相比，Turborepo 的学习曲线可能较陡峭，需要一定时间的适应。

### Lerna

Lerna 是一款专为管理具有多个软件包的 JavaScript 项目而设计的工具，旨在优化大型 Monorepo 项目的版本管理、依赖共享以及发布流程。通过提供一套强大的命令行工具，Lerna 简化了 Monorepo 项目的操作，使开发者能够更轻松地管理和维护庞大的代码库，提高开发效率和代码的可维护性。

**优点**

- 版本一致性： Lerna 有助于确保 Monorepo 中各个软件包的版本保持一致，减少了因版本不一致而导致的问题。
- 依赖管理： 提供了方便的依赖管理机制，允许在项目中共享和重用代码，减少了重复劳动。
- 发布自动化： Lerna 支持自动化的发布过程，能够一次性发布所有更新的软件包，提高了发布的效率。
- 操作简便： 具备强大的命令行工具，使得 Monorepo 项目的操作变得简单易行，包括软件包的添加、删除、测试等。

**缺点**

- 上手难度： 对于初学者来说，Lerna 的学习曲线可能较陡峭，需要花一些时间熟悉其概念和操作。
- 维护成本： 随着项目的规模增加，Monorepo 中的软件包数量可能庞大，这会增加维护的难度和成本。
- 配置复杂： 部分用户认为 Lerna 的配置相对复杂，需要仔细调整以满足特定项目的需求，可能需要更多的配置文件。

### Nx

Nx 是一个开源的工具，专为管理和开发大型 Monorepo 项目而设计。它建立在 Angular CLI 之上，提供了一套功能强大的工具和插件，支持多语言、多框架的项目。Nx 的核心理念是通过插件化的方式，为开发者提供更高层次的抽象，以提高项目的可维护性、可扩展性和开发效率。Nx 支持生成可重用的领域库、定义和执行一致的工作流，以及提供强大的可视化工具来监控项目和性能。

**优点**

- 强大的插件生态： Nx 提供了丰富的插件生态系统，支持多语言、多框架，使得开发者可以选择最适合其项目的工具。
- 一致的工作流： Nx 引入了一致的工作流程，通过定义任务和脚本，提高了多包项目的开发效率和一致性。
- 全面的可视化工具： Nx 提供了全面的可视化工具，帮助开发者更好地理解项目结构、监控性能，并提供快速导航和跳转。

**缺点**

- 学习曲线较陡峭： 由于 Nx 提供了丰富的功能和抽象，初学者可能需要花费一些时间来理解和熟悉其工作原理。
- 依赖于 Angular： Nx 的核心建立在 Angular CLI 之上，因此对于不使用 Angular 框架的项目可能显得过于重量级。
- 复杂性增加： 尽管 Nx 提供了丰富的功能，但对于小型项目而言，引入 Nx 可能带来不必要的复杂性。

### Npm Workspaces

npm Workspaces 是 npm 包管理工具的功能模块之一，旨在支持 Monorepo（单一仓库）结构的项目。该功能允许在单一仓库中管理多个包，通过一个统一的 package.json 文件来管理各个包的依赖和脚本。npm Workspaces 提供了一系列命令和配置，使得开发者可以更便捷地进行多包的管理，如依赖安装、脚本执行等。尽管在某些方面不如其他专业的 Monorepo 工具强大，npm Workspaces 提供了一种相对轻量级的方案，适用于一些小型或者简单的 Monorepo 项目，无需引入额外的复杂性。

**优点**

- 简单易用： npm Workspaces 提供了一种相对简单的 Monorepo 管理方案，易于上手和使用。
- 内建支持： 作为 npm 的一部分，npm Workspaces 不需要额外的安装，无需引入其他工具，方便集成到已有项目中。
- 灵活性： 对于小型或简单的 Monorepo 项目，npm Workspaces 提供了足够的灵活性，无需引入过多复杂性。

**缺点**

- 性能问题： 随着项目规模的增大，npm Workspaces 的性能可能会受到影响，尤其是在进行依赖安装时。
- 生态相对薄弱： 与一些专业的 Monorepo 工具相比，npm Workspaces 的生态系统相对较小，可能缺乏某些高级功能和插件。
- 限制性： 在某些高级场景下，npm Workspaces 可能无法提供足够的灵活性和功能，无法完全替代更专业的 Monorepo 工具。

### Yarn Workspaces

Yarn Workspaces 是 Yarn 包管理器的一项强大功能，专注于优化 Monorepo 项目的依赖关系管理。它允许将多个包组织在同一个版本控制存储库中，通过统一依赖版本解决了版本冲突问题，同时通过共享顶层 node_modules 目录，有效减小了磁盘占用。Yarn Workspaces 支持交叉包引用，提供了更灵活的项目组织方式，并通过并行安装加速了整体构建速度。它是一个轻量级而功能强大的 Monorepo 解决方案，尤其适用于中小型项目和对简单性要求较高的团队。

**优点**

- 依赖一致性： 通过统一依赖版本，有效解决了依赖冲突和版本不一致的问题，提高了项目的稳定性。
- 资源共享： 通过单一 node_modules 目录，减小了磁盘占用，提高了模块查找效率。
- 灵活性： 允许在 Monorepo 中的包之间进行相互引用，提供更灵活的项目组织方式。

**缺点**

- 初始学习曲线： 对于新用户来说，Yarn Workspaces 的使用可能需要一定时间的学习，特别是对于没有使用过 Yarn 的开发者。
- 功能相对简化： 与一些专注于 Monorepo 管理的工具相比，Yarn Workspaces 的功能相对简化，可能不适用于所有复杂的项目结构。

### Pnpm Workspaces

pnpm workspace 是 pnpm 包管理工具的一个功能模块，专注于支持 Monorepo（单一仓库）的工作区管理。它通过高效的依赖共享机制，将多个相关的包集中管理，实现了更快速、更节省空间的依赖安装和执行。pnpm workspace 提供了命令行工具，支持多包管理、依赖共享、版本一致性维护、脚本运行等功能，使得在单一仓库中管理多个包变得更为便捷和高效。尽管可能存在学习曲线和部分生态支持的挑战，但其在 Monorepo 场景下的优势在于提供了快速、节省空间、版本一致性等方面的综合解决方案。

**优点**

- 快速的安装和执行： pnpm 利用了硬链接和符号链接的方式，使得依赖的安装和执行更加迅速。
- 磁盘空间节省： 通过依赖共享机制，pnpm 节省了大量磁盘空间。
- 版本一致性： 工作区功能有助于保持包的版本一致性，降低了由于版本不一致导致的问题。

**缺点**

- 学习曲线： 对于不熟悉 pnpm 和工作区概念的开发者来说，需要一些时间来适应和学习。
- 部分生态支持： 虽然 pnpm 在支持的生态方面不断增加，但与其他更成熟的包管理工具相比，仍有一些生态上的差距。

## Monorepo工具综合对比表

| 工具 | 开发者 | 主要特点 | 优点 | 缺点 | 依赖管理 | 版本管理 | 增量构建 | 插件扩展 | 云端缓存 | GitHub Stars |
|------|--------|----------|------|------|----------|----------|----------|----------|----------|-------------|
| **Rush** | Microsoft | 为大型Monorepo项目提供全面的支持，具有完整的生态系统，自动版本管理和并行构建 | 1. 完整生态系统<br>2. 自动版本管理<br>3. 并行构建 | 1. 学习曲线较陡峭<br>2. 对小型项目可能显得过于庞大 | ✅ | ✅ | ✅ | ✅ | ✅ | 4.9K |
| **Turborepo** | Vercel | 旨在提供高度可配置的Monorepo解决方案，支持自定义构建流程和任务，灵活性较高 | 1. 高度可配置<br>2. 支持自定义构建流程 | 1. 相对较新，可能缺乏一些成熟的功能和社区支持 | ❌ | ❌ | ✅ | ✅ | ✅ | 20.4K |
| **Lerna** | 社区 | 专注于管理具有多个包的JavaScript项目，提供了一组工具用于优化Monorepo的管理，支持并行构建，版本管理等 | 1. 专注于JavaScript项目<br>2. 并行构建<br>3. 版本管理方便 | 1. 学习曲线较陡峭<br>2. 配置不够灵活 | ❌ | ✅ | ❌ | ❌ | ❌ | 34.3K |
| **Nx** | Nrwl | 针对Angular项目的工具，提供了一套强大的Monorepo管理功能，包括构建、测试、文档生成等，专注于提高Angular项目的开发效率 | 1. 针对Angular项目优化的强大功能集 | 1. 针对非Angular项目可能显得过于专业化，学习曲线较陡峭 | ❌ | ❌ | ✅ | ✅ | ✅ | 17K |
| **Pnpm Workspaces** | Pnpm团队 | Pnpm的一部分，提供了与Yarn Workspaces类似的功能，支持多个包共享依赖，通过符号链接进行高效的依赖管理 | 1. 高效的依赖管理<br>2. 易于上手 | 1. 功能相对比较单一<br>2. 需要适应符号链接的概念 | ✅ | ❌ | ❌ | ❌ | ❌ | 22.7K |
| **Yarn Workspaces** | Yarn团队 | Yarn的一部分，提供了一种Monorepo管理方案，允许多个包共享相同的node_modules，轻量级，易于上手 | 1. 轻量级<br>2. 易于上手 | 1. 功能相对比较单一 | ✅ | ❌ | ❌ | ❌ | ❌ | - |
| **npm Workspaces** | npm团队 | npm的一部分，提供了在Monorepo中管理包的功能，与Yarn Workspaces类似，但在某些方面有所不同 | 1. 与npm集成 | 1. 功能相对简单 | ✅ | ❌ | ❌ | ❌ | ❌ | - |

## 依赖管理

在经过上面的对比后，初步确定了`yarn workspaces`和`pnpm workspaces`作为Monorepo的工具。因为这两者具备更好的可升级性和扩展性。

由于npm和yarn都存在幽灵依赖现象，而pnpm则不存在这个问题，最终选择了pnpm。

## 版本控制

尽管 Pnpm Workspace 在管理子模块间的依赖方面表现出色，但它并未提供统一修改各个子模块关联版本号的功能，开发者需要单独进入每个子模块进行版本号的修改。因此，为了实现更全面的 Monorepo 项目管理，包括批量修改版本号、记录各个模块的修改日志以及自动化发布等功能，我们需要为其选择一个适用的版本管理和发布工具。

尽管 Lerna 不再负责依赖管理，但它将更多关注点放在了 Monorepo 项目的版本管理和发布上。通过结合 Lerna 和 Conventional Changelog 两个工具，我们可以轻松地统一修改 Monorepo 项目中各个子模块的关联版本号，并记录每次修改的日志。

## 选型建议

建议采用渐进式架构方案，即对于轻量级 Monorepo 项目，推荐选择`Lerna + pnpm workspace + lerna-changelog`，解决了依赖管理、发版管理等问题，为开发者带来便利。

## 参考资料

- [2024 年 Monorepo 工具选择和实践](https://juejin.cn/post/7342360674151858202)
- [带你了解更全面的 Monorepo - 优劣、踩坑、选型](https://juejin.cn/post/7215886869199896637)