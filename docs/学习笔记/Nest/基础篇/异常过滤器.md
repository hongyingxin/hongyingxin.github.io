# 异常过滤器

Nest 异常过滤器用于捕获和处理应用程序中抛出的异常。异常主要分为内置异常类和自定义异常。默认情况下，这个功能由内置的全局异常过滤器实现，它能处理 `HttpException` 及其子类的异常。

当遇到无法识别的异常（即不是 `HttpException` 及其子类的异常）时，内置异常过滤器会生成一个默认的 JSON 响应。

```json
{
  "statusCode": 500,
  "message": "Internal server error"
}
```

## HttpException

`HttpException` 类是所有内置异常类的基类，其他内置异常类都继承自 `HttpException`，它提供了自定义类的基础功能。

当程序抛出一个 `HttpException` 对象时，它会被异常处理程序捕获，然后转换成相关的 JSON 响应。

```ts
@Get()
async findAll() {
  throw new HttpException('Forbidden', HttpStatus.FORBIDDEN);
}
// 响应内容
{
  "statusCode": 403,
  "message": "Forbidden"
}
```

`HttpException` 的源码如下：

```ts
constructor(response: string | Record<string, any>, status: number, options?: HttpExceptionOptions | undefined);
```

从以上代码我们可以得知，`HttpException` 的构造函数接收三个参数：

- **response**（必须）：JSON 响应体，可以是字符串或对象
  - `statusCode`：默认为 `status` 参数中提供的 HTTP 状态码
  - `message`：基于 `status` 的 HTTP 错误简短描述
- **status**（必须）：HTTP 状态码，`HttpStatus` 枚举中的值
- **options**（可选）：选项对象，用于提供底层错误原因
  - `cause`：错误原因
  - `description`：错误描述

```ts
// 字符串 + 状态码
throw new HttpException('自定义错误', HttpStatus.CONFLICT);

// 对象 + 状态码
throw new HttpException({
  message: '自定义错误',
  error: 'CUSTOM_ERROR',
  statusCode: 409
}, HttpStatus.CONFLICT);

// 字符串 + 状态码 + 选项
throw new HttpException('自定义错误', HttpStatus.CONFLICT, {
  cause: new Error('业务逻辑冲突'),
  description: '用户尝试创建已存在的资源'
});
```

## 内置异常

Nest 提供了一个内置的 `HttpException` 类，用于处理 HTTP 异常。所有的内置异常类都继承自它。

最常见的内置异常类有：

- `HttpException`（自定义 HTTP 异常）
- `BadRequestException`（400 错误）
- `NotFoundException`（404 错误）
- `UnauthorizedException`（401 错误）
- `ForbiddenException`（403 错误）
- `InternalServerErrorException`（500 错误）
- `NotImplementedException`（501 错误）
- `BadGatewayException`（502 错误）
- `ServiceUnavailableException`（503 错误）
- `GatewayTimeoutException`（504 错误）

这里以 `BadRequestException` 为例，它继承自 `HttpException` 类，并实现了构造函数：

```ts
import { HttpException, HttpExceptionOptions } from './http.exception';

export default class BadRequestException extends HttpException {
  /**
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(objectOrError?: any, descriptionOrOptions?: string | HttpExceptionOptions);
}
```

从上面的源码可以看出，`BadRequestException` 的构造函数接收两个参数：

- **objectOrError**：错误信息，可以是字符串或对象
- **descriptionOrOptions**：错误描述，可以是字符串或 `HttpExceptionOptions` 对象

```ts
// 方式1：字符串 + 字符串
throw new BadRequestException('请求参数无效', '缺少必需字段');

// 方式2：字符串 + 选项对象
throw new BadRequestException('请求参数无效', {
  cause: new Error('验证失败'),
  description: '请求体格式不正确'
});

// 方式3：对象 + 状态码
throw new BadRequestException({
  message: '请求参数无效',
  error: 'VALIDATION_FAILED',
  statusCode: 400
}, HttpStatus.BAD_REQUEST);

// 方式4：只传字符串
throw new BadRequestException('请求参数无效');
```

所有的内置异常类都支持这些方式。

## 自定义异常

大多数情况下，内置的异常类已经能够满足需求。由于异常过滤器不会记录内置异常，当这个异常被抛出时，它们并不会出现在控制台中。

如果需要记录异常日志，则需要自定义异常类。自定义异常类可以继承自 `HttpException` 类。

```ts
// forbidden.exception.ts
export class ForbiddenException extends HttpException {
  constructor() {
    super('Forbidden', HttpStatus.FORBIDDEN);
  }
}

// cats.controller.ts
@Get()
async findAll() {
  throw new ForbiddenException();
}
```

## 异常过滤器

基础的异常处理程序满足大多数异常需求，但是有时我们想完全控制异常处理程序的行为。例如，增加一些日志记录，或者在返回响应之前添加一些自定义的逻辑。

这种情况就需要使用异常过滤器。异常过滤器是拦截器的一种，它可以在异常被抛出时，捕获异常，并进行处理，从而达到精准控制流程的目的。

下面是官方的一个例子，创建一个异常过滤器，负责捕获 `HttpException` 类的实例异常，并返回一个自定义的响应。

```ts
import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';
import { Request, Response } from 'express';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    // 获取请求上下文
    const ctx = host.switchToHttp();
    // 在请求上下文中获取 response 对象
    const response = ctx.getResponse<Response>();
     // 在请求上下文中获取 request 对象
    const request = ctx.getRequest<Request>();
    // 获取异常的状态码
    const status = exception.getStatus();
    // 返回自定义的响应
    response
      .status(status)
      .json({
        statusCode: status,
        timestamp: new Date().toISOString(),
        path: request.url,
      });
  }
}
```

`@Catch()` 装饰器用于指定异常过滤器要捕获的异常类型。可接受单个参数或以逗号分隔的列表，如果省略参数，则捕获所有异常。

`catch(exception: T, host: ArgumentsHost)` 方法继承自 `ExceptionFilter` 接口，它接收两个参数：

- **exception**：当前正在处理的异常对象
- **host**：`ArgumentsHost` 对象，用于获取请求上下文

### 绑定

我们通过 `@UseFilters()` 装饰器将异常过滤器绑定到控制器或方法上。

`@UseFilters()` 装饰器接收单个过滤器或以逗号分隔的过滤器实例列表。

> **注意**：`@UseFilters()` 可以接受类和实例，官方推荐使用类，因为类可以被注入，降低内存消耗。

```ts
// cats.controller.ts
@Post()
// 类
@UseFilters(new HttpExceptionFilter())
// 实例
@UseFilters(HttpExceptionFilter)

async create(@Body() createCatDto: CreateCatDto) {
  throw new ForbiddenException();
}
```

### 绑定级别

异常过滤器一共有三种绑定级别：

- **控制器类级别**：在 Controller 类上使用 `@UseFilters(HttpExceptionFilter)`
- **控制器方法级别**：在 Controller 方法上使用 `@UseFilters(HttpExceptionFilter)`
- **全局级别**：在 AppModule 中使用 `@UseFilters(HttpExceptionFilter)`

在控制器类上使用 `@UseFilters(HttpExceptionFilter)` 装饰器，可以为该控制器类中的所有方法绑定异常过滤器。

```ts
@Controller()
@UseFilters(new HttpExceptionFilter())
export class CatsController {}
```

在控制器方法上使用 `@UseFilters(HttpExceptionFilter)` 装饰器，可以为该方法绑定异常过滤器。

```ts
@Post()
@UseFilters(new HttpExceptionFilter())
async create(@Body() createCatDto: CreateCatDto) {
  throw new ForbiddenException();
}
```

全局作用域的绑定方法有两种：

**方法一**

```ts
// main.ts
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalFilters(new HttpExceptionFilter());
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();
```

**方法二**

```ts
// app.module
import { Module } from '@nestjs/common';
import { APP_FILTER } from '@nestjs/core';

@Module({
  providers: [
    {
      provide: APP_FILTER,
      useClass: HttpExceptionFilter,
    },
  ],
})
export class AppModule {}
```
