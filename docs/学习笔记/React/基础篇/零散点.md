# React 零散知识点

## 受控组件 vs 非受控组件

React 有两种不同的方式来处理表单输入。

### 受控组件 (Controlled Components)

组件的状态由 React 的 `state` 控制，组件的输入值由父组件的 `state` 管理，并通过 `props` 传递给子组件。

**特点：**
1. **状态受控**：表单输入的值由组件的 `state` 控制。
2. **单一数据源**：所有输入的值都存储在组件的 `state` 中。
3. **事件处理**：每次用户输入，事件处理函数更新 `state`。

### 非受控组件 (Uncontrolled Components)

组件的状态不由 React 管理，而是由 DOM 元素自身管理，通过使用 `ref` 来实现对 DOM 元素的直接访问。

**特点：**
1. **状态不受控**：表单输入的值由 DOM 元素控制。
2. **直接访问 DOM**：通过 `ref` 访问 DOM 元素的当前值。
3. **简化事件处理**：不需要处理每次输入的变化。

---

**总结：**
受控组件提供了更细粒度的控制，允许你在表单输入发生变化时立即处理数据；非受控组件提供了更简洁的方式来处理表单输入，允许你直接与 DOM 交互。

---

## 高阶组件 (Higher-Order Components)

高阶组件是 React 中用于复用组件逻辑的一种高级技巧。`HOC` 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。例如 Redux 的 `connect`。

高阶组件是参数为组件，返回值为新组件的函数。

使用 `HOC` 解决横切关注点问题，即 `mixins` 产生的问题。

**使用场景：**
- **代码复用**：在多个组件中共享逻辑，比如数据获取、权限检查、主题应用。
- **逻辑分离**：将组件的逻辑和视图分开，提高组件的可维护性。
- **增强组件功能**：为组件添加额外的功能，比如添加日志、缓存数据。


## Fiber 不使用 requestIdleCallback 的原因

React 没有直接使用原生的`requestIdleCallback`，而是基于`MessageChannel`实现了一个自己的调度器`Scheduler`。

**rIC的缺陷**

- 浏览器兼容性极差：因为是由Chrome主导的实验性API，直到现在，Safari浏览器依然不支持

- 刷新频率不确定：rIC的触发频率取决于浏览器的空闲程度。在页面标签处于后台或有其他干扰时，rIC的调用频率可能会降至每秒20次甚至更低。这与React的目标保持60fps（即16.6ms一次）不符。

- 任务执行时机不可控：rIC会在每一帧的布局和重绘之后执行，如果React在这个时机修改了DOM，浏览器不得不立即进行重新布局，这可能会导致一帧内发生两次布局计算，反而降低了性能。

**React的实现**

React团队在`Scheduler`模块中，利用了`MessageChannel`模拟了一个类似于rIC的机制：

- 主动申请时间：它会通过`postMessage`向浏览器发送任务

- 强制控制权：当浏览器完成渲染任务后，会立即执行`MessageChannel`的回调，比rIC更及时稳定

- 多优先级调度：相比rIC只有一个简单的“空闲”概念，React内部实现了5种任务优先级（Immediate, UserBlocking, Normal, Low, Idle），确保用户交互永远优先于背景数据渲染。

**总结**

虽然 rIC 在概念上很契合 Fiber 的异步更新，但由于它在兼容性和触发时机控制上的缺陷，React 最终选择通过 MessageChannel 自己实现了一套高精度的调度器。这不仅解决了跨浏览器问题，还让 React 能在毫秒级内精准把控 UI 更新的优先级。