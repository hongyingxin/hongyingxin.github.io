# 渡一面试

## 拼多多 promise面试题

```js
const p1 = new Promise((resolve, reject) => {
  reject('error');
  resolve('success');
})

p1.then((res1) => {
  console.log(res1);
}).then((res2) => {
  console.log(res2);
}).catch((err) => {
  console.log(err);
}).then((res3) => {
  console.log(res3);
})

const p2 = new Promise((resolve, reject) => {
  reject(new Error('error'));
})

p2.catch((err) => {
  console.log(err);
})

p2.catch((err) => {
  console.log(err);
})
```

**输出结果**

```text
error
undefined  
Error: error
Error: error
```

**解析**

p1的执行：

- p1创建时：执行器函数立即执行，调用reject('error')，Promise状态变为rejected
- resolve('success')不会执行：因为Promise状态一旦确定就不可改变

p1的链式调用：

- 第一个then不执行：因为p1是rejected状态
- 第二个then不执行：因为前面的then没有执行
- catch执行：捕获到rejection，输出'error'，并且catch返回一个resolved的Promise（值为undefined）
- 最后的then执行：因为catch返回了resolved状态的Promise，输出undefined

p2的执行：

- p2创建：立即reject一个Error对象
- 第一个catch执行：输出Error对象
- 第二个catch执行：同样捕获到相同的rejection，输出Error对象

## instanceof 实现

### 原理解析

`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

**核心原理**：沿着对象的原型链向上查找，看是否能找到构造函数的 `prototype`。

### 手写实现

```js
function myInstanceof(left, right) {
  // 获取对象的原型
  let proto = Object.getPrototypeOf(left); 
  // 获取构造函数的 prototype
  let prototype = right.prototype;
  // 沿着原型链向上查找
  while (proto) {
    if (proto === prototype) {
      return true;
    }
    proto = Object.getPrototypeOf(proto);
  }
  return false;
}
```

### 关键知识点

1. **原型链机制**：每个对象都有一个指向其原型的内部链接
2. **Object.getPrototypeOf()**：获取对象的原型，等同于访问 `__proto__`
3. **基本类型处理**：基本数据类型没有原型链，直接返回 false
4. **循环终止条件**：当 proto 为 null 时停止（到达原型链顶端）

## CommonJS

```js
this.a = 1
exports.b = 2
exports = {
  c: 3
}
module.exports = {
  d: 4
}
exports.e = 5
this.f = 6
```

**输出结果**

```js
{ d: 4 }
{ c: 3, e: 5 }
{ f: 6 }
```

**解析**

## 后管权限方案

## Composables 组合式函数的作用

### 面试回答要点

**什么是 Composables？**
Composables 是 Vue 3 中基于组合式 API 的逻辑复用模式，本质上是一个返回响应式数据和方法的函数。

**主要作用：**

1. **逻辑复用** - 将相关的状态和逻辑封装成函数，在多个组件间复用
2. **关注点分离** - 按功能划分逻辑，而不是按选项类型
3. **更好的类型支持** - 相比 mixins 有更好的 TypeScript 推断

**与 Mixins 的区别：**
- **命名冲突**：Composables 通过返回值明确来源，Mixins 可能有属性冲突
- **可追踪性**：Composables 清楚知道数据来自哪个函数
- **灵活性**：可以选择性使用返回的属性和方法

**常见应用场景：**

1. **状态管理**：封装复杂的响应式状态逻辑
2. **API 请求**：统一处理请求状态（loading、error、data）
3. **浏览器 API**：封装 localStorage、sessionStorage、geolocation 等
4. **事件处理**：统一的事件监听器管理
5. **表单验证**：可复用的表单验证逻辑
6. **动画效果**：封装动画相关的状态和方法

**面试要点：**

1. **理解本质**：Composables 是函数式编程思想在 Vue 中的体现
2. **解决痛点**：解决了 Vue 2 mixins 的命名冲突和来源不明问题
3. **组合优势**：可以灵活组合多个 composables，实现复杂功能
4. **响应式系统**：基于 Vue 3 的响应式系统，保持数据的响应性
5. **代码组织**：提供了更好的代码组织和复用方式

### 延展

**函数式编程 vs 面向对象编程**

**函数式编程（Functional Programming）**
- **核心思想**：将计算视为函数的求值，强调函数的组合和复用
- **特点**：
  - 纯函数：相同输入总是产生相同输出，无副作用
  - 不可变性：数据一旦创建就不能修改
  - 函数是一等公民：可以作为参数传递、返回值
  - 组合性：通过函数组合构建复杂逻辑

**面向对象编程（Object-Oriented Programming）**
- **核心思想**：将现实世界抽象为对象，通过对象间的交互解决问题
- **特点**：
  - 封装：将数据和操作数据的方法封装在一起
  - 继承：子类可以继承父类的属性和方法
  - 多态：同一接口可以有不同的实现
  - 抽象：隐藏实现细节，暴露必要接口

**两种编程范式的优缺点：**

| 对比项 | 函数式编程 | 面向对象编程 |
|--------|------------|--------------|
| **复用性** | 函数组合，灵活度高 | 继承机制，结构化强 |
| **测试性** | 纯函数易测试 | 需要模拟对象状态 |
| **可读性** | 逻辑清晰，数据流明确 | 符合现实世界认知 |
| **维护性** | 函数独立，影响范围小 | 继承链复杂时难维护 |
| **学习成本** | 需要转变思维方式 | 更符合直觉思维 |

**Composables 体现的函数式编程优势：**
1. **纯函数特性**：输入相同参数总是返回相同结果
2. **组合性**：可以自由组合多个 composables
3. **无副作用**：不会意外修改外部状态
4. **可预测性**：行为明确，易于理解和调试


## vue3实现响应式数组的区别

vue2 重写了数组方法
vue3 使用了proxy拦截内部方法

## axios和fetch的区别

### 基本概念

**axios**：基于`Promise`的 第三方库，基于`XMLHttpRequest`实现。

**fetch**：浏览器原生 API

### 主要区别对比表

| 对比项 | axios | fetch |
|--------|-------|-------|
| **浏览器兼容性** | 需要引入库，兼容性更好，支持更多浏览器 | 现代浏览器原生支持，IE 不支持 |
| **请求和响应处理** | 自动解析 JSON，直接获取 `response.data` | 需要手动调用 `response.json()` 解析 |
| **错误处理** | 自动处理 HTTP 错误状态（4xx, 5xx） | 需要手动检查 `response.ok` 状态 |
| **请求超时** | 内置支持 `timeout` 配置 | 需要手动实现，使用 `AbortController` |
| **请求拦截器** | 内置支持请求/响应拦截器 | 需要手动封装函数实现 |
| **请求取消** | 使用 `CancelToken` 机制 | 使用 `AbortController` API |
| **并发请求** | 提供 `axios.all()` 和 `axios.spread()` | 使用原生 `Promise.all()` |

### 代码示例对比

#### 浏览器兼容性
- **axios**：需要引入库，兼容性更好，支持更多浏览器
- **fetch**：现代浏览器原生支持，IE 不支持

#### 请求和响应处理

两者传递数据的方式不同，axios 的请求数据放在 data 属性中，以对象的方式进行传递，fetch 的请求数据放在 body 中。以字符串的方式进行传递。

两者对响应数据的转化不同，axios 会自动将响应数据转化为 JSON 格式，而fetch 需要手动转化，转化Api为`arrayBuffer()`、`blob()`、`json()`、`text()`、`formData()`。需要根据请求后的数据类型是什么然后调用对应的转化Api。

```js
// axios 请求数据放在 data 中
const options = {
  url: "http://example.com/",
  method: "POST",
  headers: {
    Accept: "application/json",
    "Content-Type": "application/json;charset=UTF-8",
  },
  data: {
    a: 10,
    b: 20,
  },
};

axios(options).then((response) => {
  console.log(response.status);
});
// axios - 自动解析 JSON
axios.get('/api/data')
  .then(response => {
    console.log(response.data); // 直接获取数据
  });

// fetch 请求数据放在 body 中
const url = "http://example.com/";
const options = {
  method: "POST",
  headers: {
    Accept: "application/json",
    "Content-Type": "application/json;charset=UTF-8",
  },
  body: JSON.stringify({
    a: 10,
    b: 20,
  }),
};

fetch(url, options).then((response) => {
  console.log(response.status);
});
// fetch - 需要手动解析
fetch('/api/data')
  .then(response => response.json())
  .then(data => {
    console.log(data);
  });
```

#### 错误处理
```js
// axios - 自动处理 HTTP 错误状态
axios.get('/api/data')
  .then(response => {
    console.log(response.data);
  })
  .catch(error => {
    // 自动捕获 4xx, 5xx 错误
    console.log(error);
  });

// fetch - 需要手动检查状态
fetch('/api/data')
  .then(response => {
    if (!response.ok) {
      throw new Error('HTTP error');
    }
    return response.json();
  })
  .catch(error => {
    console.log(error);
  });
```

#### 请求超时

Axios 的响应超时设置是非常简单的，直接设置 `timeout` 参数即可。而 fetch 则需要手动实现，使用 `AbortController` 来取消请求。

```js
// axios - 内置支持
axios.get('/api/data', {
  timeout: 5000
});

// fetch - 需要手动实现
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 5000);

fetch('/api/data', {
  signal: controller.signal
}).finally(() => clearTimeout(timeoutId));
```

#### 请求拦截器
```js
// axios - 内置支持
axios.interceptors.request.use(config => {
  config.headers.Authorization = `Bearer ${token}`;
  return config;
});

// fetch - 需要手动封装
const fetchWithAuth = (url, options = {}) => {
  return fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      'Authorization': `Bearer ${token}`
    }
  });
};
```

#### 请求取消
```js
// axios - 内置支持
const source = axios.CancelToken.source();
axios.get('/api/data', {
  cancelToken: source.token
});
source.cancel('Operation canceled');

// fetch - 使用 AbortController
const controller = new AbortController();
fetch('/api/data', {
  signal: controller.signal
});
controller.abort();
```

#### 并发请求
```js
// axios - 内置支持
axios.all([
  axios.get('/api/user'),
  axios.get('/api/posts')
]).then(axios.spread((user, posts) => {
  console.log(user.data, posts.data);
}));

// fetch - 使用 Promise.all
Promise.all([
  fetch('/api/user').then(res => res.json()),
  fetch('/api/posts').then(res => res.json())
]).then(([user, posts]) => {
  console.log(user, posts);
});
```

### 使用场景建议

**选择 axios 的情况：**
- 需要更好的错误处理
- 需要请求/响应拦截器
- 需要自动 JSON 解析
- 需要更好的浏览器兼容性
- 项目已经使用了 axios

**选择 fetch 的情况：**
- 不想引入额外依赖
- 只需要简单的 HTTP 请求
- 现代浏览器环境
- 对包大小敏感的项目

### 延展

**技术发展历程：**

`XMLHttpRequest`是最早的浏览器异步请求API，于2000年左右由微软引入，后来成为Web标准。它使用回调函数处理异步操作。

`Ajax`是`Asynchronous JavaScript and XML`的缩写，是一种基于`XMLHttpRequest`的Web开发技术，允许在不刷新整个页面的情况下与服务器进行异步数据交换。

`Axios`是一个第三方HTTP客户端库，提供了基于Promise的API。在浏览器环境中基于`XMLHttpRequest`实现，在Node.js环境中基于Node.js的`http`模块实现。

`Fetch`是现代浏览器原生提供的Web API，于2015年左右推出，原生支持Promise，提供了更简洁现代的异步请求方式，逐步替代`XMLHttpRequest`。


## promise题目

### 题目1

```js
const p1 = Promise.resolve(1)
const p2 = Promise.resolve(p1)
console.log(p1 === p2)
```


**输出结果**

```text
true
```


**解析**
这道题的核心考点是`Promise.resolve`的幂等性。当传入Promise对象时，它会原样返回而不是包装成新的Promise对象。

### 题目2

```js
const p1 = Promise.resolve(1)
const p2 = new Promise((resolve) => resolve(p1))
console.log(p1 === p2)
```

**输出结果**

```text
false
```

**解析**

这道题的核心考点是`new Promise`构造函数总是会创建一个新的Promise对象。


### 题目3

```js
const p1 = Promise.resolve(1)
const p2 = new Promise((resolve) => resolve(p1))
// 输出的状态
console.log(p1)
console.log(p2)
```

**输出结果**
```text
fulfilled
pending
```

### 题目4
```js
const p1 = Promise.resolve(1)
const p2 = Promise.resolve(2).then(() => p1)
p2.then(() => {
  console.log(1)
})
  .then(() => {
    console.log(2)
  })
  .then(() => {
    console.log(3)
  })
p1.then(() => {
  console.log(4)
})
  .then(() => {
    console.log(5)
  })
  .then(() => {
    console.log(6)
  })
```

### 题目5
```js
function delay(duration = 0) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration)
  })
}

delay().then(() => {
  console.log(1)
  Promise.resolve().then(() => {
    console.log(2)
  })
})

Promise.resolve()
  .then(delay)
  .then(() => {
    console.log(3)
  })
console.log(4)
```

**输出结果**

```text
4
1
2
3
```
