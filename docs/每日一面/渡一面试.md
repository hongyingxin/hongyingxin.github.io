# 渡一面试

## 拼多多 promise面试题

```js
const p1 = new Promise((resolve, reject) => {
  reject('error');
  resolve('success');
})

p1.then((res1) => {
  console.log(res1);
}).then((res2) => {
  console.log(res2);
}).catch((err) => {
  console.log(err);
}).then((res3) => {
  console.log(res3);
})

const p2 = new Promise((resolve, reject) => {
  reject(new Error('error'));
})

p2.catch((err) => {
  console.log(err);
})

p2.catch((err) => {
  console.log(err);
})
```

**输出结果**

```text
error
undefined  
Error: error
Error: error
```

**解析**

p1的执行：

- p1创建时：执行器函数立即执行，调用reject('error')，Promise状态变为rejected
- resolve('success')不会执行：因为Promise状态一旦确定就不可改变

p1的链式调用：

- 第一个then不执行：因为p1是rejected状态
- 第二个then不执行：因为前面的then没有执行
- catch执行：捕获到rejection，输出'error'，并且catch返回一个resolved的Promise（值为undefined）
- 最后的then执行：因为catch返回了resolved状态的Promise，输出undefined

p2的执行：

- p2创建：立即reject一个Error对象
- 第一个catch执行：输出Error对象
- 第二个catch执行：同样捕获到相同的rejection，输出Error对象

## instanceof 实现

### 原理解析

`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

**核心原理**：沿着对象的原型链向上查找，看是否能找到构造函数的 `prototype`。

### 手写实现

```js
function myInstanceof(left, right) {
  // 获取对象的原型
  let proto = Object.getPrototypeOf(left); 
  // 获取构造函数的 prototype
  let prototype = right.prototype;
  // 沿着原型链向上查找
  while (proto) {
    if (proto === prototype) {
      return true;
    }
    proto = Object.getPrototypeOf(proto);
  }
  return false;
}
```

### 关键知识点

1. **原型链机制**：每个对象都有一个指向其原型的内部链接
2. **Object.getPrototypeOf()**：获取对象的原型，等同于访问 `__proto__`
3. **基本类型处理**：基本数据类型没有原型链，直接返回 false
4. **循环终止条件**：当 proto 为 null 时停止（到达原型链顶端）

## CommonJS

```js
this.a = 1
exports.b = 2
exports = {
  c: 3
}
module.exports = {
  d: 4
}
exports.e = 5
this.f = 6
```