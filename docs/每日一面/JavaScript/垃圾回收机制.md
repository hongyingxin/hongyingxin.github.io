# # JavaScript 进阶 - 垃圾回收机制

## 简介

JavaScript 是在创建变量（对象、字符串等）时自动进行内存分配，并且在不使用它们时“自动”释放。释放的过程称为垃圾回收。

## 内存生命周期

1. 分配你所需要的内容
2. 使用分配到的内容（读、写）
3. 不需要时，释放内存

```js
const n = 123; // 为数值分配内存
const s = "azerty"; // 为字符串分配内存

const o = {
  a: 1,
  b: null,
}; // 为对象及其包含的值分配内存

// 为数组及其包含的值分配内存（就像对象一样）
const a = [1, null, "abra"];

function f(a) {
  return a + 2;
} // 为函数（可调用的对象）分配内存
```

## 引用

垃圾回收算法依赖的主要概念是引用。在内存管理的上下文中，如果一个对象有访问另一个对象的权限（隐式或者显式），称作前面的对象引用后面的对象。例如，一个 JavaScript 对象具有对它的原型的引用（隐式引用）和对它属性的引用（显式引用）。

## 引用计数垃圾回收

引用计算垃圾回收是最初级的垃圾回收算法，此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

当一个对象被引用时，它的引用计数会增加；当一个对象不再被引用时，它的引用计数会减少。当引用计数为 0 时，表示该对象不再被引用，JavaScript 引擎会将其回收。

```js
let x = {
  a: {
    b: 2,
  },
};
// 创建了两个对象。一个作为另一个的属性被引用。
// 另一个被赋值给变量‘x’。
// 很显然，没有可以被垃圾回收的对象。
let y = x;
// 变量‘y’是第二个拥有对象引用的变量。
x = 1;
// 现在，起初在‘x’中的对象有唯一的引用，就是变量‘y’。
let z = y.a;
// 引用对象的‘a’属性。
// 现在，这个对象有两个引用，一个作为属性，
// 另一个作为变量‘z’。
y = "mozilla";
// 起初在‘x’中的对象现在是零引用了。它可以被垃圾回收了。
// 但是，它的属性‘a’仍被变量‘z’引用，所以这个对象还不能回收。
z = null;
// 起初在 x 中的对象的属性‘a’是零引用了。这个对象可以被垃圾回收了。
```

循环引用是引用计数垃圾回收算法的一个问题，是导致内存泄漏的常见原因。

```js
// 创建了两个对象，一个对象的属性引用另一个对象，形成了一个循环
function f() {
  const x = {};
  const y = {};
  x.a = y; // x 引用 y
  y.a = x; // y 引用 x
  return;
}

f();
```

## 标记清除算法

标记清除算法是现代浏览器中常用的垃圾回收算法。这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。

从根对象（window全局）开始查找所有引用的对象，并标记为“使用中”，没有标记为使用中的对象就是垃圾对象。

现代 JavaScript 引擎（如 V8、SpiderMonkey）通常使用标记-清除算法进行垃圾回收。它通过从根对象开始遍历所有对象，标记所有可以访问到的对象，然后清除未标记的对象。这样，所有无法被访问到的对象都会被回收。

这种算法很好解决了循环引用的问题，循环引用的对象也可能是垃圾对象。不过这种算法会导致那些无法从根对象查询到的对象都将被清除。


## 内存泄漏

内存泄漏是指程序中已经不再需要使用的内存，却没有被释放的情况。在 JavaScript 中，常见的内存泄漏包括未被清除的定时器、未被移除的事件监听器、闭包中的变量等。