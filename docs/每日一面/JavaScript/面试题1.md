# JavaScript 面试题1

## 1. 以下代码输出什么？解释原因。

```javascript
const obj = {
  objName: "百度",
  print: () => console.log(this.objName),
};
```

<details>
<summary>点查看答案</summary>

**答案：**

```javascript
undefined
```

**解析：** 

1. 箭头函数的特性

- 箭头函数没有自己的`this`，它会继承定义时所在作用域的`this`
- `print`是用箭头函数定义的，所以它的`this`不是`obj`，而是定义它时所在的环境

2. 当前环境的this

- 这里箭头函数定义在全局作用域，所以它的`this`指向全局对象
- 严格模式下，顶层的`this`是`undefined`
- 非严格模式下，顶层的`this`是`window`（浏览器中）或者`global`（Node.js中）

3. 如何修改达到预期

将`print`改成普通函数，这样它的`this`就指向`obj`

```js
print: function() {
  console.log(this.objName);
}
```

</details>

## 2. trt..catch 可以捕获到异步代码中的错误吗

<details>
<summary>点查看答案</summary>

**答案：**

不能

**解析：**

这道题考察Javascript异步机制和错误处理的理解。以下面代码为例：

```js
try {
  setTimeout(() => {
    throw new Error('error');
  }, 1000);
} catch (error) {
  console.log(error);
}
```

setTimeout是一个异步函数，它的回调函数会在指定的延时后被放入事件队列，等待当前执行栈清空后才执行。因此，当setTimeout的回调函数执行并抛出错误时，try...catch已经执行完毕，无法捕捉到异步回调中的错误。

想要捕获异步代码的错误，应该：

1. 在异步回调内部使用try-catch
2. 使用Promise的catch方法
3. 使用async/await配置try-catch
4. 使用全局错误处理器（如 process.on('uncaughtException')）

</details>

## 3. 以下代码输出什么？解释原因。

```js
foo(typeof a);
function foo(p) {
  console.log(this);
  console.log(p);
  console.log(typeof b);
  let b = 0;
}
```

<details>
<summary>点查看答案</summary>

**答案：**

```javascript
window
undefined
before initialization
```

**解析：**

这段代码涉及了几个知识点：变量提升、`typeof`运算符特性、函数作用域内的`let`声明的暂时性死区、函数调用中的`this`指向。

**运行步骤：**

1. 函数`foo`被函数声明提升，因此在调用`foo(...)`时已可用
2. `typeof a`中的`a`未定义，但`typeof`操作符在访问未声明变量时不会跑错，而是返回`undefined`，所以`a`值为`undefined`，传入`foo(...)`的参数`p`为`undefined`
3. `console.log(this)`在非严格模式下，`this`指向全局对象`window`，所以输出`window`，开启严格模式后，`this`指向`undefined`
4. `console.log(p)`输出`undefined`
5. `console.log(typeof b)`中的`b`被`let`声明，存在暂时性死区，在声明前访问会报错，所以输出`before initialization`

</details>

## 4. 说说下面代码的输出结果

```js
Promise.resolve().then(() => {
  console.log(0)
  return Promise.resolve(4)
}).then((res) => {
  console.log(res)
})

Promise.resolve().then(() => {
  console.log(1)
}).then(() => {
  console.log(2)
}).then(() => {
  console.log(3)
}).then(() => {
  console.log(5)
}).then(() =>{
  console.log(6)
})
```

<details>
<summary>点查看答案</summary>

**答案：**

```javascript
0
1
2
3
4
5
6
``` 

暂时还不懂。
</details>

## 5. 如何让 Proxy 去监听基本数据类型

<details>
<summary>点查看答案</summary>

**答案：**

Proxy无法直接监听基本数据类型，因为它们是不可变的。Proxy只能在对象级别上进行操作。

当我们尝试使用 Proxy 包装基本数据类型时，会得到一个 TypeError 错误。因为基本数据类型不具备属性和方法。

```js
const value = 'Hello';
const handler = {
  set(target, property, value) {
    console.log(`Setting property '${property}' to '${value}'`);
    target[property] = value;
    return true;
  }
};
const proxyValue = new Proxy(value, handler); // TypeError: Cannot create proxy with a non-object as target
```

我们可以通过将基本数据类型包装成对象来监听它们。

```js

const value = 'hello'
function ValueWrapper(value) {
  this.value = value
}
const wrapper = new ValueWrapper(value)
const handler = {
  set(target, property, value) {
    console.log(`Setting property ${property} to ${value}`);
    target[property] = value;
    return true;
  },
}
const proxyValue = new Proxy(wrapper, handler)
console.log('proxyValue.name',proxyValue.value)
proxyValue.value = 'Jane'
console.log('proxyValue.name1',proxyValue.value)
```
</details>

## 6. Proxy 能够监听到对象中的对象的引用吗？

<details>
<summary>点查看答案</summary>

**答案：**

Proxy默认只能拦截对象第一层的操作，对于嵌套对象的属性修改无法直接拦截。

```js
const obj = {
  nestedObj: {
    foo: 'bar'
  }
}

const handler = {
  get(target, prop, receiver) {
    const value = Reflect.get(target, prop, receiver)
    if (typeof value === 'object' && value !== null) {
      return new Proxy(value, handler)  // 返回 Proxy 包装的对象
    }
    return value  // 返回原始值（字符串、数字等）
  },
  set(target, prop, value) {  
    target[prop] = value
    return true
  }
}

const proxyObj = new Proxy(obj, handler)
proxyObj.nestedObj.foo = 'baz'

const textObb = {
  name: 'John',
}
const textProxy = new Proxy(textObb, handler)
textProxy.name = 'Jane'
```

- 我们可以通过递归创建Proxy来实现对嵌套对象的属性修改的拦截
- 当 `proxyObj.nestedObj.foo = 'baz'` 执行时
- JavaScript引擎会把这个操作分解成两步，第一步获取 nestedObj 对象，第二步设置 foo 属性
即`const temp = proxyObj.nestedObj` ，然后 `temp.foo = 'baz'`
- 注意的一点：这里`Reflect.get`的作用是获取对象属性的原始值，它返回的是原始值，而不是Proxy包装的对象

</details>

## 7. 如果空数组调用reduce会发生什么？

<details>
<summary>点查看答案</summary>

**答案：**

这里分两种情况，
1. 一种是没有提供初始化参数，则会抛出一个TypeError错误。这是因为在空数组上调用reduce()方法时，无法得到初始累积值；
```js
const emptyArray = [];
const result = emptyArray.reduce((accumulator, currentValue) => accumulator + currentValue);
// TypeError: Reduce of empty array with no initial value
```
2. 一种是指定了初始化参数，则会返回初始化参数。这是因为在空数组上调用reduce()方法时，会返回初始化参数。
```js
const emptyArray = [];
const initialValue = 0;
const result = emptyArray.reduce((accumulator, currentValue) => accumulator + currentValue, initialValue);

console.log(result); // 输出: 0
```

</details>

## 8. 改变this指向的方法有哪些？

<details>
<summary>点查看答案</summary>

**答案：**

1. call()、bind()、apply()

</details>

## 9. 是否有使用过空值合并运算符（??），举几个可以使用的场景。

<details>
<summary>点查看答案</summary>

**答案：**

空值合并操作符（??）是一个逻辑操作符，当左侧的操作数为null或undefined时，返回右侧的操作数，否则返回左侧的操作数。
```js
const a = null ?? 'default';
console.log(a); // 输出: default

const b = 0 ?? 'default';
console.log(b); // 输出: 0

const c = 'hello' ?? 'default';
console.log(c); // 输出: hello
```

**场景的操作符**

1. 可选链操作符（?.）

作用：安全访问可能为 undefined 或 null 的属性

场景：避免访问不存在的对象属性时抛出错误

```js
const user = {
  name: 'John',
  address: {
    city: 'New York'
  }
}

const city = user.address?.city ?? 'Unknown';
console.log(city); // 输出: New York
```

2. 逻辑与操作符（&&）

作用：进行短路求值，避免访问 undefined 属性

场景：当左侧为假值时，直接返回左侧值；否则返回右侧值

```js
const user = {
  name: 'John',
  address: {
    city: 'New York'
  }
}

const city = user.address && user.address.city ?? 'Unknown';
console.log(city); // 输出: New York
```

3. 逻辑或操作符（||）

作用：提供默认值，当左侧为假值时返回右侧值

与 ?? 的区别：|| 对所有假值生效（0、''、false 等），而 ?? 只对 null 和 undefined 生效
场景：提供默认值，当左侧为假值时返回右侧值
```js
const user = {
  name: 'John',
  address: {
    city: 'New York'
  }
}

const city = user.address || user.address.city ?? 'Unknown';
console.log(city); // 输出: New York
```

4. 双重否定操作符（!!）

作用：将任何值转换为 boolean 类型

使用场景：强制类型转换为布尔值

```js
const value = 'hello';
const result = !!value;
console.log(result); // 输出: true
```

5. 三元操作符（?:）

作用：条件表达式，根据条件返回不同的值

使用场景：简洁的条件判断和赋值

```js
const value = 'hello';
const result = value ? 'yes' : 'no';
console.log(result); // 输出: yes
```

6. 逻辑赋值操作符

- ||=：逻辑或赋值（当左侧为假值时才赋值）
```js
const value = 'hello';
value ||= 'world';
console.log(value); // 输出: hello
```
- &&=：逻辑与赋值（当左侧为真值时才赋值）
```js
const value = 'hello';
value &&= 'world';
console.log(value); // 输出: hello
```
- ??=：空值合并赋值（当左侧为 null 或 undefined 时才赋值）
```js
const value = 'hello';
value ??= 'world';
console.log(value); // 输出: hello
```
</details>

## 10. 运行以上代码，输出结果为：

```js
function Foo(){
  Foo.a = function(){
      console.log(1);
  }
  this.a = function(){
      console.log(2)
  }
}

Foo.prototype.a = function(){
  console.log(3);
}

Foo.a = function(){
  console.log(4);
}

Foo.a();
let obj = new Foo();
obj.a();
Foo.a(); 
```

<details>
<summary>点查看答案</summary>

**答案：**

```javascript
4
2
1
```
**执行流程：**
1. 首先调用Foo.a()方法，输出4。Foo.a()是一个静态方法，直接在函数对象上定义
2. 然后创建了一个Foo类型的实例obj，调用obj.a()方法，输出2。this.a是一个实例方法，会覆盖原型上的方法
3. 最后再次调用Foo.a()方法，输出1。虽然在上面已经定义了一个静态方法Foo.ax，但是在构建函数Foo中又重新定义了一个同名属性，导致静态方法被覆盖了。

**关键知识点：**
1. 静态方法 vs 实例方法
    - Foo.a 是静态方法，属于函数对象本身
    - obj.a 是实例方法，属于实例对象
2. 属性查找链
    - 实例自身属性（通过 this.a 定义）
    - 原型属性（通过 Foo.prototype.a 定义）
    - 实例方法优先级高于原型方法
3. 构造函数的副作用
    - 构造函数内部可以修改函数对象的静态属性
    - 每次 new Foo() 都会执行这个修改
</details>

## 11. 运行以上代码，输出结果为：

```js
const obj = {
 fn1: () => console.log(this),
 fn2: function() {console.log(this)}
}

obj.fn1();
obj.fn2();

const x = new obj.fn1();
const y = new obj.fn2();
```

<details>
<summary>点查看答案</summary>

**答案：**

```js
Window
{fn1, fn2}
obj.fn1 is not a constructor
```

- 箭头函数没有自己的`this`值，因为`fn1`中的this指向是全局对象window，所以输出Window
- `fn2`中的this指向是`obj`对象，所以输出`{fn1, fn2}`
- `new obj.fn1()`会报错，因为`fn1`是一个箭头函数，不能作为构造函数使用
- `new obj.fn2()`会创建一个新对象，因为`fn2`是一个普通函数，所以输出`{fn1, fn2}`，但因为上面执行报错，所以并不会执行。

</details>

## 12. 浏览器有几种缓存，它们的优先级什么样？

<details>
<summary>点查看答案</summary>

**答案：**

浏览器缓存主要分为两种：

1. 强缓存（Strong Cache）：通过Expires或Cache-Control控制，浏览器直接从本地缓存读取，不发送请求到服务器
2. 协商缓存（Negotiation Cache）：通过ETag或Last-Modified控制，浏览器发送条件请求到服务器验证缓存是否有效
3. Service Worker：通过Service Worker缓存，浏览器直接从本地缓存读取，不发送请求到服务器
4. Web Storage：包括localStorage和sessionStorage，浏览器直接从本地缓存读取，不发送请求到服务器

优先级：Service Worker > 强缓存 > 协商缓存 > Web Storage
</details>

## 13. Web Worker是什么

<details>
<summary>点查看答案</summary>

**答案：**

Web Worker是 HTML5 标准中提供的一项技术，它可以让 JavaScript 在后台运行，从而避免阻塞 UI 线程。

Web Worker 有以下几个特点：
1. 独立线程
2. 沙箱环境
3. 事件通信

</details>

## 14. Promise的 finally 怎么实现的？

<details>
<summary>点查看答案</summary>

**答案：**

Promise的finally方法是ES2018(ES9)引入的，它会在Promise结束时（无论成功还是失败）都会执行回调函数。

**基本实现原理：**

```javascript
Promise.prototype.finally = function(callback) {
  // 获取Promise构造函数
  const P = this.constructor;
  // 返回一个新的Promise
  return this.then(
    // 成功时
    value => P.resolve(callback()).then(() => value),
    // 失败时  
    reason => P.resolve(callback()).then(() => { throw reason })
  );
};
```

**实现要点：**

1. **无论成功失败都执行**：finally回调在Promise settled（已敲定）时都会执行
2. **不改变原Promise的值**：finally不会修改Promise的结果值或拒绝原因
3. **支持异步回调**：如果callback返回Promise，会等待其完成
4. **错误传播**：如果callback抛出错误，会替换原来的结果
</details>

## 15. Promise then的第二个参数和catch的区别

<details>
<summary>点查看答案</summary>

**答案：**

`Promise`的`then`方法和`catch`方法都是用于处理Promise的rejected的情况。它们的区别在于：
1. `then`方法的第二个参数

如果`Promise`的状态为rejected，`then`方法的第二个参数会被调用。该参数是一个函数，可以接受一个参数，即Promise返回的错误信息。
```js
function asyncFunction() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(new Error('Something went wrong'));
    }, 1000);
  });
}

asyncFunction()
  .then(
    result => console.log(result), 
    error => console.error(error)
  );
// 在上述代码中，当 Promise 被 reject 时，then 方法的第二个参数会被调用，并打印出错误信息。
```

2. `catch`方法

`catch` 方法相当于 `then` 方法的第二个参数，也是用于处理 `Promise` 的 rejected 状态的情况。不同之处在于，`catch` 方法可以链式调用，而不需要在每次调用 `then` 方法时都传递第二个参数。
```js
function asyncFunction() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(new Error('Something went wrong'));
    }, 1000);
  });
}

asyncFunction()
  .then(result => console.log(result))
  .catch(error => console.error(error));
// 在上述代码中，当 Promise 被 reject 时，catch 方法会被调用，并打印出错误信息。
```

因此，then 方法的第二个参数和 catch 方法都是用于处理 Promise 的 rejected 状态的情况，但前者需要在每次调用 then 方法时都传递第二个参数，而后者则可以链式调用。
</details>

## 16. 以下代码输出什么？

```js
var name = '123';

var obj = {
 name: '456',
 print: function() {
  function a() {
    console.log(this.name);
  }
  a();
 }
}

obj.print();
```

<details>
<summary>点查看答案</summary>

**答案：**

```javascript
123
```

**解析：**

1. 在全局作用域声明了变量name，值为'123'
2. 声明一个对象obj，包含属性name和方法print，name属性的值为'456'，print方法的值为一个函数a
3. 当执行obj.print()时，会调用print方法，并在其中定义了函数a
4. 函数a中调用console.log(this.name)，由于this指向的是全局对象，所以输出'123'


**演变**
```js
var name = '123';

var obj = {
 name: '456',
 print: function() {
  const a = () => {
    console.log(this.name);
  }
  a();
 }
}

obj.print();
```
如果想正确输出结果，可以使用箭头函数来定义a函数，这样a函数中的this就指向obj对象。

</details>

## 17. 以下代码输出什么？

```js
console.log(typeof typeof typeof null);
console.log(typeof console.log(1));
```

<details>
<summary>点查看答案</summary>

**答案：**

```javascript
"string"
1
"undefined"
```

**解析：**

1. `typeof typeof typeof null`

- `typeof null` 返回 `"object"`
- `typeof "object"` 返回 `"string"`
- `typeof "string"` 返回 `"string"`

因此最终结果为`string`

2. `typeof console.log(1)`

- `console.log(1)` 输出 `1`
- `console.log(1)`没有返回值，因此返回`undefined`
- `typeof "undefined"` 返回 `undefined`

因此最终结果为`string -> 1 -> undefined`

</details>

## 18. async/await、generator、promise 的区别和关联

<details>
<summary>点查看答案</summary>

**答案：**

promise与async/await函数都是用来解决JavaScript中的异步问题，从回调函数，到Promise处理异步，到Generator处理异步，再到Async/await处理异步，它们都是为了解决回调地狱问题，让异步代码看起来更像同步代码，从而提高代码的可读性和可维护性。

**关联**

- async/await：是建立在Generator函数的语法糖，可以更方便地实现异步编程。async函数返回一个Promise对象，await表达式会阻塞代码执行，直到Promise对象状态变为resolved。

- promise：是一种异步编程模型，可以将回调函数嵌套的代码转换为链式调用。

- generator：是一种迭代器，可以通过yield表达式暂停代码执行，并通过next()方法恢复执行。

**区别**

- async/await：是 ES7 引入的新特性，可以让异步编程看起来像同步编程，更加易读易写。async/await 只能用于函数内部，不能用于顶层代码（例如全局作用域）。

- Promise：是 ES6 引入的新特性，使用 then() 方法和 catch() 方法注册回调函数，实现异步编程。Promise 可以使用 race() 方法和 all() 方法处理多个异步操作。

- Generator：是 ES6 引入的新特性，可以通过 yield 表达式暂停和恢复代码执行，实现异步流程控制。Generator 需要手动执行 next() 方法，才能继续执行下一步操作。

</details>

## 19. 说说对 requestIdleCallback 的理解

<details>
<summary>点查看答案</summary>

**答案：**

`requestIdleCallback`是一个浏览器 API，它允许我们在浏览器空闲时执行一些任务，以提高网页的性能和响应速度。

通常情况下，JavaScript 代码会占用主线程，从而阻塞了其他的任务。当页面需要进行一些复杂计算、渲染大量的DOM元素等操作时，就会导致用户的交互体验变得缓慢和卡顿。

`requestIdleCallback` 的作用就是将一些非关键性的任务从主线程中分离出来，等到浏览器闲置时再执行。这样就可以避免占用主线程，提高页面的响应速度和流畅度。

使用 `requestIdleCallback` 需要传入一个回调函数，该函数会在浏览器空闲时被调用。回调函数的参数是一个 `IdleDeadline` 对象，它包含有关浏览器还剩余多少时间可供执行任务的信息。根据该对象的时间戳信息，开发人员可以自行决定是否继续执行任务或推迟执行。

`requestIdleCallback` 可以帮助我们优化 Web 应用程序的性能和响应速度，减少资源的浪费。

### 延展

`requestAnimationFrame` 在重新渲染屏幕之前执行，适合用来做动画；而 `requestIdleCallback` 在渲染屏幕之后执行，并且是否有空执行要看浏览器的调度，或者使用 `timeout` 参数。

</details>

## 20. 页面加载的过程中，JS 文件是不是一定会阻塞 DOM 和 CSSOM 的构建？

<details>
<summary>点查看答案</summary>

**答案：**

不一定

**解析：**

JavaScript阻塞DOM和CSSOM的构建的情况主要集中在以下两个方面：

- JavaScript文件被放置在head标签内部
当JavaScript文件被放置在head标签内部时，浏览器会先加载JavaScript文件并执行它，然后才会继续解析HTML文档。因此，如果JavaScript文件过大或服务器响应时间过长，就会导致页面一直处于等待状态，进而影响DOM和CSSOM的构建。

- JavaScript代码修改了DOM结构
在JavaScript代码执行时，如果对DOM结构进行了修改，那么浏览器需要重新计算布局（reflow）和重绘（repaint），这个过程会较为耗时，并且会阻塞DOM和CSSOM的构建。

除此之外，还有一些情况下JavaScript并不会阻塞DOM和CSSOM的构建：

- 通过设置 script 标签的 async 、defer 属性避免阻塞DOM和CSSOM的构建
  - async：异步加载JavaScript文件，脚本的下载和执行将与其他工作同时进行（例如从服务器请求其他资源、渲染页面等），而不必等到脚本下载完成才开始这些操作。因此，在使用 async 属性时，脚本的加载和执行是异步的，并且不保证脚本在页面中的顺序。
  - defer属性 ：属性也告诉浏览器立即下载脚本文件，但有一个重要的区别：当文档解析时，脚本不会执行，直到文档解析完成后才执行。这意味着脚本将按照它们在页面上出现的顺序执行，并且在执行之前，整个文档已经被解析完毕了。
- Web Workers ：Web Workers 是一种运行在后台线程的JavaScript脚本，它不会阻塞DOM和CSSOM的构建，并且可以利用多核CPU提高JavaScript代码执行速度。

</details>

## 21. 说说你对轮询的理解

<details>
<summary>点查看答案</summary>

**答案：**

轮询是一种常见的网络通信技术，它通过定期发送请求来检测服务器的状态，从而实现实时更新。

轮询可以分为两种：短轮询和长轮询

- 短轮询：客户端每隔固定的时间发送请求，服务器收到后无论数据是否有更新都立即返回响应。这种方式的缺点是浪费带宽。
- 长轮询：是对短轮询的改进（早起的Web聊天应用），客户端发送请求后服务器不会立即响应，而是将连接挂起，直到有新数据产生或超时。客户端处理完响应后，立即发起下一次请求。这种方式优点是比短轮询实时并减少了无意义的往返，但服务器需要维护大量挂起的连接，比较耗费资源。

前端轮询的实现方式主要有两种：
- 使用`setTimeout`定时器（这里不使用`setInterval`是确保上一个请求结束后再开始下一次避免请求堆积）
- 使用递归

**轮询 vs SSE vs WebSocket**

| 方案 | 通信方式 | 实时性 | 服务器压力 | 复杂度 |
|------|----------|--------|------------|--------|
| 短轮询 | 双向 (客户端驱动) | 低 | 很大 (频繁请求) | 极低 |
| 长轮询 | 双向 (客户端驱动) | 中 | 较大 (挂起连接) | 低 |
| SSE | 单向 (服务端推送) | 高 | 较小 | 中 |
| WebSocket | 双向 (全双工) | 极高 | 小 (长连接) | 较高 |

</details>

## 22. JavaScript函数有哪几种声明方式？有什么区别？

<details>
<summary>点查看答案</summary>

**答案：**

JavaScript函数有以下几种声明方式：

- 函数声明

函数的声明式写法为：`function test(){}`，这种写法会导致函数提升，所有通过`function`关键字声明的变量都会被解释器优先编译，不管声明在什么位置都可以调用它，但是它本身并不会被执行。

```js
test(); // 测试
function test() {
  console.log("测试");
}
test(); // 测试
```

- 函数表达式

函数的表达式写法为：`var test = function(){}`，这种写法不会导致函数提升，必须先声明后调用，不然就会报错。

```js
test(); // 报错：TypeError: test is not a function
var test = function() {
  console.log("测试");
};
```

- 箭头函数

ES6 引入的最常用的现代声明方式。

```js
const test = () => {
  console.log("测试");
};
test(); // 测试
```

- 函数构造函数

函数构造函数写法为：`new Function('return "测试"')`，这种写法不常用，因为性能较差，而且容易造成代码混乱。
</details>

## 23. 说说你对“立即执行函数”的理解

<details>
<summary>点查看答案</summary>

**答案：**

立即执行函数（IIFE）是一种语法，是一个在定义之后立即被执行的匿名函数。

**语法结构**

典型的 IIFE 由两部分组成：第一部分是包围在圆括号中的匿名函数，第二部分是紧跟其后的圆括号（用于调用该函数）。

```js
(function() {
  const message = "Hello, IIFE!";
  console.log(message);
})();
```

除了最常见的写法，你可能还会看到这些变种：

- 叹号/运算符开头： `!function(){ ... }()`; 这里的 ! 会告诉解析器这后面是一个表达式，而不是声明。`()，！，+，-，=`等运算符都能起到立即执行的作用，这些运算符的作用就是将匿名函数或函数声明转换为函数表达式。


- 传参写法： `(function(window, $) { ... })(window, jQuery);` 这种写法可以缩短查找全局变量的作用域链，同时方便压缩代码。

**作用**

- 创建私有作用域（避免变量污染全局作用域）
在`let`、`const`出现之前，JavaScript只有全局作用域和函数作用域。
- 模块化开发
在`CommonJS`、`AMD`、`CMD`等模块化规范出现之前，JavaScript没有模块化开发的概念。
- 解决闭包中的循环问题
在闭包中，如果需要访问外部变量，需要将外部变量作为参数传递给内部函数。

**延展**

立即执行函数是闭包最典型的应用场景之一。

闭包是指一个函数可以记得并访问它定义时所在的词法作用域，即使该函数是在当前作用域之外执行。

闭包的三个核心条件：
- 函数嵌套
- 内部函数引用外部变量
- 外部阴影
</details>

## 24. 相比于npm和yarn，pnpm的优势是什么？

<details>
<summary>点查看答案</summary>

**答案：**

pnpm对比npm/yarn的优点：

- 更快速的依赖下载
- 更高效的利用磁盘空间
- 更优秀的依赖管理

### 包管理工具的发展历史

**npm2**

用node版本管理工具把node版本降到4，那npm版本就是2.x了。npm2存在的问题就是node_modules是嵌套的，如`node_modules/express/node_modules`。同样的依赖复制很多次，占据比较大的磁盘空间。而且window的文件路径最长是260多个字符，嵌套是会超过window路径的长度限制。

**yarn**

yarn通过铺平解决npm依赖重复的问题。后面的npm3也采用这种方案。

但还存在最主要的一个问题是幽灵依赖，也就是你明明没有声明在 `dependencies` 里的依赖，但在代码里却可以 `require` 进来。即幽灵依赖的问题。

**pnpm**

pnpm就是为了解决幽灵依赖的问题而诞生的。

回想下 npm3 和 yarn 为什么要做 node_modules 扁平化？不就是因为同样的依赖会复制多次，并且路径过长在 windows 下有问题么？

那如果不复制呢，比如通过 link。

首先介绍下 link，也就是软硬连接，这是操作系统提供的机制，硬连接就是同一个文件的不同引用，而软链接是新建一个文件，文件内容指向另一个路径。当然，这俩链接使用起来是差不多的。

如果不复制文件，只在全局仓库保存一份 npm 包的内容，其余的地方都 link 过去呢？

这样不会有复制多次的磁盘空间浪费，而且也不会有路径过长的问题。因为路径过长的限制本质上是不能有太深的目录层级，现在都是各个位置的目录的 link，并不是同一个目录，所以也不会有长度限制。

没错，pnpm 就是通过这种思路来实现的。

### 总结

npm2 是通过嵌套的方式管理 node_modules 的，会有同样的依赖复制多次的问题。

npm3+ 和 yarn 是通过铺平的扁平化的方式来管理 node_modules，解决了嵌套方式的部分问题，但是引入了幽灵依赖的问题，并且同名的包只会提升一个版本的，其余的版本依然会复制多次。

pnpm 则是用了另一种方式，不再是复制了，而是都从全局 store 硬连接到 node_modules/.pnpm，然后之间通过软链接来组织依赖关系。

这样不但节省磁盘空间，也没有幽灵依赖问题，安装速度还快，从机制上来说完胜 npm 和 yarn。

</details>


## 25. 如何判断页面是通过PC端还是移动端访问？

<details>
<summary>点查看答案</summary>

**答案：**

1. navigator.userAgent
最简单的方法就是分析浏览器的 user agent 字符串，它包含了设备信息。

JS 通过navigator.userAgent属性拿到这个字符串，只要里面包含mobi、android、iphone等关键字，就可以认定是移动设备。

这种方法的优点是简单方便，缺点是不可靠，因为用户可以修改这个字符串，让手机浏览器伪装成桌面浏览器。

2. window.screen，window.innerWidth

另一种方法是通过屏幕宽度，判断是否为手机。

window.screen对象返回用户设备的屏幕信息，该对象的width属性是屏幕宽度（单位为像素）。只要屏幕宽度小于768px，就可以认定是移动设备。这个方法的缺点在于，如果手机横屏使用，就识别不了。

window.innerWidth返回浏览器窗口里面的网页可见部分的宽度，比较适合指定网页在不同宽度下的样式。

3. window.orientation

第三种方法是侦测屏幕方向，手机屏幕可以随时改变方向（横屏或竖屏），桌面设备做不到。

window.orientation属性用于获取屏幕的当前方向，只有移动设备才有这个属性，桌面设备会返回undefined。

4. touch 事件

第四种方法是，手机浏览器的 DOM 元素可以通过ontouchstart属性，为touch事件指定监听函数。桌面设备没有这个属性。

</details>

## 26. 导致页面加载白屏时间长的原因有哪些？如何进行优化？

<details>
<summary>点查看答案</summary>

**答案：**

### 白屏时间

白屏时间是指从用户开始访问网页到浏览器开始显示任何内容的时间。

### 白屏过程

从输入url，到页面的画面展示的过程：

1、首先，在浏览器地址栏中输入url

2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。

3、在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。

4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。

5、握手成功后，浏览器向服务器发送http请求，请求数据包。

6、服务器处理收到的请求，将数据返回至浏览器

7、浏览器收到HTTP响应

8、读取页面内容，浏览器渲染，解析html源码

9、生成Dom树、解析css样式、js交互,渲染显示页面

### 白屏原因

从页面加载过程我们可以分析出白屏的主要原因：

1. 网络传输延迟：包括DNS解析慢，域名解析耗时过长；TCP连接建立慢；HTTP请求积压，没开启http2的情况下并发连接有限制

2. 关键资源阻塞：包括CSS阻塞，比如在`<head>`中引入的CSS文件，会阻塞页面的渲染；JavaScript阻塞，比如在`<head>`中引入的JavaScript文件，会阻塞页面的渲染

3. 服务器响应慢：主要是服务器处理请求慢，数据库查询慢，导致首字节到达时间过长

4. 框架初始化开销：SPA单页面应用

### 白屏优化

1. 网络层优化

  - DNS 预解析：使用 `<link rel="dns-prefetch" href="//example.com">` 提前解析域名。

  - 使用 CDN：将静态资源部署在离用户最近的边缘节点。

  - 升级 HTTP/2：利用多路复用解决排队问题，并使用服务器推送（Server Push）。

2. 关键资源路径优化（渲染层）

  - 资源压缩与合并：使用 Gzip 或 Brotli 压缩文本；利用 Webpack 合并小文件。

  - CSS 优化：提取"关键渲染路径"的 CSS 直接内联在 `<head>` 中，非关键 CSS 异步加载。

  - JS 脚本异步化：async：下载完立即执行（可能阻塞渲染）。defer：下载完后，等 DOM 解析完成后按顺序执行（推荐）。

3. 加载策略优化（应用层）

  - 路由懒加载：在 SPA 中，按需加载页面组件，减少首屏 JavaScript 体积。

  - 骨架屏 (Skeleton Screen)：在数据加载完之前，先展示一个页面的大致轮廓，缓解用户焦虑。

  - 预加载/预获取： `<link rel="preload">` 强制浏览器预先下载当前页面必需的资源， `<link rel="prefetch">` 告诉浏览器在空闲时下载未来可能用到的资源。

4. 架构级优化

  - 服务端渲染 (SSR)：直接在服务端生成完整的 HTML 字符串返回，浏览器拿到后即可渲染，几乎消除白屏时间。

  - 静态站点生成 (SSG)：如 Next.js 或 Nuxt.js，提前将页面编译为静态 HTML。

### 白屏扩展

1. 量化白屏时间：使用 Performance API 测量白屏时间。

2. 使用 Chrome DevTools 的 Network 面板监控请求和响应时间。

</details>