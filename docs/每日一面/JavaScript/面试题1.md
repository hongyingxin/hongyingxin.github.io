# JavaScript 面试题1

## 1. 以下代码输出什么？解释原因。

```javascript
const obj = {
  objName: "百度",
  print: () => console.log(this.objName),
};
```

<details>
<summary>点查看答案</summary>

**答案：**

```javascript
undefined
```

**解析：** 

1. 箭头函数的特性

- 箭头函数没有自己的`this`，它会继承定义时所在作用域的`this`
- `print`是用箭头函数定义的，所以它的`this`不是`obj`，而是定义它时所在的环境

2. 当前环境的this

- 这里箭头函数定义在全局作用域，所以它的`this`指向全局对象
- 严格模式下，顶层的`this`是`undefined`
- 非严格模式下，顶层的`this`是`window`（浏览器中）或者`global`（Node.js中）

3. 如何修改达到预期

将`print`改成普通函数，这样它的`this`就指向`obj`

```js
print: function() {
  console.log(this.objName);
}
```

</details>

## 2. trt..catch 可以捕获到异步代码中的错误吗

<details>
<summary>点查看答案</summary>

**答案：**

不能

**解析：**

这道题考察Javascript异步机制和错误处理的理解。以下面代码为例：

```js
try {
  setTimeout(() => {
    throw new Error('error');
  }, 1000);
} catch (error) {
  console.log(error);
}
```

setTimeout是一个异步函数，它的回调函数会在指定的延时后被放入事件队列，等待当前执行栈清空后才执行。因此，当setTimeout的回调函数执行并抛出错误时，try...catch已经执行完毕，无法捕捉到异步回调中的错误。

想要捕获异步代码的错误，应该：

1. 在异步回调内部使用try-catch
2. 使用Promise的catch方法
3. 使用async/await配置try-catch
4. 使用全局错误处理器（如 process.on('uncaughtException')）

</details>

## 3. 以下代码输出什么？解释原因。

```js
foo(typeof a);
function foo(p) {
  console.log(this);
  console.log(p);
  console.log(typeof b);
  let b = 0;
}
```

<details>
<summary>点查看答案</summary>

**答案：**

```javascript
window
undefined
before initialization
```

**解析：**

这段代码涉及了几个知识点：变量提升、`typeof`运算符特性、函数作用域内的`let`声明的暂时性死区、函数调用中的`this`指向。

**运行步骤：**

1. 函数`foo`被函数声明提升，因此在调用`foo(...)`时已可用
2. `typeof a`中的`a`未定义，但`typeof`操作符在访问未声明变量时不会跑错，而是返回`undefined`，所以`a`值为`undefined`，传入`foo(...)`的参数`p`为`undefined`
3. `console.log(this)`在非严格模式下，`this`指向全局对象`window`，所以输出`window`，开启严格模式后，`this`指向`undefined`
4. `console.log(p)`输出`undefined`
5. `console.log(typeof b)`中的`b`被`let`声明，存在暂时性死区，在声明前访问会报错，所以输出`before initialization`

</details>

## 4. 说说下面代码的输出结果

```js
Promise.resolve().then(() => {
  console.log(0)
  return Promise.resolve(4)
}).then((res) => {
  console.log(res)
})

Promise.resolve().then(() => {
  console.log(1)
}).then(() => {
  console.log(2)
}).then(() => {
  console.log(3)
}).then(() => {
  console.log(5)
}).then(() =>{
  console.log(6)
})
```

<details>
<summary>点查看答案</summary>

**答案：**

```javascript
0
1
2
3
4
5
6
``` 

暂时还不懂。
</details>

## 5. 如何让 Proxy 去监听基本数据类型

<details>
<summary>点查看答案</summary>

**答案：**

Proxy无法直接监听基本数据类型，因为它们是不可变的。Proxy只能在对象级别上进行操作。

当我们尝试使用 Proxy 包装基本数据类型时，会得到一个 TypeError 错误。因为基本数据类型不具备属性和方法。

```js
const value = 'Hello';
const handler = {
  set(target, property, value) {
    console.log(`Setting property '${property}' to '${value}'`);
    target[property] = value;
    return true;
  }
};
const proxyValue = new Proxy(value, handler); // TypeError: Cannot create proxy with a non-object as target
```

我们可以通过将基本数据类型包装成对象来监听它们。

```js

const value = 'hello'
function ValueWrapper(value) {
  this.value = value
}
const wrapper = new ValueWrapper(value)
const handler = {
  set(target, property, value) {
    console.log(`Setting property ${property} to ${value}`);
    target[property] = value;
    return true;
  },
}
const proxyValue = new Proxy(wrapper, handler)
console.log('proxyValue.name',proxyValue.value)
proxyValue.value = 'Jane'
console.log('proxyValue.name1',proxyValue.value)
```
</details>

## 6. Proxy 能够监听到对象中的对象的引用吗？

<details>
<summary>点查看答案</summary>

**答案：**

Proxy默认只能拦截对象第一层的操作，对于嵌套对象的属性修改无法直接拦截。

```js
const obj = {
  nestedObj: {
    foo: 'bar'
  }
}

const handler = {
  get(target, prop, receiver) {
    const value = Reflect.get(target, prop, receiver)
    if (typeof value === 'object' && value !== null) {
      return new Proxy(value, handler)  // 返回 Proxy 包装的对象
    }
    return value  // 返回原始值（字符串、数字等）
  },
  set(target, prop, value) {  
    target[prop] = value
    return true
  }
}

const proxyObj = new Proxy(obj, handler)
proxyObj.nestedObj.foo = 'baz'

const textObb = {
  name: 'John',
}
const textProxy = new Proxy(textObb, handler)
textProxy.name = 'Jane'
```

- 我们可以通过递归创建Proxy来实现对嵌套对象的属性修改的拦截
- 当 `proxyObj.nestedObj.foo = 'baz'` 执行时
- JavaScript引擎会把这个操作分解成两步，第一步获取 nestedObj 对象，第二步设置 foo 属性
即`const temp = proxyObj.nestedObj` ，然后 `temp.foo = 'baz'`
- 注意的一点：这里`Reflect.get`的作用是获取对象属性的原始值，它返回的是原始值，而不是Proxy包装的对象

</details>

## 7. 如果空数组调用reduce会发生什么？

<details>
<summary>点查看答案</summary>

**答案：**

这里分两种情况，
1. 一种是没有提供初始化参数，则会抛出一个TypeError错误。这是因为在空数组上调用reduce()方法时，无法得到初始累积值；
```js
const emptyArray = [];
const result = emptyArray.reduce((accumulator, currentValue) => accumulator + currentValue);
// TypeError: Reduce of empty array with no initial value
```
2. 一种是指定了初始化参数，则会返回初始化参数。这是因为在空数组上调用reduce()方法时，会返回初始化参数。
```js
const emptyArray = [];
const initialValue = 0;
const result = emptyArray.reduce((accumulator, currentValue) => accumulator + currentValue, initialValue);

console.log(result); // 输出: 0
```

</details>

## 8. 改变this指向的方法有哪些？

<details>
<summary>点查看答案</summary>

**答案：**

1. call()、bind()、apply()

</details>

## 9. 是否有使用过空值合并运算符（??），举几个可以使用的场景。

<details>
<summary>点查看答案</summary>

**答案：**

空值合并操作符（??）是一个逻辑操作符，当左侧的操作数为null或undefined时，返回右侧的操作数，否则返回左侧的操作数。
```js
const a = null ?? 'default';
console.log(a); // 输出: default

const b = 0 ?? 'default';
console.log(b); // 输出: 0

const c = 'hello' ?? 'default';
console.log(c); // 输出: hello
```

**场景的操作符**

1. 可选链操作符（?.）

作用：安全访问可能为 undefined 或 null 的属性

场景：避免访问不存在的对象属性时抛出错误

```js
const user = {
  name: 'John',
  address: {
    city: 'New York'
  }
}

const city = user.address?.city ?? 'Unknown';
console.log(city); // 输出: New York
```

2. 逻辑与操作符（&&）

作用：进行短路求值，避免访问 undefined 属性

场景：当左侧为假值时，直接返回左侧值；否则返回右侧值

```js
const user = {
  name: 'John',
  address: {
    city: 'New York'
  }
}

const city = user.address && user.address.city ?? 'Unknown';
console.log(city); // 输出: New York
```

3. 逻辑或操作符（||）

作用：提供默认值，当左侧为假值时返回右侧值

与 ?? 的区别：|| 对所有假值生效（0、''、false 等），而 ?? 只对 null 和 undefined 生效
场景：提供默认值，当左侧为假值时返回右侧值
```js
const user = {
  name: 'John',
  address: {
    city: 'New York'
  }
}

const city = user.address || user.address.city ?? 'Unknown';
console.log(city); // 输出: New York
```

4. 双重否定操作符（!!）

作用：将任何值转换为 boolean 类型

使用场景：强制类型转换为布尔值

```js
const value = 'hello';
const result = !!value;
console.log(result); // 输出: true
```

5. 三元操作符（?:）

作用：条件表达式，根据条件返回不同的值

使用场景：简洁的条件判断和赋值

```js
const value = 'hello';
const result = value ? 'yes' : 'no';
console.log(result); // 输出: yes
```

6. 逻辑赋值操作符

- ||=：逻辑或赋值（当左侧为假值时才赋值）
```js
const value = 'hello';
value ||= 'world';
console.log(value); // 输出: hello
```
- &&=：逻辑与赋值（当左侧为真值时才赋值）
```js
const value = 'hello';
value &&= 'world';
console.log(value); // 输出: hello
```
- ??=：空值合并赋值（当左侧为 null 或 undefined 时才赋值）
```js
const value = 'hello';
value ??= 'world';
console.log(value); // 输出: hello
```
</details>

10. 运行以上代码，输出结果为：

```js
function Foo(){
  Foo.a = function(){
      console.log(1);
  }
  this.a = function(){
      console.log(2)
  }
}

Foo.prototype.a = function(){
  console.log(3);
}

Foo.a = function(){
  console.log(4);
}

Foo.a();
let obj = new Foo();
obj.a();
Foo.a(); 
```

<details>
<summary>点查看答案</summary>

**答案：**

```javascript
4
2
1
```
**执行流程：**
1. 首先调用Foo.a()方法，输出4。Foo.a()是一个静态方法，直接在函数对象上定义
2. 然后创建了一个Foo类型的实例obj，调用obj.a()方法，输出2。this.a是一个实例方法，会覆盖原型上的方法
3. 最后再次调用Foo.a()方法，输出1。虽然在上面已经定义了一个静态方法Foo.ax，但是在构建函数Foo中又重新定义了一个同名属性，导致静态方法被覆盖了。

**关键知识点：**
1. 静态方法 vs 实例方法
    - Foo.a 是静态方法，属于函数对象本身
    - obj.a 是实例方法，属于实例对象
2. 属性查找链
    - 实例自身属性（通过 this.a 定义）
    - 原型属性（通过 Foo.prototype.a 定义）
    - 实例方法优先级高于原型方法
3. 构造函数的副作用
    - 构造函数内部可以修改函数对象的静态属性
    - 每次 new Foo() 都会执行这个修改
</details>