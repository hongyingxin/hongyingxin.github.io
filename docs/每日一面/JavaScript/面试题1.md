# JavaScript 面试题1

## 1. 以下代码输出什么？解释原因。

```javascript
const obj = {
  objName: "百度",
  print: () => console.log(this.objName),
};
```

<details>
<summary>点查看答案</summary>

**答案：**

```javascript
undefined
```

**解析：** 

1. 箭头函数的特性

- 箭头函数没有自己的`this`，它会继承定义时所在作用域的`this`
- `print`是用箭头函数定义的，所以它的`this`不是`obj`，而是定义它时所在的环境

2. 当前环境的this

- 这里箭头函数定义在全局作用域，所以它的`this`指向全局对象
- 严格模式下，顶层的`this`是`undefined`
- 非严格模式下，顶层的`this`是`window`（浏览器中）或者`global`（Node.js中）

3. 如何修改达到预期

将`print`改成普通函数，这样它的`this`就指向`obj`

```js
print: function() {
  console.log(this.objName);
}
```

</details>

## 2. trt..catch 可以捕获到异步代码中的错误吗

<details>
<summary>点查看答案</summary>

**答案：**

不能

**解析：**

这道题考察Javascript异步机制和错误处理的理解。以下面代码为例：

```js
try {
  setTimeout(() => {
    throw new Error('error');
  }, 1000);
} catch (error) {
  console.log(error);
}
```

setTimeout是一个异步函数，它的回调函数会在指定的延时后被放入事件队列，等待当前执行栈清空后才执行。因此，当setTimeout的回调函数执行并抛出错误时，try...catch已经执行完毕，无法捕捉到异步回调中的错误。

想要捕获异步代码的错误，应该：

1. 在异步回调内部使用try-catch
2. 使用Promise的catch方法
3. 使用async/await配置try-catch
4. 使用全局错误处理器（如 process.on('uncaughtException')）

</details>

## 3. 以下代码输出什么？解释原因。

```js
foo(typeof a);
function foo(p) {
  console.log(this);
  console.log(p);
  console.log(typeof b);
  let b = 0;
}
```

<details>
<summary>点查看答案</summary>

**答案：**

```javascript
window
undefined
before initialization
```

**解析：**

这段代码涉及了几个知识点：变量提升、`typeof`运算符特性、函数作用域内的`let`声明的暂时性死区、函数调用中的`this`指向。

**运行步骤：**

1. 函数`foo`被函数声明提升，因此在调用`foo(...)`时已可用
2. `typeof a`中的`a`未定义，但`typeof`操作符在访问未声明变量时不会跑错，而是返回`undefined`，所以`a`值为`undefined`，传入`foo(...)`的参数`p`为`undefined`
3. `console.log(this)`在非严格模式下，`this`指向全局对象`window`，所以输出`window`，开启严格模式后，`this`指向`undefined`
4. `console.log(p)`输出`undefined`
5. `console.log(typeof b)`中的`b`被`let`声明，存在暂时性死区，在声明前访问会报错，所以输出`before initialization`

</details>

## 4. 说说下面代码的输出结果

```js
Promise.resolve().then(() => {
  console.log(0)
  return Promise.resolve(4)
}).then((res) => {
  console.log(res)
})

Promise.resolve().then(() => {
  console.log(1)
}).then(() => {
  console.log(2)
}).then(() => {
  console.log(3)
}).then(() => {
  console.log(5)
}).then(() =>{
  console.log(6)
})
```

<details>
<summary>点查看答案</summary>

**答案：**

```javascript
0
1
2
3
4
5
6
``` 

暂时还不懂。
</details>

## 5. 如何让 Proxy 去监听基本数据类型

<details>
<summary>点查看答案</summary>

**答案：**

Proxy无法直接监听基本数据类型，因为它们是不可变的。Proxy只能在对象级别上进行操作。

当我们尝试使用 Proxy 包装基本数据类型时，会得到一个 TypeError 错误。因为基本数据类型不具备属性和方法。

```js
const value = 'Hello';
const handler = {
  set(target, property, value) {
    console.log(`Setting property '${property}' to '${value}'`);
    target[property] = value;
    return true;
  }
};
const proxyValue = new Proxy(value, handler); // TypeError: Cannot create proxy with a non-object as target
```

我们可以通过将基本数据类型包装成对象来监听它们。

```js

const value = 'hello'
function ValueWrapper(value) {
  this.value = value
}
const wrapper = new ValueWrapper(value)
const handler = {
  set(target, property, value) {
    console.log(`Setting property ${property} to ${value}`);
    target[property] = value;
    return true;
  },
}
const proxyValue = new Proxy(wrapper, handler)
console.log('proxyValue.name',proxyValue.value)
proxyValue.value = 'Jane'
console.log('proxyValue.name1',proxyValue.value)
```
</details>