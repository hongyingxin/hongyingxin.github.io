# JavaScript 面试题1

## 1. 以下代码输出什么？解释原因。

```javascript
const obj = {
  objName: "百度",
  print: () => console.log(this.objName),
};
```

<details>
<summary>点查看答案</summary>

**答案：**

```javascript
undefined
```

**解析：** 

1. 箭头函数的特性

- 箭头函数没有自己的`this`，它会继承定义时所在作用域的`this`
- `print`是用箭头函数定义的，所以它的`this`不是`obj`，而是定义它时所在的环境

2. 当前环境的this

- 这里箭头函数定义在全局作用域，所以它的`this`指向全局对象
- 严格模式下，顶层的`this`是`undefined`
- 非严格模式下，顶层的`this`是`window`（浏览器中）或者`global`（Node.js中）

3. 如何修改达到预期

将`print`改成普通函数，这样它的`this`就指向`obj`

```js
print: function() {
  console.log(this.objName);
}
```

</details>

## 2. trt..catch 可以捕获到异步代码中的错误吗

<details>
<summary>点查看答案</summary>

**答案：**

不能

**解析：**

这道题考察Javascript异步机制和错误处理的理解。以下面代码为例：

```js
try {
  setTimeout(() => {
    throw new Error('error');
  }, 1000);
} catch (error) {
  console.log(error);
}
```

setTimeout是一个异步函数，它的回调函数会在指定的延时后被放入事件队列，等待当前执行栈清空后才执行。因此，当setTimeout的回调函数执行并抛出错误时，try...catch已经执行完毕，无法捕捉到异步回调中的错误。

想要捕获异步代码的错误，应该：

1. 在异步回调内部使用try-catch
2. 使用Promise的catch方法
3. 使用async/await配置try-catch
4. 使用全局错误处理器（如 process.on('uncaughtException')）

</details>

## 3. 以下代码输出什么？解释原因。

```js
foo(typeof a);
function foo(p) {
  console.log(this);
  console.log(p);
  console.log(typeof b);
  let b = 0;
}
```

<details>
<summary>点查看答案</summary>

**答案：**

```javascript
window
undefined
before initialization
```

**解析：**

这段代码涉及了几个知识点：变量提升、`typeof`运算符特性、函数作用域内的`let`声明的暂时性死区、函数调用中的`this`指向。

**运行步骤：**

1. 函数`foo`被函数声明提升，因此在调用`foo(...)`时已可用
2. `typeof a`中的`a`未定义，但`typeof`操作符在访问未声明变量时不会跑错，而是返回`undefined`，所以`a`值为`undefined`，传入`foo(...)`的参数`p`为`undefined`
3. `console.log(this)`在非严格模式下，`this`指向全局对象`window`，所以输出`window`，开启严格模式后，`this`指向`undefined`
4. `console.log(p)`输出`undefined`
5. `console.log(typeof b)`中的`b`被`let`声明，存在暂时性死区，在声明前访问会报错，所以输出`before initialization`

</details>

## 4. 说说下面代码的输出结果

```js
Promise.resolve().then(() => {
  console.log(0)
  return Promise.resolve(4)
}).then((res) => {
  console.log(res)
})

Promise.resolve().then(() => {
  console.log(1)
}).then(() => {
  console.log(2)
}).then(() => {
  console.log(3)
}).then(() => {
  console.log(5)
}).then(() =>{
  console.log(6)
})
```

<details>
<summary>点查看答案</summary>

**答案：**

```javascript
0
1
2
3
4
5
6
``` 

暂时还不懂。
</details>

## 5. 如何让 Proxy 去监听基本数据类型

<details>
<summary>点查看答案</summary>

**答案：**

Proxy无法直接监听基本数据类型，因为它们是不可变的。Proxy只能在对象级别上进行操作。

当我们尝试使用 Proxy 包装基本数据类型时，会得到一个 TypeError 错误。因为基本数据类型不具备属性和方法。

```js
const value = 'Hello';
const handler = {
  set(target, property, value) {
    console.log(`Setting property '${property}' to '${value}'`);
    target[property] = value;
    return true;
  }
};
const proxyValue = new Proxy(value, handler); // TypeError: Cannot create proxy with a non-object as target
```

我们可以通过将基本数据类型包装成对象来监听它们。

```js

const value = 'hello'
function ValueWrapper(value) {
  this.value = value
}
const wrapper = new ValueWrapper(value)
const handler = {
  set(target, property, value) {
    console.log(`Setting property ${property} to ${value}`);
    target[property] = value;
    return true;
  },
}
const proxyValue = new Proxy(wrapper, handler)
console.log('proxyValue.name',proxyValue.value)
proxyValue.value = 'Jane'
console.log('proxyValue.name1',proxyValue.value)
```
</details>

## 6. Proxy 能够监听到对象中的对象的引用吗？

<details>
<summary>点查看答案</summary>

**答案：**

Proxy默认只能拦截对象第一层的操作，对于嵌套对象的属性修改无法直接拦截。

```js
const obj = {
  nestedObj: {
    foo: 'bar'
  }
}

const handler = {
  get(target, prop, receiver) {
    const value = Reflect.get(target, prop, receiver)
    if (typeof value === 'object' && value !== null) {
      return new Proxy(value, handler)  // 返回 Proxy 包装的对象
    }
    return value  // 返回原始值（字符串、数字等）
  },
  set(target, prop, value) {  
    target[prop] = value
    return true
  }
}

const proxyObj = new Proxy(obj, handler)
proxyObj.nestedObj.foo = 'baz'

const textObb = {
  name: 'John',
}
const textProxy = new Proxy(textObb, handler)
textProxy.name = 'Jane'
```

- 我们可以通过递归创建Proxy来实现对嵌套对象的属性修改的拦截
- 当 `proxyObj.nestedObj.foo = 'baz'` 执行时
- JavaScript引擎会把这个操作分解成两步，第一步获取 nestedObj 对象，第二步设置 foo 属性
即`const temp = proxyObj.nestedObj` ，然后 `temp.foo = 'baz'`
- 注意的一点：这里`Reflect.get`的作用是获取对象属性的原始值，它返回的是原始值，而不是Proxy包装的对象

</details>

## 7. 如果空数组调用reduce会发生什么？

<details>
<summary>点查看答案</summary>

**答案：**

这里分两种情况，
1. 一种是没有提供初始化参数，则会抛出一个TypeError错误。这是因为在空数组上调用reduce()方法时，无法得到初始累积值；
```js
const emptyArray = [];
const result = emptyArray.reduce((accumulator, currentValue) => accumulator + currentValue);
// TypeError: Reduce of empty array with no initial value
```
2. 一种是指定了初始化参数，则会返回初始化参数。这是因为在空数组上调用reduce()方法时，会返回初始化参数。
```js
const emptyArray = [];
const initialValue = 0;
const result = emptyArray.reduce((accumulator, currentValue) => accumulator + currentValue, initialValue);

console.log(result); // 输出: 0
```

</details>

## 8. 改变this指向的方法有哪些？

<details>
<summary>点查看答案</summary>

**答案：**

1. call()、bind()、apply()

</details>

## 9. 是否有使用过空值合并运算符（??），举几个可以使用的场景。

<details>
<summary>点查看答案</summary>

**答案：**

空值合并操作符（??）是一个逻辑操作符，当左侧的操作数为null或undefined时，返回右侧的操作数，否则返回左侧的操作数。
```js
const a = null ?? 'default';
console.log(a); // 输出: default

const b = 0 ?? 'default';
console.log(b); // 输出: 0

const c = 'hello' ?? 'default';
console.log(c); // 输出: hello
```

**场景的操作符**

1. 可选链操作符（?.）

作用：安全访问可能为 undefined 或 null 的属性

场景：避免访问不存在的对象属性时抛出错误

```js
const user = {
  name: 'John',
  address: {
    city: 'New York'
  }
}

const city = user.address?.city ?? 'Unknown';
console.log(city); // 输出: New York
```

2. 逻辑与操作符（&&）

作用：进行短路求值，避免访问 undefined 属性

场景：当左侧为假值时，直接返回左侧值；否则返回右侧值

```js
const user = {
  name: 'John',
  address: {
    city: 'New York'
  }
}

const city = user.address && user.address.city ?? 'Unknown';
console.log(city); // 输出: New York
```

3. 逻辑或操作符（||）

作用：提供默认值，当左侧为假值时返回右侧值

与 ?? 的区别：|| 对所有假值生效（0、''、false 等），而 ?? 只对 null 和 undefined 生效
场景：提供默认值，当左侧为假值时返回右侧值
```js
const user = {
  name: 'John',
  address: {
    city: 'New York'
  }
}

const city = user.address || user.address.city ?? 'Unknown';
console.log(city); // 输出: New York
```

4. 双重否定操作符（!!）

作用：将任何值转换为 boolean 类型

使用场景：强制类型转换为布尔值

```js
const value = 'hello';
const result = !!value;
console.log(result); // 输出: true
```

5. 三元操作符（?:）

作用：条件表达式，根据条件返回不同的值

使用场景：简洁的条件判断和赋值

```js
const value = 'hello';
const result = value ? 'yes' : 'no';
console.log(result); // 输出: yes
```

6. 逻辑赋值操作符

- ||=：逻辑或赋值（当左侧为假值时才赋值）
```js
const value = 'hello';
value ||= 'world';
console.log(value); // 输出: hello
```
- &&=：逻辑与赋值（当左侧为真值时才赋值）
```js
const value = 'hello';
value &&= 'world';
console.log(value); // 输出: hello
```
- ??=：空值合并赋值（当左侧为 null 或 undefined 时才赋值）
```js
const value = 'hello';
value ??= 'world';
console.log(value); // 输出: hello
```
</details>

## 10. 运行以上代码，输出结果为：

```js
function Foo(){
  Foo.a = function(){
      console.log(1);
  }
  this.a = function(){
      console.log(2)
  }
}

Foo.prototype.a = function(){
  console.log(3);
}

Foo.a = function(){
  console.log(4);
}

Foo.a();
let obj = new Foo();
obj.a();
Foo.a(); 
```

<details>
<summary>点查看答案</summary>

**答案：**

```javascript
4
2
1
```
**执行流程：**
1. 首先调用Foo.a()方法，输出4。Foo.a()是一个静态方法，直接在函数对象上定义
2. 然后创建了一个Foo类型的实例obj，调用obj.a()方法，输出2。this.a是一个实例方法，会覆盖原型上的方法
3. 最后再次调用Foo.a()方法，输出1。虽然在上面已经定义了一个静态方法Foo.ax，但是在构建函数Foo中又重新定义了一个同名属性，导致静态方法被覆盖了。

**关键知识点：**
1. 静态方法 vs 实例方法
    - Foo.a 是静态方法，属于函数对象本身
    - obj.a 是实例方法，属于实例对象
2. 属性查找链
    - 实例自身属性（通过 this.a 定义）
    - 原型属性（通过 Foo.prototype.a 定义）
    - 实例方法优先级高于原型方法
3. 构造函数的副作用
    - 构造函数内部可以修改函数对象的静态属性
    - 每次 new Foo() 都会执行这个修改
</details>

## 11. 运行以上代码，输出结果为：

```js
const obj = {
 fn1: () => console.log(this),
 fn2: function() {console.log(this)}
}

obj.fn1();
obj.fn2();

const x = new obj.fn1();
const y = new obj.fn2();
```

<details>
<summary>点查看答案</summary>

**答案：**

```js
Window
{fn1, fn2}
obj.fn1 is not a constructor
```

- 箭头函数没有自己的`this`值，因为`fn1`中的this指向是全局对象window，所以输出Window
- `fn2`中的this指向是`obj`对象，所以输出`{fn1, fn2}`
- `new obj.fn1()`会报错，因为`fn1`是一个箭头函数，不能作为构造函数使用
- `new obj.fn2()`会创建一个新对象，因为`fn2`是一个普通函数，所以输出`{fn1, fn2}`，但因为上面执行报错，所以并不会执行。

</details>

## 12. 浏览器有几种缓存，它们的优先级什么样？

<details>
<summary>点查看答案</summary>

**答案：**

浏览器缓存主要分为两种：

1. 强缓存（Strong Cache）：通过Expires或Cache-Control控制，浏览器直接从本地缓存读取，不发送请求到服务器
2. 协商缓存（Negotiation Cache）：通过ETag或Last-Modified控制，浏览器发送条件请求到服务器验证缓存是否有效
3. Service Worker：通过Service Worker缓存，浏览器直接从本地缓存读取，不发送请求到服务器
4. Web Storage：包括localStorage和sessionStorage，浏览器直接从本地缓存读取，不发送请求到服务器

优先级：Service Worker > 强缓存 > 协商缓存 > Web Storage
</details>

## 13. Web Worker是什么

<details>
<summary>点查看答案</summary>

**答案：**

Web Worker是 HTML5 标准中提供的一项技术，它可以让 JavaScript 在后台运行，从而避免阻塞 UI 线程。

Web Worker 有以下几个特点：
1. 独立线程
2. 沙箱环境
3. 事件通信

</details>

## 14. Promise的 finally 怎么实现的？

<details>
<summary>点查看答案</summary>

**答案：**

Promise的finally方法是ES2018(ES9)引入的，它会在Promise结束时（无论成功还是失败）都会执行回调函数。

**基本实现原理：**

```javascript
Promise.prototype.finally = function(callback) {
  // 获取Promise构造函数
  const P = this.constructor;
  // 返回一个新的Promise
  return this.then(
    // 成功时
    value => P.resolve(callback()).then(() => value),
    // 失败时  
    reason => P.resolve(callback()).then(() => { throw reason })
  );
};
```

**实现要点：**

1. **无论成功失败都执行**：finally回调在Promise settled（已敲定）时都会执行
2. **不改变原Promise的值**：finally不会修改Promise的结果值或拒绝原因
3. **支持异步回调**：如果callback返回Promise，会等待其完成
4. **错误传播**：如果callback抛出错误，会替换原来的结果
</details>

## 15. Promise then的第二个参数和catch的区别

<details>
<summary>点查看答案</summary>

**答案：**

`Promise`的`then`方法和`catch`方法都是用于处理Promise的rejected的情况。它们的区别在于：
1. `then`方法的第二个参数

如果`Promise`的状态为rejected，`then`方法的第二个参数会被调用。该参数是一个函数，可以接受一个参数，即Promise返回的错误信息。
```js
function asyncFunction() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(new Error('Something went wrong'));
    }, 1000);
  });
}

asyncFunction()
  .then(
    result => console.log(result), 
    error => console.error(error)
  );
// 在上述代码中，当 Promise 被 reject 时，then 方法的第二个参数会被调用，并打印出错误信息。
```

2. `catch`方法

`catch` 方法相当于 `then` 方法的第二个参数，也是用于处理 `Promise` 的 rejected 状态的情况。不同之处在于，`catch` 方法可以链式调用，而不需要在每次调用 `then` 方法时都传递第二个参数。
```js
function asyncFunction() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(new Error('Something went wrong'));
    }, 1000);
  });
}

asyncFunction()
  .then(result => console.log(result))
  .catch(error => console.error(error));
// 在上述代码中，当 Promise 被 reject 时，catch 方法会被调用，并打印出错误信息。
```

因此，then 方法的第二个参数和 catch 方法都是用于处理 Promise 的 rejected 状态的情况，但前者需要在每次调用 then 方法时都传递第二个参数，而后者则可以链式调用。
</details>

## 16. 以下代码输出什么？

```js
var name = '123';

var obj = {
 name: '456',
 print: function() {
  function a() {
    console.log(this.name);
  }
  a();
 }
}

obj.print();
```

<details>
<summary>点查看答案</summary>

**答案：**

```javascript
123
```

**解析：**

1. 在全局作用域声明了变量name，值为'123'
2. 声明一个对象obj，包含属性name和方法print，name属性的值为'456'，print方法的值为一个函数a
3. 当执行obj.print()时，会调用print方法，并在其中定义了函数a
4. 函数a中调用console.log(this.name)，由于this指向的是全局对象，所以输出'123'


**演变**
```js
var name = '123';

var obj = {
 name: '456',
 print: function() {
  const a = () => {
    console.log(this.name);
  }
  a();
 }
}

obj.print();
```
如果想正确输出结果，可以使用箭头函数来定义a函数，这样a函数中的this就指向obj对象。

</details>

## 17. 以下代码输出什么？

```js
console.log(typeof typeof typeof null);
console.log(typeof console.log(1));
```

<details>
<summary>点查看答案</summary>

**答案：**

```javascript
"string"
1
"undefined"
```

**解析：**

1. `typeof typeof typeof null`

- `typeof null` 返回 "object"
- `typeof "object"` 返回 "string"
- `typeof "string"` 返回 "string"

因此最终结果为`string`

2. `typeof console.log(1)`

- `console.log(1)` 输出 `1`
- `console.log(1)`没有返回值，因此返回`undefined`
- `typeof "undefined"` 返回 `undefined`

因此最终结果为`string -> 1 -> undefined`

</details>

## 18. async/await、generator、promise 的区别和关联

<details>
<summary>点查看答案</summary>

**答案：**

promise与async/await函数都是用来解决JavaScript中的异步问题，从回调函数，到Promise处理异步，到Generator处理异步，再到Async/await处理异步，它们都是为了解决回调地狱问题，让异步代码看起来更像同步代码，从而提高代码的可读性和可维护性。

**关联**

- async/await：是建立在Generator函数的语法糖，可以更方便地实现异步编程。async函数返回一个Promise对象，await表达式会阻塞代码执行，直到Promise对象状态变为resolved。

- promise：是一种异步编程模型，可以将回调函数嵌套的代码转换为链式调用。

- generator：是一种迭代器，可以通过yield表达式暂停代码执行，并通过next()方法恢复执行。

**区别**

- async/await：是 ES7 引入的新特性，可以让异步编程看起来像同步编程，更加易读易写。async/await 只能用于函数内部，不能用于顶层代码（例如全局作用域）。

- Promise：是 ES6 引入的新特性，使用 then() 方法和 catch() 方法注册回调函数，实现异步编程。Promise 可以使用 race() 方法和 all() 方法处理多个异步操作。

- Generator：是 ES6 引入的新特性，可以通过 yield 表达式暂停和恢复代码执行，实现异步流程控制。Generator 需要手动执行 next() 方法，才能继续执行下一步操作。

</details>

## 19. 说说对 requestIdleCallback 的理解

<details>
<summary>点查看答案</summary>

**答案：**

`requestIdleCallback`是一个浏览器 API，它允许我们在浏览器空闲时执行一些任务，以提高网页的性能和响应速度。

通常情况下，JavaScript 代码会占用主线程，从而阻塞了其他的任务。当页面需要进行一些复杂计算、渲染大量的DOM元素等操作时，就会导致用户的交互体验变得缓慢和卡顿。

`requestIdleCallback` 的作用就是将一些非关键性的任务从主线程中分离出来，等到浏览器闲置时再执行。这样就可以避免占用主线程，提高页面的响应速度和流畅度。

使用 `requestIdleCallback` 需要传入一个回调函数，该函数会在浏览器空闲时被调用。回调函数的参数是一个 `IdleDeadline` 对象，它包含有关浏览器还剩余多少时间可供执行任务的信息。根据该对象的时间戳信息，开发人员可以自行决定是否继续执行任务或推迟执行。

`requestIdleCallback` 可以帮助我们优化 Web 应用程序的性能和响应速度，减少资源的浪费。

### 延展

`requestAnimationFrame` 在重新渲染屏幕之前执行，适合用来做动画；而 `requestIdleCallback` 在渲染屏幕之后执行，并且是否有空执行要看浏览器的调度，或者使用 `timeout` 参数。

</details>

## 20. 页面加载的过程中，JS 文件是不是一定会阻塞 DOM 和 CSSOM 的构建？

<details>
<summary>点查看答案</summary>

**答案：**

不一定

**解析：**

JavaScript阻塞DOM和CSSOM的构建的情况主要集中在以下两个方面：

- JavaScript文件被放置在head标签内部
当JavaScript文件被放置在head标签内部时，浏览器会先加载JavaScript文件并执行它，然后才会继续解析HTML文档。因此，如果JavaScript文件过大或服务器响应时间过长，就会导致页面一直处于等待状态，进而影响DOM和CSSOM的构建。

- JavaScript代码修改了DOM结构
在JavaScript代码执行时，如果对DOM结构进行了修改，那么浏览器需要重新计算布局（reflow）和重绘（repaint），这个过程会较为耗时，并且会阻塞DOM和CSSOM的构建。

除此之外，还有一些情况下JavaScript并不会阻塞DOM和CSSOM的构建：

- 通过设置 script 标签的 async 、defer 属性避免阻塞DOM和CSSOM的构建
  - async：异步加载JavaScript文件，脚本的下载和执行将与其他工作同时进行（例如从服务器请求其他资源、渲染页面等），而不必等到脚本下载完成才开始这些操作。因此，在使用 async 属性时，脚本的加载和执行是异步的，并且不保证脚本在页面中的顺序。
  - defer属性 ：属性也告诉浏览器立即下载脚本文件，但有一个重要的区别：当文档解析时，脚本不会执行，直到文档解析完成后才执行。这意味着脚本将按照它们在页面上出现的顺序执行，并且在执行之前，整个文档已经被解析完毕了。
- Web Workers ：Web Workers 是一种运行在后台线程的JavaScript脚本，它不会阻塞DOM和CSSOM的构建，并且可以利用多核CPU提高JavaScript代码执行速度。

</details>