# 面试题

## 数据类型

### null 和 undefined 的区别

null 表示“没有对象”，undefined 表示“没有定义”。

null 是一个对象，undefined 是一个原始类型。

### 对象之间的比较规则

```js
{} == {}      // false
[] == []      // false
[1] == [1]    // false
```

对象比较时比较的是引用地址，即使两个对象的内容完全相同，只要是不同的实例，比较结果也是

### 为什么 0.1 + 0.2 !== 0.3？

```javascript
console.log(0.1 + 0.2);     // 0.30000000000000004
console.log(0.1 + 0.2 === 0.3);  // false
```

这是因为 JavaScript 使用 IEEE 754 双精度浮点数，某些小数在二进制表示时是无限循环的。（省流：浮点数精度问题）

## 类型判断

### typeof NaN 的结果是什么

```js
typeof NaN; // 'number'
```

NaN 是一个特殊的数值类型，表示“不是一个数字”，用于指出数字类型中的错误情况。

NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN
为 true。

### 为什么 typeof null 的结果是 'object'？

对象的类型信息是000，null的类型信息是0，因此和对象的标识位相同，所以typeof null会返回'object'。

### 为什么 instanceof 不能检测原始类型？

因为原始类型不是对象，没有原型链，所以不能使用 instanceof 运算符。

### 如何实现一个 instanceof 方法？ （手写）

instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。

实现思路：获取对象的原型（`__proto__`），获取构造函数的 prototype，循环判断对象的原型是否等于构造函数的 prototype，如果找到返回 true，找不到返回 false

补充说明：ES6 之后推荐使用 Object.getPrototypeOf() 获取原型，因为 __proto__ 属性已被废弃。

```js
function myInstanceof(left, right) {
  // 获取对象的原型
  let proto = Object.getPrototypeOf(left);
  // 获取构造函数的 prototype
  let prototype = right.prototype;
  // 递归查找原型链
  while (proto) {
    if (proto === prototype) {
        return true;
    }
    proto = Object.getPrototypeOf(proto);
  }
  return false;
}
```

## 数组

### 数组去重

```js
const arr = [1, 2, 1, 2, 1, 2]

// ES6 Set去重
function unique (arr) {
  return Array.from(new Set(arr))
}

// indexOf去重
function unique (arr) {
  let array = []
  for (let i = 0; i < arr.length; i++) {
    if (array.indexOf(arr[i]) === -1) {
      array.push(arr[i])
    }
  }
  return array
}

// filter
function unique (arr) {
  return arr.filter((item, index) => arr.indexOf(item) === index);
}

// reduce
function unique (arr) {
  return arr.reduce((prev, cur) => 
    prev.includes(cur) ? prev : [...prev, cur], []);
}
```

### 数组扁平化

```js
const arr = [1, 2, [3, 4, [5, 6]]]

// ES6 flat() Infinity为展开全部
arr.flat(Infinity)

// reduce实现
function flatArray(arr) {
  return arr.reduce((acc, val) => 
    Array.isArray(val) ? acc.concat(flatArray(val)) : acc.concat(val)
  ), []
}
```