# vue3

## ref和reactive的区别是什么

### reactive(object)

- 返回一个对象的响应式代理。
- 仅对引用数据类型有效，对基本数据类型无效（控制台不报错，但失去响应式）。
- 可以直接访问。
- **响应式丢失问题**：
  - 解构和整体赋值（不能替换整个对象，对解构操作不友好）。
  - 返回的是一个原始对象的 `Proxy`，因此和原始对象不相等。

#### 局限性：
1. **有限的值类型**：只能用于对象类型。
2. **不能替换整个对象**：由于 Vue 的响应式跟踪是通过同属性访问实现的，必须保持对响应式对象的相同引用。
3. **对解构操作不友好**：当进行解构时，或者将该属性传递给函数，会丢失响应性连接。

### ref(val)

- 返回一个对象的响应式代理。
- 对任何数据类型都有效（当值为引用数据类型时，会用 `reactive` 转换）。
- 访问数据需要通过 `.value` 的形式（在 template 模板中不需要）。

### 如何选择

1. 如果你需要一个响应式原始值，那么使用 `ref()` 是正确的选择，要注意是原始值。
2. 如果你需要一个响应式对象，层级不深，那么使用 `ref` 也可以。
3. 如果您需要一个响应式可变对象，并且对象层级较深，需要深度跟踪，那么使用 `reactive`。

### 总结

- ref：用于基本数据类型和单个对象引用，返回一个包装对象，需要通过.value访问。
- reactive：用于对象类型（对象和数组）返回原对象的响应式代理，可以直接访问。
- 使用场景：基本类型用ref，复杂对象用reactive，需要整体替换对象时使用ref

## setup函数什么时候执行？能访问this吗？

- 执行时机：组合式API的`setup()`钩子会在所有选项时API钩子之前调用，包括`beforeCreate()`。

- this访问：不能访问this，因为组件实例还不存在，为`undefined`。

- 参数：接收`props`、`context`两个参数。