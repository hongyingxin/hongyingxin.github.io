# vue3

## 1.ref和reactive的区别是什么

### reactive(object)

- 返回一个对象的响应式代理。
- 仅对引用数据类型有效，对基本数据类型无效（控制台不报错，但失去响应式）。
- 可以直接访问。
- **响应式丢失问题**：
  - 解构和整体赋值（不能替换整个对象，对解构操作不友好）。
  - 返回的是一个原始对象的 `Proxy`，因此和原始对象不相等。

#### 局限性：
1. **有限的值类型**：只能用于对象类型。
2. **不能替换整个对象**：由于 Vue 的响应式跟踪是通过同属性访问实现的，必须保持对响应式对象的相同引用。
3. **对解构操作不友好**：当进行解构时，或者将该属性传递给函数，会丢失响应性连接。

### ref(val)

- 返回一个对象的响应式代理。
- 对任何数据类型都有效（当值为引用数据类型时，会用 `reactive` 转换）。
- 访问数据需要通过 `.value` 的形式（在 template 模板中不需要）。

### 如何选择

1. 如果你需要一个响应式原始值，那么使用 `ref()` 是正确的选择，要注意是原始值。
2. 如果你需要一个响应式对象，层级不深，那么使用 `ref` 也可以。
3. 如果您需要一个响应式可变对象，并且对象层级较深，需要深度跟踪，那么使用 `reactive`。

### 总结

- ref：用于基本数据类型和单个对象引用，返回一个包装对象，需要通过.value访问。
- reactive：用于对象类型（对象和数组）返回原对象的响应式代理，可以直接访问。
- 使用场景：基本类型用ref，复杂对象用reactive，需要整体替换对象时使用ref

## 2.setup函数什么时候执行？能访问this吗？

- 执行时机：组合式API的`setup()`钩子会在所有选项时API钩子之前调用，包括`beforeCreate()`。

- this访问：不能访问this，因为组件实例还不存在，为`undefined`。

- 参数：接收`props`、`context`两个参数。

## 3.watchEffect和watch的具体区别？

- `watch`和`watchEffect`都是监听器，它们之间的主要区别是追踪响应式依赖的方式。
- 与`watchEffect`相比，`watch`可以懒执行副作用，更加明确是应该由哪个状态触发侦听器重新执行，可以访问所侦听状态的前一个值和当前值。
- `watchEffect`：自动监听数据源作为依赖，运行后立即执行。
- `watch`：只监听指明的数据源，不会监听回调中的数据，需要数据源改变后才会执行。
- options选项：
  - `immediate`：创建时立即触发回调
  - `deep`：强制深度遍历
  - `flush`：回调函数的刷新时机
  - `once`：一次性侦听器
- 使用场景： `watchEffect`适合副作用操作，`watch`适合需要对比新旧值的场景

## 4.Teleport是什么？解决了什么具体问题

Teleport 是一个内置组件，可以将组件的DOM挂载到指定的组件层，而不是默认的父组件层，常用于创建模态框等弹窗组件。

- 属性：
  - `to`属性为必选项，可以指定挂载的DOM位置，通常是body；
  - `disabled`属性为可选，可以禁用Teleport组件；
  - `defer`属性为可选，3.5+版本新增的属性，可以延迟挂载。
  
- 问题： 模态框、下拉菜单受父组件CSS影响（z-index、overflow等）
- 解决： 将组件内容渲染到任意DOM位置，通常是body
- 语法：` <Teleport to="body">content</Teleport>`