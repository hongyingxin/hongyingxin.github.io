# vue3

## 1.ref和reactive的区别是什么

### reactive(object)

- 返回一个对象的响应式代理。
- 仅对引用数据类型有效，对基本数据类型无效（控制台不报错，但失去响应式）。
- 可以直接访问。
- **响应式丢失问题**：
  - 解构和整体赋值（不能替换整个对象，对解构操作不友好）。
  - 返回的是一个原始对象的 `Proxy`，因此和原始对象不相等。

#### 局限性：
1. **有限的值类型**：只能用于对象类型。
2. **不能替换整个对象**：由于 Vue 的响应式跟踪是通过同属性访问实现的，必须保持对响应式对象的相同引用。
3. **对解构操作不友好**：当进行解构时，或者将该属性传递给函数，会丢失响应性连接。

### ref(val)

- 返回一个对象的响应式代理。
- 对任何数据类型都有效（当值为引用数据类型时，会用 `reactive` 转换）。
- 访问数据需要通过 `.value` 的形式（在 template 模板中不需要）。

### 如何选择

1. 如果你需要一个响应式原始值，那么使用 `ref()` 是正确的选择，要注意是原始值。
2. 如果你需要一个响应式对象，层级不深，那么使用 `ref` 也可以。
3. 如果您需要一个响应式可变对象，并且对象层级较深，需要深度跟踪，那么使用 `reactive`。

### 总结

- ref：用于基本数据类型和单个对象引用，返回一个包装对象，需要通过.value访问。
- reactive：用于对象类型（对象和数组）返回原对象的响应式代理，可以直接访问。
- 使用场景：基本类型用ref，复杂对象用reactive，需要整体替换对象时使用ref

## 2.setup函数什么时候执行？能访问this吗？

- 执行时机：组合式API的`setup()`钩子会在所有选项时API钩子之前调用，包括`beforeCreate()`。

- this访问：不能访问this，因为组件实例还不存在，为`undefined`。

- 参数：接收`props`、`context`两个参数。

## 3.watchEffect和watch的具体区别？

- `watch`和`watchEffect`都是监听器，它们之间的主要区别是追踪响应式依赖的方式。
- 与`watchEffect`相比，`watch`可以懒执行副作用，更加明确是应该由哪个状态触发侦听器重新执行，可以访问所侦听状态的前一个值和当前值。
- `watchEffect`：自动监听数据源作为依赖，运行后立即执行。
- `watch`：只监听指明的数据源，不会监听回调中的数据，需要数据源改变后才会执行。
- options选项：
  - `immediate`：创建时立即触发回调
  - `deep`：强制深度遍历
  - `flush`：回调函数的刷新时机
  - `once`：一次性侦听器
- 使用场景： `watchEffect`适合副作用操作，`watch`适合需要对比新旧值的场景

## 4.Teleport是什么？解决了什么具体问题

Teleport 是一个内置组件，可以将组件的DOM挂载到指定的组件层，而不是默认的父组件层，常用于创建模态框等弹窗组件。

- 属性：
  - `to`属性为必选项，可以指定挂载的DOM位置，通常是body；
  - `disabled`属性为可选，可以禁用Teleport组件；
  - `defer`属性为可选，3.5+版本新增的属性，可以延迟挂载。
  
- 问题： 模态框、下拉菜单受父组件CSS影响（z-index、overflow等）
- 解决： 将组件内容渲染到任意DOM位置，通常是body
- 语法：` <Teleport to="body">content</Teleport>`

## 5. Vue3编译时优化有哪些？

Vue3在编译时做了大量优化，主要目标是“编译时做更多工作，运行时做更少工作”，从而显著提升性能。主要包括以下几个方面：

**1. 静态提升（Static Hoisting）**

将模板中的静态节点提升到渲染函数外部。比如`<p>静态文本</p>`这样的节点，Vue3会在编译时识别出来，避免每次重新渲染时重复创建。减少了Vnode创建的开销。

**2. 补丁标记（Patch Flags）**

编译时给动态内容打标记，告诉运行时哪些地方可能会变。比如`<div :class="dynamicClass"></div>`会别标记为CLASS类型，更新时只检测class属性。精准更新，跳过静态内容。

**3.动态子节点收集**

只追踪会变化的子节点，形成一个扁平数组。避免遍历整个DOM树，更新复杂度从O(n)降到O(动态节点数)。

**4. 事件监听器缓存**

缓存事件处理函数，避免因为内联函数导致的不必要重渲染。特别是在父组件传递事件给子组件时。

**5. Block Tree架构**

Vue3引入了Block概念，将模板编译成Block树，每个Block只关心自己的动态子节点。

**6. Tree-shaking支持**

Vue3的API设计支持Tree-shaking，可以按需打包，只有被使用到的API才会被打包，减少bundle包体积。

**总结**

这些优化让Vue3相比Vue2性能提升了1.3-2倍，特别是在大型应用中表现更明显。核心思想就是通过编译时的静态分析，让运行时只关注真正会变化的部分。

## 6. Vue3的Tree-shaking怎么实现？