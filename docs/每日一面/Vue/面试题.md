# 面试题

## 1. Vue中 Scoped Styles 是如何实现样式隔离的？说说具体的原理

Vue的Scoped Styles通过**属性选择器**实现样式隔离。

**实现过程：**
1. **编译时**：Vue编译器为每个scoped组件生成唯一的哈希ID（如`data-v-f3f3eg9`），并将CSS选择器改写为带属性选择器的形式
2. **运行时**：为组件的所有DOM元素添加对应的data属性

它的优点是有效防止样式冲突，提高组件独立性，但是无法直接修改子组件样式，需要使用深度选择器`:deep()`

**🔗 详细解析：** [点击查看详细解析](./面试题-详解.md#_1-vue中-scoped-styles-是如何实现样式隔离的)

## 2. Vue3中的 Teleport是什么，有哪些应用场景？

Teleport是Vue3新增的内置组件，可以将组件的模板渲染到DOM树中的任意位置，而不受组件层级限制。

**主要应用场景：**
- **模态框/弹窗**：避免z-index层级问题，直接渲染到body下
- **Toast通知**：全局提示组件，需要在页面顶层显示
- **下拉菜单**：防止被父容器的overflow:hidden裁剪
- **全屏组件**：如全屏播放器、图片预览等

**🔗 详细解析：** [点击查看详细解析](./面试题-详解.md#_2-vue3中的-teleport是什么-有哪些应用场景)

## 3. 为什么需要Pinia或者Vuex？如果不使用状态管理工具，如何实现跨组件通信？代替方案有哪些？

**为什么需要状态管理工具：**
当应用复杂度增加时，多个组件需要共享状态，传统的props/emit方式会导致"prop drilling"问题，代码难以维护。

**不使用状态管理的跨组件通信方案：**
1. **Props/Emit**：父子组件通信，但多层嵌套时繁琐
2. **Provide/Inject**：祖先向后代传递数据，但缺乏响应式追踪
3. **Event Bus**：全局事件总线，但难以调试和维护
4. **全局变量**：简单粗暴，但破坏了组件封装性

**🔗 详细解析：** [点击查看详细解析](./面试题-详解.md#_3-为什么需要pinia或者vuex-如果不使用状态管理工具-如何实现跨组件通信-代替方案有哪些)

## 4. Vue3的 addRoute 与 React Router 的动态 useRoutes 有何区别？如何解决动态路由刷新后失效的问题？

**区别**
addRoute是命令式API，运行时动态添加路由到现有路由实例。路由实例可变，支持增删改路由，状态持久化。
useRoutes是声明式Hook，基于路由配置数组重新渲染路由树。每次调用useRoutes都会重新计算路由匹配，无状态。

**刷新失效解决方案：**
- **权限路由持久化**：将动态路由配置存储到localStorage/sessionStorage
- **应用初始化恢复**：在应用启动时从存储中恢复路由配置
- **路由守卫处理**：在beforeEach中检查并重新添加缺失的路由

**🔗 详细解析：** [点击查看详细解析](./面试题-详解.md#_4-vue3的-addroute-与-react-router-的动态-useroutes-有何区别-如何解决动态路由刷新后失效的问题)

## 5. Vue3中的 v-model 的改进是什么？如何使用 defineModel 简化代码？

**Vue3 v-model 主要改进：**
1. **支持多个v-model**：可以在同一组件上使用多个v-model绑定不同属性
2. **自定义修饰符**：支持自定义v-model修饰符，增强灵活性
3. **破坏性变更**：默认prop从`value`改为`modelValue`，事件从`input`改为`update:modelValue`

**defineModel 简化：**
- **Vue 3.4+新特性**：编译时宏，自动处理props和emit的声明
- **代码简化**：无需手动定义props和emit，一行代码搞定双向绑定
- **类型安全**：完整的TypeScript支持和类型推导

**🔗 详细解析：** [点击查看详细解析](./面试题-详解.md#_5-vue3中的-v-model-的改进是什么-如何使用-definemodel-简化代码)

## 6. Vue2中v-model的实现原理是什么？

v-model是Vue2中的语法糖，本质上是`:value`属性绑定和`@input`事件监听的组合。

**实现机制：**
1. **属性绑定**：将数据绑定到表单元素的`value`属性
2. **事件监听**：监听`input`事件，当用户输入时更新数据
3. **双向同步**：数据变化更新视图，用户输入更新数据

**不同表单元素的处理：**
- **input/textarea**：绑定`value`属性，监听`input`事件
- **checkbox/radio**：绑定`checked`属性，监听`change`事件  
- **select**：绑定`value`属性，监听`change`事件

**🔗 详细解析：** [点击查看详细解析](./面试题-详解.md#_6-vue2中v-model的实现原理是什么)

## 7. 在Vue中，为什么推荐使用ref而非直接操作DOM？

Vue是数据驱动的框架，推荐通过数据变化来驱动视图更新，而非直接操作DOM。

使用ref的优势可以保持数据驱动和声明式编程，避免手动DOM操作与Vue的虚拟DOM更新冲突，更好的可维护性，代码逻辑清晰，便于调试和维护，SSR兼容性，服务端渲染环境下DOM API不可用。

场景的场景有聚焦输入框、滚动定位等必要的DOM操作，集成第三方DOM库（如图表库、编辑器），获取DOM元素尺寸、位置等信息，调用原生DOM方法（如canvas绘图）。

**🔗 详细解析：** [点击查看详细解析](./面试题-详解.md#_7-在vue中为什么推荐使用ref而非直接操作dom)

## 8. template 标签为什么不能使用 v-show ？

template标签是Vue的虚拟标签，不会渲染到DOM中，而v-show是通过CSS的display属性控制显示隐藏，需要真实的DOM元素。

**技术原理：**
1. **template特性**：template标签仅作为模板容器，编译后不产生实际DOM节点
2. **v-show机制**：通过切换元素的`display: none`和`display: block`来控制显示
3. **冲突本质**：v-show需要操作真实DOM元素的样式，但template不存在于DOM中


**🔗 详细解析：** [点击查看详细解析](./面试题-详解.md#_8-template-标签为什么不能使用-v-show)

**🔗之前解释过：**[点击查看之前解释](../../随笔/11月.md#_11月3日)

## 9. watch 与 watchEffect 的区别，分别在什么场景下使用？

`watch`：需要明确指定监听的数据源，惰性执行,只有当监听的数据发生变化时才执行,可以访问新值和旧值

`watchEffect`：自动追踪回调函数中使用的响应式数据，立即执行,初始化时立即执行一次，之后响应式数据变化时执行,无法访问新旧值，只能访问当前值

**watch 适用场景：**需要监听特定数据源的变化，需要访问变化前后的值进行对比，执行异步操作或开销较大的操作，需要精确控制何时触发副作用

**watchEffect 适用场景：**需要根据多个响应式数据执行副作用，不关心具体监听哪些数据，只关心结果，需要立即执行的副作用，简化复杂依赖关系的监听

**🔗 详细解析：** [点击查看详细解析](./面试题-详解.md#_9-watch-与-watcheffect-的区别-分别在什么场景下使用)

## 10. 怎么理解 Vue3 提供的 markRaw ？

`markRaw` 是 Vue 3 提供的一个工具函数，用于标记一个对象，使其永远不会被转换为响应式对象。

**核心作用：**
1. **阻止响应式转换**：被 `markRaw` 标记的对象不会被 `reactive()` 或 `ref()` 转换为响应式
2. **性能优化**：避免对大型对象或第三方库实例进行不必要的响应式处理
3. **防止意外转换**：确保某些对象保持原始状态，不被 Vue 的响应式系统影响

**使用场景：**
- **第三方库实例**：如 Chart.js、Leaflet 地图等复杂对象
- **大型数据对象**：不需要响应式的大型配置对象或数据集
- **DOM 元素**：原生 DOM 节点或第三方组件实例
- **函数对象**：包含方法的复杂对象，避免响应式开销

**代码示例：**
```javascript
import { markRaw, reactive } from 'vue'

// 标记第三方库实例
const chart = markRaw(new Chart(canvas, config))
const state = reactive({
  chart, // chart 不会被转换为响应式
  data: [] // data 会被转换为响应式
})

// 标记大型配置对象
const config = markRaw({
  // 大量配置项...
})
```

**注意事项：**
- `markRaw` 是不可逆的，一旦标记就无法取消
- 被标记的对象及其嵌套属性都不会是响应式的
- 适合用于不需要追踪变化的对象

**🔗 详细解析：** [点击查看详细解析](./面试题-详解.md#_10-怎么理解-vue3-提供的-markraw)