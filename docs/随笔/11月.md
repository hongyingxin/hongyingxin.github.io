---
sticky: 11
---

# 11月

## 11月3日

突发奇想，为什么Vue的`template`模板不支持`v-show`指令而支持`v-if`指令。

`v-show`是通过切换元素的CSS `display`属性来控制显示/隐藏，元素始终会被渲染到DOM中；

`template`是一个抽象的包裹元素，不会被渲染为实际的DOM节点，它只是一个逻辑容器，用于分组多个元素，最终不会再页面中产生实际的HTML元素。

既然`v-show`需要通过修改 实际 DOM 元素 的 display 属性来工作，而 `template` 根本不会渲染成实际的 DOM 元素，那么 `v-show` 就无法在 `template` 上工作。

**延展**

`template`标签跟`DocumentFragment`文档片段


## 11月4日

css兼容问题之文本描边 `text-stroke` 和 `text-shadow`

**text-stroke**

`text-stroke` 是 CSS 的一个复合属性，用于设置或检索对象中的文字的描边，在浏览器兼容上面表现较差。
它包含两个属性：`text-stroke-color` 和 `text-stroke-width`，分别用于设置描边厚度和描边颜色。

最近发现一个兼容问题，在某些情况下，描边文字笔画的连接处会出现描边重叠颜色加深的现象。

```html
<!-- 正常网页场景页面结构 -->
<div class="class-font">添加了黑色描边的白色字体</div>

<!-- chrome场景页面结构 -->
<view class="class-font">添加了黑色描边的白色字体</view>
```
```css
.class-font {
  font-size: 24px;
  color: #fff;
  -webkit-text-stroke: 1px black;
  text-stroke: 1px black;
}
```

描边正常和异常情况的示例图如下：

![text-stroke 正常和异常情况的示例图](../public/assets/随笔/text-stroke_1.png)

尝试过各种兼容性写法，都不能解决这个问题。查看资料发现 text-stroke 其实并没有出现在任何 W3C 规范中，它曾经只作为文字描边属性短暂包含在规范中，但现在已被删除。

同时它只在 Firefox 和 Edge 上能够通过使用-webkit-text-stroke属性支持该效果（没有-moz-或-ms-前缀写法的浏览器支持）。
那么我们用什么办法去解决这个问题呢？

既然 text-stroke 存在问题，那我们看下另外有没有可以替换它效果的属性就好了，经发现在 css3 版本中存在一个叫 text-shadow 的文本阴影属性也可以满足我们想要的效果。

**text-shadow**

`text-shadow` 是 css3 版本中推出的一个新的属性，它被用于向文本设置阴影效果，其在浏览器兼容方面表现很好。

```css
.class-font {
  font-size: 24px;
  color: #fff;
  text-shadow: 1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
}
```

表现示例图如下：

![text-shadow 表现示例图](../public/assets/随笔/text-stroke_2.png)

在这里要说一下 text-shadow 和 text-stroke 两个属性在视觉方面的表现区别。

`text-stroke`属于文本内部描边，它是通过压榨文字内部空间实现的。比如一个白色的文字笔画线条粗细是4px，如果`text-stroke`设置的是一个2px厚度的黑色描边，那么这个文字的实际表现是：2px黑色描边 和 2px白色填充。

`text-shadow`则表现为文本外部描边，它相当于给文字的外部穿上了一层外套。同样4px粗细的文字笔画线条，其设置属性2px厚度的黑色文本阴影，这个文字的表现是：2px黑色描边 和 4px白色填充。

总体来说，两者视觉上表现稍有差异，但是在设置的描边厚度比较小的情况下基本是类似的，而且从使用上来说，`text-shadow`其实更贴合实际应用，所以我们完全可以直接使用 `text-shadow`来给文本实现描边效果。

## 11月5日

今天解决了一个遇到很久的问题。

在项目中，公共组件`components/GiftSwipe`目录的组件，在本地我不需要显式引入能够直接使用，但是正式环境不行，页面会报错。

```vue
<!-- 本地环境 -->
<GiftSwipe></GiftSwipe>

<!-- 正式环境 -->
<GiftSwipe></GiftSwipe>
<!-- 需要加这一行，不然会报找不到该组件的错误信息 -->
import GiftSwipe from '@/components/GiftSwipe/GiftSwipe.vue'
```

因为是环境问题，所以第一个检查构建配置文件`vite.config.ts`。

```typescript
import Components from 'unplugin-vue-components/vite';
import { VantResolver } from 'unplugin-vue-components/resolvers';

export default defineConfig({
  plugins: [
    vue(),
    Components({
      resolvers: [VantResolver()],
    }),
  ],
})
```

这里发现使用了`unplugin-vue-components`插件，这个插件可以自动引入组件。但是这个插件配置只注册了`VantResolver()`，那么他只会自动导入`Vant`组件库的组件，而不会自动导入我们自定义的组件。

在经过代码注释的测试下，我们确定了是因为这个插件引起的问题。

并且在这个过程中，发现启用这个插件时会生成一个`components.d.ts`文件，这个文件是用来声明组件的，从文件可以看到，`unplugin-vue-components`插件已经自动扫描并注册了`GiftSwipe`组件。 

```ts
import '@vue/runtime-core'

export {}

declare module '@vue/runtime-core' {
  export interface GlobalComponents {
    Carousel: typeof import('./src/components/Carousel/Carousel.vue')['default']
    CustomizeLamp: typeof import('./src/components/lamp/CustomizeLamp.vue')['default']
    GiftSwipe: typeof import('./src/components/GiftSwipe/GiftSwipe.vue')['default']
    Lamp: typeof import('./src/components/lamp/lamp.vue')['default']
    Music: typeof import('./src/components/Music/Music.vue')['default']
    NickCarousel: typeof import('./src/components/Carousel/NickCarousel.vue')['default']
    PreviewIndex: typeof import('./src/components/PreviewSvga/PreviewIndex.vue')['default']
    PreviewSvga: typeof import('./src/components/PreviewSvga.vue')['default']
    PreviewVap: typeof import('./src/components/PreviewSvga/PreviewVap.vue')['default']
    RouterLink: typeof import('vue-router')['RouterLink']
    RouterView: typeof import('vue-router')['RouterView']
  }
}
```

但是在`.gitignore`文件中，忽略了`components.d.ts`文件，所以这个文件没有被提交到仓库中。这就解释了为什么在本地可以正常使用，而在正式环境不行。

但是还有另一个问题没弄明白，为什么测试环境可以正常使用，而正式环境不行。

目前猜测时`vue-tsc`的严格程度不同，正式环境可能使用更严格的TypeScript类型检查或者`components.d.ts`文件没有被`tsconfig.json`正确包含。

因为默认生成的`components.d.ts`文件在根目录，但`tsconfig.json`只配置了`src`目录，所以`components.d.ts`文件没有被正确包含。

```ts
  "include": ["src/**/*.ts", "src/**/*.d.ts", "src/**/*.tsx", "src/**/*.vue", "src/utils.d.ts", "src/utils.d.ts"],
```
**解决方案**
```ts
// 方案1：修改 tsconfig.json 包含 components.d.ts
"include": ["src/**/*.ts", "src/**/*.d.ts", "src/**/*.tsx", "src/**/*.vue", "components.d.ts"]

// 方案2：配置 unplugin-vue-components 自动扫描自定义组件
Components({
  resolvers: [VantResolver()],
  dirs: ['src/components'], // 添加自定义组件目录
  dts: true // 确保生成类型声明文件
})
```

但是这个还不是我们想要的答案，这个是彻底解决这个问题的办法，但是我还是需要弄清楚为什么在测试环境可以正常使用，而在正式环境不行。

因为从执行命令来看，`vue-tsc`命令在测试和正式环境是完全一样的：

```bash
"test": "vue-tsc && vite build --mode test", // 测试环境
"build": "vue-tsc && vite build --mode prod" // 正式环境
```

那就可能是构建服务器的状态差异，两者使用了不同的构建服务器或构建策略。

# 测试环境与正式环境对比

| 方面 | 测试环境 | 正式环境 |
|------|---------|---------|
| 构建缓存 | 可能保留了之前的构建缓存 | 可能每次全新构建（clean build） |
| node_modules | 可能是增量更新 | 可能每次重新安装 |
| 临时文件 | 可能保留 components.d.ts | 可能被清理 |
| 构建频率 | 经常构建，有缓存 | 较少构建，每次都是干净环境 |

最终在检查`Jenkins`构建时，发现了两者的差异。

测试环境采用了普通构建策略，而正式环境则是每次都是清除残余后再构建。

```bash
# 第一次构建或开发时
npm run dev  # 或之前的某次构建
# ↓ unplugin-vue-components 生成了 components.d.ts
# ↓ 文件被保留在服务器上

# 后续的构建
npm run test
# ↓ vue-tsc 执行，找到了残留的 components.d.ts ✅
# ↓ 类型检查通过
# ↓ vite build 执行


# 正式环境
# 每次构建前清理
git clean -fdx  # 删除所有未跟踪的文件（包括 components.d.ts）
# 或
rm -rf node_modules build_v  

npm ci  # 而不是 npm install，更严格
npm run build
# ↓ vue-tsc 执行，没有找到 components.d.ts ❌
# ↓ 报错：<GiftSwipe> 组件类型未定义
```

到这里心里大概有个底了，但是因为涉及到流水线部署的原因，未能亲自验证，只能先记录下来，后续有时间再验证。

## 11月11日

记录一次git stash 的使用。

有时候我们会一不小心在`master`或者`develop`分支上开发，然后又需要切换到其他分支上开发，这时候我们就需要使用`git stash`来暂存我们的修改。

让我们看下官方对`git stash`的解释：

 > 当你想记录工作目录和索引的当前状态，但又想回到一个干净的工作目录时，请使用`git stash`。 该命令将你的本地修改保存起来，并将工作目录还原为与`HEAD`提交相匹配。

```bash
# 保存当前修改
git stash push
# git stash 是 git stash push 的简写
git stash
# 查看暂存列表
git stash list
# 查看暂存内容
git stash show
# 恢复暂存
git stash apply
```

### 命令详解

#### push

**语法：**
```bash
git stash push [-p|--patch] [-S|--staged] [-k|--[no-]keep-index] [-u|--include-untracked] [-a|--all] [-q|--quiet] [(-m|--message) <信息>] [--pathspec-from-file=<文件> [--pathspec-file-nul]] [--] [<路径规范>…​]
```

**功能说明：**
将你的本地修改保存到一个新的"存储条目"中，并将它们回滚到 HEAD（在工作区和索引中）。`<信息>`部分是可选的，它给出了描述和储藏的状态。

**注意事项：**
为了快速制作快照，你可以省略"push"。在这种模式下，非选项参数是不允许的，以防止拼写错误的子命令产生不需要的储藏条目。这方面的两个例外是 `stash -p`，它作为 `stash push -p` 的别名，以及为消除歧义允许在双连字符 `--` 之后的路径规范元素。

#### list[<日志选项>]

列出你目前拥有的储藏目录。 每个 "储藏目录 "都列出了它的名字（例如，`stash@{0}`是最新的条目，`stash@{1}`是之前的条目，等等），条目产生时的分支名称，以及该条目所基于的提交的简短描述。

```bash
git stash list

stash@{0}: WIP on submit: 6ebd0e2...更新 git-stash 文档
stash@{1}: On master: 9cc0589... 添加 git-stash
```

#### show

**语法：**
```bash
git stash show [-u|--include-untracked|--only-untracked] [<diff选项>] [<储藏目录>]
```

**功能说明：**
显示贮藏中记录的修改，作为贮藏内容与贮藏库条目首次创建时的提交之间的差异。 默认情况下，该命令显示diff统计，但它会接受 "git diff "已知的任何格式（例如，git stash show -p stash@{1}`以补丁形式查看第二条最新条目）。 如果没有提供<diff选项>，默认行为将由`stash.showStat`和`stash.showPatch`配置变量给出。你也可以使用`stash.showIncludeUntracked`来设置是否默认启用--include-untracked`。

**注意事项：**
如果没有提供<diff选项>，默认行为将由`stash.showStat`和`stash.showPatch`配置变量给出。你也可以使用`stash.showIncludeUntracked`来设置是否默认启用--include-untracked`。


#### pop

```bash
git pop [--index] [-q|--quiet] [<暂存>]
```
**功能说明：**
从贮藏库列表中移除一个单一的贮藏状态，并将其应用于当前工作区状态之上，也就是做`git stash push`的逆向操作。工作目录必须与索引匹配。

**注意事项：**
应用状态可能会因为冲突而失败；在这种情况下，它不会被从贮藏库列表中删除。你需要手动解决冲突，并在之后调用 git stash drop。

#### apply

与pop命令类似，但是不会删除暂存。 

### 实战

上面介绍完常用的命令，下面让我们进入实战内容。

```bash
# 查看当前的git工作目录状态，确定修改到文件
git status
# 先暂存修改 -u 表示包括未跟踪的文件 -m 表示添加暂存信息
git stash push -u -m "暂存信息"
# 查看暂存列表
git stash list
# 切换到目标分支
git checkout <目标分支>
# 恢复暂存 这里习惯使用pop命令，因为apply命令不会删除暂存，需要手动删除
git stash pop
# 到这里，我们已经成功恢复了暂存，并且删除了暂存。
```

参考文档：[git stash](https://git-scm.com/docs/git-stash/zh_HANS-CN)