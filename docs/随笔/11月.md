# 11月

## 11月3日

突发奇想，为什么Vue的`template`模板不支持`v-show`指令而支持`v-if`指令。

`v-show`是通过切换元素的CSS `display`属性来控制显示/隐藏，元素始终会被渲染到DOM中；

`template`是一个抽象的包裹元素，不会被渲染为实际的DOM节点，它只是一个逻辑容器，用于分组多个元素，最终不会再页面中产生实际的HTML元素。

既然`v-show`需要通过修改 实际 DOM 元素 的 display 属性来工作，而 `template` 根本不会渲染成实际的 DOM 元素，那么 `v-show` 就无法在 `template` 上工作。

**延展**

`template`标签跟`DocumentFragment`文档片段


## 11月4日

css兼容问题之文本描边 `text-stroke` 和 `text-shadow`

**text-stroke**

`text-stroke` 是 CSS 的一个复合属性，用于设置或检索对象中的文字的描边，在浏览器兼容上面表现较差。
它包含两个属性：`text-stroke-color` 和 `text-stroke-width`，分别用于设置描边厚度和描边颜色。

最近发现一个兼容问题，在某些情况下，描边文字笔画的连接处会出现描边重叠颜色加深的现象。

```html
<!-- 正常网页场景页面结构 -->
<div class="class-font">添加了黑色描边的白色字体</div>

<!-- chrome场景页面结构 -->
<view class="class-font">添加了黑色描边的白色字体</view>
```
```css
.class-font {
  font-size: 24px;
  color: #fff;
  -webkit-text-stroke: 1px black;
  text-stroke: 1px black;
}
```

描边正常和异常情况的示例图如下：

![text-stroke 正常和异常情况的示例图](../public/assets/随笔/text-stroke_1.png)

尝试过各种兼容性写法，都不能解决这个问题。查看资料发现 text-stroke 其实并没有出现在任何 W3C 规范中，它曾经只作为文字描边属性短暂包含在规范中，但现在已被删除。

同时它只在 Firefox 和 Edge 上能够通过使用-webkit-text-stroke属性支持该效果（没有-moz-或-ms-前缀写法的浏览器支持）。
那么我们用什么办法去解决这个问题呢？

既然 text-stroke 存在问题，那我们看下另外有没有可以替换它效果的属性就好了，经发现在 css3 版本中存在一个叫 text-shadow 的文本阴影属性也可以满足我们想要的效果。

**text-shadow**

`text-shadow` 是 css3 版本中推出的一个新的属性，它被用于向文本设置阴影效果，其在浏览器兼容方面表现很好。

```css
.class-font {
  font-size: 24px;
  color: #fff;
  text-shadow: 1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
}
```

表现示例图如下：

![text-shadow 表现示例图](../public/assets/随笔/text-stroke_2.png)

在这里要说一下 text-shadow 和 text-stroke 两个属性在视觉方面的表现区别。

`text-stroke`属于文本内部描边，它是通过压榨文字内部空间实现的。比如一个白色的文字笔画线条粗细是4px，如果`text-stroke`设置的是一个2px厚度的黑色描边，那么这个文字的实际表现是：2px黑色描边 和 2px白色填充。

`text-shadow`则表现为文本外部描边，它相当于给文字的外部穿上了一层外套。同样4px粗细的文字笔画线条，其设置属性2px厚度的黑色文本阴影，这个文字的表现是：2px黑色描边 和 4px白色填充。

总体来说，两者视觉上表现稍有差异，但是在设置的描边厚度比较小的情况下基本是类似的，而且从使用上来说，`text-shadow`其实更贴合实际应用，所以我们完全可以直接使用 `text-shadow`来给文本实现描边效果。

## 11月5日

今天解决了一个遇到很久的问题。

在项目中，公共组件`components/GiftSwipe`目录的组件，在本地我不需要显式引入能够直接使用，但是正式环境不行，页面会报错。

```vue
<!-- 本地环境 -->
<GiftSwipe></GiftSwipe>

<!-- 正式环境 -->
<GiftSwipe></GiftSwipe>
<!-- 需要加这一行，不然会报找不到该组件的错误信息 -->
import GiftSwipe from '@/components/GiftSwipe/GiftSwipe.vue'
```

因为是环境问题，所以第一个检查构建配置文件`vite.config.ts`。

```typescript
import Components from 'unplugin-vue-components/vite';
import { VantResolver } from 'unplugin-vue-components/resolvers';

export default defineConfig({
  plugins: [
    vue(),
    Components({
      resolvers: [VantResolver()],
    }),
  ],
})
```

这里发现使用了`unplugin-vue-components`插件，这个插件可以自动引入组件。但是这个插件配置只注册了`VantResolver()`，那么他只会自动导入`Vant`组件库的组件，而不会自动导入我们自定义的组件。

在经过代码注释的测试下，我们确定了是因为这个插件引起的问题。

并且在这个过程中，发现启用这个插件时会生成一个`components.d.ts`文件，这个文件是用来声明组件的，从文件可以看到，`unplugin-vue-components`插件已经自动扫描并注册了`GiftSwipe`组件。 

```ts
import '@vue/runtime-core'

export {}

declare module '@vue/runtime-core' {
  export interface GlobalComponents {
    Carousel: typeof import('./src/components/Carousel/Carousel.vue')['default']
    CustomizeLamp: typeof import('./src/components/lamp/CustomizeLamp.vue')['default']
    GiftSwipe: typeof import('./src/components/GiftSwipe/GiftSwipe.vue')['default']
    Lamp: typeof import('./src/components/lamp/lamp.vue')['default']
    Music: typeof import('./src/components/Music/Music.vue')['default']
    NickCarousel: typeof import('./src/components/Carousel/NickCarousel.vue')['default']
    PreviewIndex: typeof import('./src/components/PreviewSvga/PreviewIndex.vue')['default']
    PreviewSvga: typeof import('./src/components/PreviewSvga.vue')['default']
    PreviewVap: typeof import('./src/components/PreviewSvga/PreviewVap.vue')['default']
    RouterLink: typeof import('vue-router')['RouterLink']
    RouterView: typeof import('vue-router')['RouterView']
  }
}
```

但是在`.gitignore`文件中，忽略了`components.d.ts`文件，所以这个文件没有被提交到仓库中。这就解释了为什么在本地可以正常使用，而在正式环境不行。

但是还有另一个问题没弄明白，为什么测试环境可以正常使用，而正式环境不行。

目前猜测时`vue-tsc`的严格程度不同，正式环境可能使用更严格的TypeScript类型检查或者`components.d.ts`文件没有被`tsconfig.json`正确包含。

因为默认生成的`components.d.ts`文件在根目录，但`tsconfig.json`只配置了`src`目录，所以`components.d.ts`文件没有被正确包含。

```ts
  "include": ["src/**/*.ts", "src/**/*.d.ts", "src/**/*.tsx", "src/**/*.vue", "src/utils.d.ts", "src/utils.d.ts"],
```
**解决方案**
```ts
// 方案1：修改 tsconfig.json 包含 components.d.ts
"include": ["src/**/*.ts", "src/**/*.d.ts", "src/**/*.tsx", "src/**/*.vue", "components.d.ts"]

// 方案2：配置 unplugin-vue-components 自动扫描自定义组件
Components({
  resolvers: [VantResolver()],
  dirs: ['src/components'], // 添加自定义组件目录
  dts: true // 确保生成类型声明文件
})
```

但是这个还不是我们想要的答案，这个是彻底解决这个问题的办法，但是我还是需要弄清楚为什么在测试环境可以正常使用，而在正式环境不行。

因为从执行命令来看，`vue-tsc`命令在测试和正式环境是完全一样的：

```bash
"test": "vue-tsc && vite build --mode test", // 测试环境
"build": "vue-tsc && vite build --mode prod" // 正式环境
```

那就可能是构建服务器的状态差异，两者使用了不同的构建服务器或构建策略。

# 测试环境与正式环境对比

| 方面 | 测试环境 | 正式环境 |
|------|---------|---------|
| 构建缓存 | 可能保留了之前的构建缓存 | 可能每次全新构建（clean build） |
| node_modules | 可能是增量更新 | 可能每次重新安装 |
| 临时文件 | 可能保留 components.d.ts | 可能被清理 |
| 构建频率 | 经常构建，有缓存 | 较少构建，每次都是干净环境 |

最终在检查`Jenkins`构建时，发现了两者的差异。

测试环境采用了普通构建策略，而正式环境则是每次都是清除残余后再构建。

```bash
# 第一次构建或开发时
npm run dev  # 或之前的某次构建
# ↓ unplugin-vue-components 生成了 components.d.ts
# ↓ 文件被保留在服务器上

# 后续的构建
npm run test
# ↓ vue-tsc 执行，找到了残留的 components.d.ts ✅
# ↓ 类型检查通过
# ↓ vite build 执行


# 正式环境
# 每次构建前清理
git clean -fdx  # 删除所有未跟踪的文件（包括 components.d.ts）
# 或
rm -rf node_modules build_v  

npm ci  # 而不是 npm install，更严格
npm run build
# ↓ vue-tsc 执行，没有找到 components.d.ts ❌
# ↓ 报错：<GiftSwipe> 组件类型未定义
```

到这里心里大概有个底了，但是因为涉及到流水线部署的原因，未能亲自验证，只能先记录下来，后续有时间再验证。