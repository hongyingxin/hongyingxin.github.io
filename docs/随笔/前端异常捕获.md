# 前端异常捕获

在之前的[前端监控平台](./前端监控平台.md)一文中提到，前端实现异常捕获主要有四种方式，今天深入学习一下。

## try...catch 语句

`try...catch`语句是 JavaScript 中用于捕获和处理异常的语句。它允许你定义一段代码，如果这段代码在执行过程中发生异常，则跳转到 `catch` 块中执行。

```js
try {
  console.log(a);
} catch (error) {
  console.log(error);
}
```

这是最精细的捕获方式，针对性最强。

**捕获范围**：只能捕获其代码块内的同步错误。

**局限性**： 无法捕获异步错误（如setTimeout内的报错，Promise内部报错）

```js
// 1. setTimeout 内的报错无法捕获
try {
  setTimeout(() => {
    // 1秒后执行时，try..catch 已经执行完毕，无法捕获到错误
    console.log(a);
  }, 1000);
} catch (error) {
  // 这里不会被触发
  console.log(error);
}
// 2. Promise 内部报错无法捕获
try {
  new Promise((resolve, reject) => {
    throw new Error('Promise 内部报错');
  });
} catch (error) {
  // 同样无法捕获，除非使用 await
  console.log(error);
}
```

另外需要注意的是，`Sentry`平台也是无法感知到`try...catch`语句的错误。如果想要在后台看到它，可以手动调用`Sentry`的`captureException`方法进行上报。

```js
try {
  console.log(a);
} catch (error) {
  // 手动上报给 Sentry
  Sentry.captureException(error); 
}
```

## onerror

`window.onerror`是浏览器提供的全局错误处理函数。当页面发生错误时，会调用该函数。

```js
window.onerror = function (message, source, lineno, colno, error) {
  console.log(message, source, lineno, colno, error);
};
```

**捕获范围**：JS 运行时错误（如变量未定义、函数不存在）

**局限性**：

- 无法捕获资源加载错误（因为资源错误不冒泡）
- 无法捕获 Promise 异常

`window.onerror` 兼容性好，能获取到错误的具体内容。其回调函数包含以下五个参数：

- `message`：错误信息（字符串）。
- `source`：发生错误的脚本 URL。
- `lineno`：发生错误的行号。
- `colno`：发生错误的列号。
- `error`：Error 对象（包含堆栈信息等）。

```js
window.onerror = function (message, source, lineno, colno, error) {
  console.log('错误信息：', message);
  console.log('错误来源：', source);
  console.log('行号：', lineno);
  console.log('列号：', colno);
  console.log('错误对象：', error);
};

console.log(a);

// 输出：
// 错误信息：ReferenceError: a is not defined
// 错误来源：http://localhost:5173/
// 行号：1
// 列号：1
// 错误对象：ReferenceError: a is not defined
```

## error事件

`error`事件是浏览器提供的全局错误处理事件。当页面发生错误时，会调用该事件。这也是目前最推荐的全局监控方式。

```js
window.addEventListener('error', function (event) {
  console.log(event);
});
```

**捕获范围**：

- JS运行时错误（如变量未定义、函数不存在）
- 资源加载错误（如图片加载失败、脚本加载失败）

**局限性**：无法捕获Promise异常

这里需要注意的是，如果想捕获资源加载错误，必须将第三个参数设置为 true（开启捕获阶段）。原理是资源加载失败事件（ErrorEvent）在 target 处触发后不会冒泡。如果在冒泡阶段（默认 false）监听 window，是收不到信息的。只有在捕获阶段，从 window 往下走的时候才能拦截到。

`window.addEventListener('error')` 的回调函数接收一个 `event` 对象。根据错误类型的不同，该对象的属性也有所区别：

**1. JS 运行时错误（ErrorEvent）**：
- `event.message`：错误信息。
- `event.filename`：发生错误的脚本 URL。
- `event.lineno`：行号。
- `event.colno`：列号。
- `event.error`：Error 对象。

**2. 资源加载错误（Event）**：
- `event.target`：触发错误的元素（如 `<img>`、`<script>`）。
- 注意：资源加载错误对象通常不包含 `message`、`lineno` 等属性。

```js
window.addEventListener('error', function (event) {
  if (event.target && (event.target.src || event.target.href)) {
    console.log('资源加载错误：', event.target.localName, event.target.src || event.target.href);
  } else {
    console.log('JS 运行时错误：', event.message, event.filename, event.lineno, event.colno, event.error);
  }
}, true); // 必须设置为 true 以在捕获阶段捕获资源加载错误

console.log(a);

// 输出：
// JS 运行时错误： ReferenceError: a is not defined
// 错误来源：http://localhost:5173/
// 行号：1
// 列号：1
// 错误对象：ReferenceError: a is not defined

const img = new Image();
img.src = 'https://invalid-domain-xxx/test.png';
document.body.appendChild(img);

// 输出：
// 资源加载错误： img https://invalid-domain-xxx/test.png
```

## unhandledrejection事件

`unhandledrejection`是专门用于捕获那些没有被`.catch()`处理的 Promise reject，是对`error`事件的补充。

```js
window.addEventListener('unhandledrejection', function (event) {
  console.log(event);
});
```

**捕获范围**：所有没有被 `.catch()` 处理的 Promise reject。

```js
window.addEventListener('unhandledrejection', function (event) {
  console.log(event);
});

new Promise((resolve, reject) => {
  reject(new Error('Promise 内部报错'));
});

// 输出：
// Promise 内部报错

new Promise((resolve, reject) => {
  reject(new Error('Promise 内部报错'));
}).catch((error) => {
  console.log(error);
});

// 输出：
// Promise 内部报错
```

## 总结对比

| 错误类型 | onerror | unhandledrejection | addEventListener('error', ..., true) |
| :--- | :---: | :---: | :---: |
| **JS 运行时错误** (如 a.b) | ✅ 能捕获 | ❌ 不能 | ✅ 能捕获 |
| **Promise 未捕获异常** | ❌ 不能 | ✅ 能捕获 | ❌ 不能 |
| **资源加载失败** (404) | ❌ 不能 | ❌ 不能 | ✅ 能捕获 |
| **语法错误** (SyntaxError) | ✅ 能捕获 | ❌ 不能 | ✅ 能捕获 |

在实际项目中（如Sentry的底层逻辑），为了实现全方位的监控，通常会组合使用：
- 使用 `window.addEventListener('error', callback, true)` 监控运行时错误和资源加载失败。
- 使用 `window.addEventListener('unhandledrejection', callback)` 监控 Promise 异常。

## 进阶探索

### 跨域脚本错误

在Sentry上报的错误中，我们能看到`Script error`这种错误。

这个问题是浏览器出于安全考虑，当页面加载来自不同域的SDK和静态资源时，如果脚本报错，仅显示`Script error`错误，获取不到堆栈。

这个问题主要通过 **CORS** 配置来解决：

- **客户端**：在 `<script>` 标签添加 `crossorigin="anonymous"` 属性。
- **服务端**：在响应头中添加 `Access-Control-Allow-Origin: *`（或指定的域名）。

### Iframe 内嵌页面错误捕获

由于同源策略，父窗口无法直接通过 `window.addEventListener('error')` 捕获到不同源 iframe 内部的错误。

需要在 `iframe` 内部也注入监控代码，或者在父页面通过 `iframe.contentWindow.onerror` 进行监听（前提是同源）。

```js
window.frames[0].onerror = function (message, source, lineno, colno, error) {
  console.log('捕获到 iframe 错误：', message);
};
```

### 框架异常处理

Vue 和 React 框架内部会捕获部分异常，有时这些异常不会冒泡到 `window`。

Vue 使用 `app.config.errorHandler` 来捕获全局错误。

```js
app.config.errorHandler = (err, vm, info) => {
  console.error('Vue 错误：', err, info);
  // 手动上报给 Sentry 或监控平台
};
```

React 通过 **Error Boundary（错误边界）** 组件来捕获子组件树中的异常。

```jsx
class ErrorBoundary extends React.Component {
  componentDidCatch(error, errorInfo) {
    // 错误上报逻辑
    console.error('React 错误：', error, errorInfo);
  }
  render() {
    return this.props.children;
  }
}
```