# 数据类型

## 前言

>请讲下 JavaScript 中的数据类型？

在前端面试中，估计大家都被这么问过。

答：JavaScript 中的数据类型包括原始类型和引用类型。其中原始类型包括 `Number`、`String`、`Boolean`、`Null`、`Undefined`、`Symbol`、`BigInt` 共 7 种，引用类型包括 `Object` 共 1 种。

一般都是这么回答的，只是这通常第一个问题，由这个问题可以引出很多很多的问题。比如：

- `Null` 和 `Undefined` 有什么区别？前端的判空有哪些需要注意的？
- `typeof null` 为什么是 `object`？
- 为什么 `ES6` 要提出 `Symbol`？
- `BigInt` 解决了什么问题？
- 为什么 `0.1 + 0.2 !== 0.3`？你如何解决这个问题？
- 如何判断一个值是数组？

## 弱类型语言

因为 JavaScript 是弱类型语言或者说是动态语言。这意味着不需要提前声明变量的类型，在程序运行的过程中，类型会被自动确定，也就是说可以使用同一个变量保存不同类型的值。

```js
var foo = 42 // foo is a Number now
foo = 'bar' // foo is a String now
foo = true // foo is a Boolean now
```

这种特性给我们带来便利的同时，也给我们带来了很多的类型错误.

对 JavaScript 的数据类型掌握，是一个前端最基本的知识点。

## null 还是 undefined

### 定义

`undefined` 表示未定义的变量。`null` 值表示一个空对象指针。

> 一开始的时候，JavaScript 设计者 Brendan Eich 其实只是定义了 `null`，`null` 像在 Java 里一样，被当成一个对象。但是因为 JavaScript 中有两种数据类型：原始数据类型和引用数据类型。Brendan Eich 觉得表示“无”的值最好不是对象。

所以 JavaScript 的设计是 `null` 是一个表示“无”的对象，转为数值时为 `0`；`undefined` 是一个表示“无”的原始值，转为数值时为 `NaN`。

```js
Number(null) // 0

5 + null // 5

Number(undefined) // NaN

5 + undefined // NaN
```

### Null 和 Undefined 的区别和应用

`null` 表示“没有对象”，即该处不应该有值。典型的用法如下：

- 1.作为函数的参数
- 2.作为对象原型链的终点

```js
Object.getPrototypeOf(Object.prototype)
```

`undefined` 表示“缺少值”，就是此处应该有一个值，但是还没有定义。典型用法：

- 1.变量被声明，但没有赋值时，就等于 `undefined`
- 2.调用函数时，应该提供的参数没有提供，该参数等于 `undefined`
- 3.对象没有赋值的属性，该属性的值为 `undefined`
- 4.函数没有返回值时，默认返回 `undefined`

```js
var i;
i // undefined

function f(x) {
  console.log(x)
}
f() // undefined

var o = new Object()
o.p // undefined

var x = f()
x // undefined
```

### 判空应该注意什么？

JavaScript 五种空值和假值，分别为 `null`、`undefined`、`NaN`、`''`、`0`、`false`。

这有时候很容易导致一些问题，比如

```js
let a = 0
console.log(a || '/')
// 本意是只要 a 为 null 或者 Undefined 的时候，输出 '/'，但实际上只要是我们以上的五种之一就输出 '/'
```
当然我们可以写成这样：

```js
let a = 0
if (a === null || a == undefined) {
  console.log('/')
} else {
  console.log(a)
}
```
虽然解决了问题，但不太优雅。于是 ES 规范提出了空值合并操作符（`??`），用于解决这个问题。

> 空值合并操作符（`??`）是一个逻辑操作符，当左侧的操作数为 `null` 或 `undefined` 时，返回其右侧操作数，否则返回左侧操作数。

```js
let a = 0
console.log(a ?? '/')
// 输出: 0
```

## typeof null

```js
typeof null // 'object'
```
JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。第一版的 JavaScript 是用 32 位比特来存储值的，且是通过值的低 1 位或 3 位来识别类型的，对象的类型标签是 `000`。如下：

- 1: 整型(`int`)
- 000: 引用类型（`object`）
- 010: 双精度类型（`double`）
- 100: 字符串类型（`string`）
- 110: 布尔类型（`boolean`）

但有两个特殊值：

- `undefined`，用整数 `-2^30` 表示（负 2 的 30 次方，不在整数的范围内）
- `null`，机器码空指针（C/C++ 宏定义），低三位也是 `000`

由于 `null` 代表的是空指针，因此 `null` 的类型标签是 `000`，所以 `typeof null` 会返回 `'object'`。

## Number————0.1+0.2 !== 0.3

### 现象

在 JavaScript 会存在类似如下的现象

```js
0.1 + 0.2 = 0.30000000000000004
```
### 原因

我们在对浮点数进行运算的过程中，需要将十进制转换成二进制。十进制小数转换为二进制的规则如下：

> 对小数点以后的数乘以 2，取结果的整数部分（不是 1 就是 0），然后再用小数部分再乘以 2，再取结果的整数部分，以此类推，直到小数部分为 0 或者位数已经够了，然后把取的整数部分按先后次序排列。

根据上面的规则，最后 0.1 的表示如下：

> 0.000110011001100110011

所以说，精度丢失并不是语言的问题，而是浮点数存储本身固有的缺陷。

JavaScript 是以 64 位双精度浮点数存储所有 `Number` 类型值，按照 `IEEE 754` 标准，`0.1` 的二进制只保留 52 位有效数字，即
> 1.100110011001100110011001100110011001100110011001101 * 2^(-4)
同理，0.2 的二进制数为
> 1.100110011001100110011001100110011001100110011001101 * 2^(-3)
这样在进制之间的转换中精度已经损失，运算的时候如下：

```js
0.00011001100110011001100110011001100110011001100110011010
+0.00110011001100110011001100110011001100110011001100110100
=0.01001100110011001100110011001100110011001100110011001110
```
所以导致了最后的计算结果中 0.1 + 0.2 !== 0.3

### 如何解决

- 将数字转换成整数

```js
function add(num1, num2) {
  const num1Digits = (num1.toString().split('.')[1] || '').length;
  const num2Digits = (num2.toString().split('.')[1] || '').length;
  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
  return (num1 * baseNum + num2 * baseNum) / baseNum;
}
```

- 类库

NPM 上有许多支持 JavaScript 和 Node.js 的数学库，比如 `mathjs`、`decimal.js` 等.

- ES6

ES6 在 Number 对象上新增了一个极小的常量 `Number.EPSILON`，用于解决浮点数运算的精度问题。

```js
Number.EPSILON
// 2.220446049250313e-16
Number.EPSILON.toFixed(20)
// "0.00000000000000022204"
``` 

引入一个这么小的量，目的在于为浮点数计算设置一个误差范围，如果误差能够小于 Number.EPSILON，就可以认为结果是相等的。

```js
function withinErrorMargin (left, right) {
  return Math.abs(left - right) < Number.EPSILON
}
withinErrorMargin(0.1+0.2, 0.3)
```

## Symbol

### 定义

`ES6` 引入了一种新的原始数据类型 `Symbol`，表示独一无二的值.

```js
let s = Symbol()
typeof s // 'symbol'
```

### 应用场景

- 定义一组常量，保证这组常量都是不相等的。消除魔法字符串

- 对象中保证不同的属性名

```js
let mySymbol = Symbol();

// 第一种写法
let a = {};
a[mySymbol] = 'Hello!';

// 第二种写法
let a = {
[mySymbol]: 'Hello!'
};

// 第三种写法
let a = {};
Object.defineProperty(a, mySymbol, { value: 'Hello!' });

// 以上写法都得到同样结果
a[mySymbol] // "Hello!"
```

- `Vue` 中的 `provide` 和 `inject`。`provide` 和 `inject` 允许一个祖先组件向其所有子孙后代注入一个依赖，无论组件层级有多深，并在其上下游关系成立的时间里始终生效。但这个侵入性也是非常强，使用 `Symbol` 作为 `key` 可以减少对组件代码的干扰，避免命名冲突等问题。

## 数组

> 请说下判断 `Array` 的方法？

### 为什么会问这个问题？

因为数组是一个特殊的存在，是我们平时接触得最多的数据结构之一，它是一个特殊对象，它的索引就是“普通对象”的 `key` 值，但它又拥有一些“普通对象”没有的方法，比如 `map` 等。

`typeof` 是 JavaScript 原生提供的判断数据类型的运算符，它会返回一个表示参数数据类型的字符串。但是我们不能通过 `typeof` 判断是否为数组。因为 `typeof` 数组、普通对象以及 `null`，都会返回 `'object'`。

```js
typeof [] // 'object'
typeof {} // 'object'
typeof null // 'object'
```
### 判断数组的方法

- `Object.prototype.toString.call()`

每一个继承 `Object` 的对象都有 `toString()` 方法。如果 `toString` 方法没有重写的话，会返回 `[object type]` 的形式，其中 `type` 为对象的类型。

```js
const a = ['Hello','Howard'];
const b = {0:'Hello',1:'Howard'};
const c = 'Hello Howard';
Object.prototype.toString.call(a);//"[object Array]"
Object.prototype.toString.call(b);//"[object Object]"
Object.prototype.toString.call(c);//"[object String]"
```

- `Array.isArray()`

`Array.isArray()` 是 `ES5` 新增的方法，用于判断一个值是否为数组。当不存在 `Array.isArray()`，可以用 `Object.prototype.toString.call()` 实现。

```js
Array.isArray([]) // true
Array.isArray({}) // false
Array.isArray('Hello Howard') // false

if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}
```
- `instanceof`

`instanceof` 运算符可以用来判断某个构造函数的 `prototype` 属性所指向的对象是否存在于另外一个要检测对象的原型链上。因为数组的构造函数是 `Array`，所以可以通过以下判断。

> 注意：因为数组也是对象，所以 `instanceof Object` 也是 `true`。

```js
const a = [];
const b = {};
console.log(a instanceof Array);//true
console.log(a instanceof Object);//true,在数组的原型链上也能找到Object构造函数
console.log(b instanceof Array);//false
```

- `constructor`

`constructor` 通过构造函数实例化的实例，拥有一个 `constructor` 属性。

```js
function B() {};
let b = new B();
console.log(b.constructor === B) // true
```

而数组是由一个叫 `Array` 的函数实例化的。所以可以：

```js
let c = []
console.log(c.constructor === Array) // true
```

>注意：constructor 是会被改变的。所以不推荐这样判断

```js
let c = []
c.constructor = String
console.log(c.constructor === Array) // false
```

## 常见考点

### 1. 基本数据类型 (Primitive Types)
JavaScript 有七种基本数据类型：
- **Number**：表示数字，包括整数和浮点数。
- **String**：表示字符串，文本数据。
- **Boolean**：表示布尔值，只有 `true` 和 `false`。
- **Undefined**：表示未定义的值，通常是变量声明但未赋值时的状态。
- **Null**：表示空值，表示“无”或“缺失”。
- **Symbol** (ES6)：表示唯一的标识符，用于对象属性的键。
- **BigInt** (ES2020)：用于表示任意精度的整数，允许处理超过 `Number.MAX_SAFE_INTEGER` 的整数。

### 2. 引用数据类型 (Reference Types)
- **Object**：引用类型的集合，包括数组、函数、日期、正则表达式等。
- **Array**：特殊的对象，表示有序的数据集合。考察点：常用方法（如 `push`, `pop`, `map`, `filter`, `reduce` 等）。
- **Function**：函数也是对象，可以作为一等公民。考察点：函数的属性和方法（如 `call`, `apply`, `bind`）。

### 3. 数据类型检查
- **typeof 操作符**：用于检测基本类型。注意 `typeof null` 的历史遗留问题。
  ```js
  typeof 'hello'; // "string"
  typeof 42;      // "number"
  typeof {};      // "object"
  typeof null;    // "object" (历史遗留 Bug)
  ```
- **instanceof 操作符**：用于检查对象的原型链。
  ```js
  [] instanceof Array; // true
  [] instanceof Object; // true
  ```
- **Object.prototype.toString.call()**：最准确的类型判断方法。

### 4. 类型转换
- **隐式转换**：在运算或逻辑判断时自动转换（如 `'5' - 1 // 4`, `'5' + 1 // '51'`）。
- **显式转换**：使用 `String()`, `Number()`, `Boolean()`, `parseInt()`, `parseFloat()` 等进行转换。

### 5. NaN 和 Infinity
- **NaN** (Not a Number)：表示不是一个数字。使用 `Number.isNaN()` 判断。
- **Infinity**：表示正负无穷大。

### 6. 值传递与引用传递
- **基本类型**：按值传递，传递的是值的副本，修改互不影响。
- **引用类型**：按引用传递，传递的是内存地址的指针，修改会影响原对象。

### 7. null vs. undefined
- `null` 表示“定义了但为空”（空对象指针）。
- `undefined` 表示“未定义”或“缺少值”。

### 8. 对象的可变性
- 对象的属性可以动态添加和删除：
  ```js
  const obj = {};
  obj.name = 'Alice'; // 添加
  delete obj.name;    // 删除
  ```
- **冻结对象**：`Object.freeze()` 可以使对象不可变。

### 9. 特殊对象
- **Array vs Object**：在性能、用途、内置方法上的差异。
- **Date 和 RegExp**：常用日期处理和正则表达式匹配。

### 10. 新型数据结构 (ES6+)
- **Map 和 Set**：
  ```js
  const myMap = new Map();
  myMap.set('key', 'value');
  
  const mySet = new Set([1, 2, 2, 3]); // [1, 2, 3] 去重
  ```
- **WeakMap 和 WeakSet**：弱引用版本，有助于垃圾回收。

### 11. 比较操作符 (== vs ===)
- `==`（等值比较）：会发生隐式类型转换。
- `===`（全等比较）：不进行转换，要求类型和值都相同。
  ```js
  null == undefined;  // true
  null === undefined; // false
  ```

### 12. 内存管理与垃圾回收
- **引用计数**：查看对象是否有引用指向它。
- **标记清除**：从根对象开始扫描，不可达的对象将被回收。
- **内存泄漏**：常见的有全局变量、闭包未释放、定时器未清除等。

### 13. 性能优化
- 如何选择合适的数据类型以优化性能（例如在大量数据下使用类型化数组 `TypedArray`）。

### 14. 类型安全 (TypeScript)
- 强类型检查的重要性，包括接口（Interface）、类型别名（Type Alias）和泛型（Generics）。
